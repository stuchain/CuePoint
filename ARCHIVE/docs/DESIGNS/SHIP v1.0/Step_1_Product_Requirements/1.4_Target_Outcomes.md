# Implementation Step 1.4: Target Outcomes (v1.0)

## Implementation Overview
**What We're Building**: Implement the four target outcomes that define v1.0 success: Installation, Trust, Reliability, and Update capabilities.

## Implementation Tasks

### Task 1.4.1: Implement Installation Outcome

**What to Build**
- PyInstaller build configuration
- macOS DMG creation
- Windows NSIS installer
- Installation testing infrastructure

**Implementation Details**

**1.4.1.1 PyInstaller Configuration**
- **File to Create**: `build/pyinstaller.spec`
- **Implementation**:
  ```python
  # -*- mode: python ; coding: utf-8 -*-
  a = Analysis(
      ['SRC/main.py'],
      pathex=[],
      binaries=[],
      datas=[
          ('SRC/cuepoint/ui/resources', 'cuepoint/ui/resources'),
          ('config', 'config'),
      ],
      hiddenimports=[
          'PySide6.QtCore',
          'PySide6.QtWidgets',
          # ... all required imports
      ],
      hookspath=[],
      hooksconfig={},
      runtime_hooks=[],
      excludes=[],
      noarchive=False,
  )
  pyz = PYZ(a.pure)
  exe = EXE(
      pyz,
      a.scripts,
      a.binaries,
      a.datas,
      [],
      name='CuePoint',
      debug=False,
      bootloader_ignore_signals=False,
      strip=False,
      upx=True,
      upx_exclude=[],
      runtime_tmpdir=None,
      console=False,
      disable_windowed_traceback=False,
      argv_emulation=False,
      target_arch=None,
      codesign_identity=None,
      entitlements_file=None,
  )
  ```
- **Purpose**: Bundle Python runtime and all dependencies
- **Location**: `build/` directory
- **Dependencies**: PyInstaller installed

**1.4.1.2 macOS DMG Creation**
- **File to Create**: `scripts/create_dmg.sh`
- **Implementation**:
  ```bash
  #!/bin/bash
  # Create DMG for macOS distribution
  APP_NAME="CuePoint"
  DMG_NAME="${APP_NAME}-v${VERSION}-macos-universal"
  
  # Create temporary directory
  TEMP_DIR=$(mktemp -d)
  
  # Copy app to temp directory
  cp -R "dist/${APP_NAME}.app" "${TEMP_DIR}/"
  
  # Create Applications symlink
  ln -s /Applications "${TEMP_DIR}/Applications"
  
  # Create DMG
  hdiutil create -volname "${APP_NAME}" \
    -srcfolder "${TEMP_DIR}" \
    -ov -format UDZO \
    "dist/${DMG_NAME}.dmg"
  
  # Cleanup
  rm -rf "${TEMP_DIR}"
  ```
- **Purpose**: Create distributable DMG file
- **Location**: `scripts/` directory
- **Dependencies**: macOS build environment, hdiutil

**1.4.1.3 Windows NSIS Installer**
- **File to Create**: `scripts/installer.nsi`
- **Implementation**:
  ```nsis
  !include "MUI2.nsh"
  
  Name "CuePoint"
  OutFile "CuePoint-v${VERSION}-windows-x64-setup.exe"
  InstallDir "$LOCALAPPDATA\CuePoint"
  RequestExecutionLevel user
  
  !insertmacro MUI_PAGE_WELCOME
  !insertmacro MUI_PAGE_DIRECTORY
  !insertmacro MUI_PAGE_INSTFILES
  !insertmacro MUI_PAGE_FINISH
  
  Section "Install"
    SetOutPath "$INSTDIR"
    File /r "dist\CuePoint\*"
    
    # Create Start Menu shortcut
    CreateShortcut "$SMPROGRAMS\CuePoint.lnk" "$INSTDIR\CuePoint.exe"
    
    # Create uninstaller
    WriteUninstaller "$INSTDIR\uninstall.exe"
  SectionEnd
  
  Section "Uninstall"
    RMDir /r "$INSTDIR"
    Delete "$SMPROGRAMS\CuePoint.lnk"
  SectionEnd
  ```
- **Purpose**: Create Windows installer
- **Location**: `scripts/` directory
- **Dependencies**: NSIS compiler

**1.4.1.4 Installation Testing**
- **File to Create**: `SRC/tests/acceptance/test_installation.py`
- **Implementation**:
  ```python
  def test_macos_installation():
      """Test macOS DMG installation"""
      # Mount DMG
      # Verify app structure
      # Test launch
      # Verify no Python required
      
  def test_windows_installation():
      """Test Windows installer"""
      # Run installer
      # Verify installation
      # Test launch
      # Verify no Python required
  ```
- **Purpose**: Automated installation testing
- **Location**: `SRC/tests/acceptance/` directory

### Task 1.4.2: Implement Trust Outcome

**What to Build**
- macOS code signing setup
- macOS notarization workflow
- Windows code signing setup
- Trust verification testing

**Implementation Details**

**1.4.2.1 macOS Code Signing**
- **File to Create**: `scripts/sign_macos.sh`
- **Implementation**:
  ```bash
  #!/bin/bash
  # Sign macOS app bundle
  APP_PATH="dist/CuePoint.app"
  CERT_NAME="Developer ID Application: Your Name"
  
  # Sign nested frameworks
  find "${APP_PATH}" -name "*.dylib" -exec \
    codesign --force --options runtime --timestamp \
    --sign "${CERT_NAME}" {} \;
  
  # Sign app bundle
  codesign --force --deep --options runtime --timestamp \
    --sign "${CERT_NAME}" "${APP_PATH}"
  
  # Verify
  codesign --verify --deep --strict --verbose=2 "${APP_PATH}"
  spctl -a -vv --type execute "${APP_PATH}"
  ```
- **Purpose**: Sign app for macOS Gatekeeper
- **Dependencies**: Apple Developer ID certificate
- **Integration**: Part of CI/CD pipeline (Step 2)

**1.4.2.2 macOS Notarization**
- **File to Create**: `scripts/notarize_macos.sh`
- **Implementation**:
  ```bash
  #!/bin/bash
  # Notarize macOS DMG
  DMG_PATH="dist/CuePoint-v${VERSION}-macos-universal.dmg"
  
  # Submit for notarization
  xcrun notarytool submit "${DMG_PATH}" \
    --keychain-profile "notarytool-profile" \
    --wait
  
  # Staple
  xcrun stapler staple "${DMG_PATH}"
  
  # Verify
  spctl -a -vv "${DMG_PATH}"
  ```
- **Purpose**: Notarize app for macOS
- **Dependencies**: Apple Developer account, notarytool configured
- **Integration**: Part of CI/CD pipeline (Step 2)

**1.4.2.3 Windows Code Signing**
- **File to Create**: `scripts/sign_windows.ps1`
- **Implementation**:
  ```powershell
  # Sign Windows executable
  $exePath = "dist\CuePoint.exe"
  $certPath = $env:WINDOWS_CERT_PFX
  $certPassword = $env:WINDOWS_CERT_PASSWORD
  
  # Sign executable
  signtool sign /f $certPath /p $certPassword /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 $exePath
  
  # Verify
  signtool verify /pa /v $exePath
  ```
- **Purpose**: Sign Windows executable
- **Dependencies**: Code signing certificate
- **Integration**: Part of CI/CD pipeline (Step 2)

**1.4.2.4 Trust Verification Testing**
- **File to Create**: `SRC/tests/acceptance/test_trust.py`
- **Implementation**:
  ```python
  def test_macos_gatekeeper():
      """Test macOS Gatekeeper acceptance"""
      # Install on fresh macOS
      # Launch app
      # Verify no warnings
      
  def test_windows_smartscreen():
      """Test Windows SmartScreen"""
      # Install on fresh Windows
      # Launch app
      # Verify minimal warnings
  ```
- **Purpose**: Verify trust indicators work
- **Location**: `SRC/tests/acceptance/` directory

### Task 1.4.3: Implement Reliability Outcome

**What to Build**
- Standard storage paths implementation
- Error handling framework
- Data integrity mechanisms
- State persistence system

**Implementation Details**

**1.4.3.1 Standard Storage Paths**
- **File to Create**: `SRC/cuepoint/utils/paths.py`
- **Implementation**:
  ```python
  from PySide6.QtCore import QStandardPaths
  from pathlib import Path
  
  class AppPaths:
      """Standard application paths"""
      @staticmethod
      def config_dir() -> Path:
          return Path(QStandardPaths.writableLocation(
              QStandardPaths.AppConfigLocation
          )) / "CuePoint"
      
      @staticmethod
      def data_dir() -> Path:
          return Path(QStandardPaths.writableLocation(
              QStandardPaths.AppLocalDataLocation
          )) / "CuePoint"
      
      @staticmethod
      def cache_dir() -> Path:
          return Path(QStandardPaths.writableLocation(
              QStandardPaths.CacheLocation
          )) / "CuePoint"
      
      @staticmethod
      def logs_dir() -> Path:
          return Path(QStandardPaths.writableLocation(
              QStandardPaths.AppLocalDataLocation
          )) / "CuePoint" / "Logs"
  ```
- **Purpose**: Consistent paths across OS
- **Usage**: Import and use throughout app

**1.4.3.2 Error Handling Framework**
- **File to Modify**: `SRC/cuepoint/utils/error_handler.py`
- **Implementation**:
  ```python
  class ErrorHandler:
      """Centralized error handling"""
      @staticmethod
      def handle_error(error: Exception, context: str) -> str:
          """Handle error and return user-friendly message"""
          # Log error
          logger.error(f"{context}: {error}", exc_info=True)
          
          # Return user-friendly message
          if isinstance(error, FileNotFoundError):
              return f"File not found. Please check the path and try again."
          elif isinstance(error, PermissionError):
              return f"Permission denied. Please check file permissions."
          # ... more error types
          
          return f"An error occurred: {str(error)}. Check logs for details."
  ```
- **Purpose**: Consistent error messages
- **Integration**: Use in all services and UI

**1.4.3.3 Data Integrity Mechanisms**
- **File to Modify**: `SRC/cuepoint/services/output_writer.py`
- **Implementation**:
  ```python
  def safe_write_file(file_path: Path, content: str):
      """Atomically write file"""
      temp_path = file_path.with_suffix('.tmp')
      
      # Write to temp file
      with open(temp_path, 'w', encoding='utf-8') as f:
          f.write(content)
          f.flush()
          os.fsync(f.fileno())
      
      # Atomic rename
      temp_path.replace(file_path)
  ```
- **Purpose**: Prevent data corruption
- **Usage**: All file write operations

**1.4.3.4 State Persistence**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  from PySide6.QtCore import QSettings
  
  class MainWindow:
      def __init__(self):
          self.settings = QSettings()
          self.restore_state()
      
      def save_state(self):
          """Save window state"""
          self.settings.setValue("geometry", self.saveGeometry())
          self.settings.setValue("windowState", self.saveState())
          self.settings.setValue("last_xml", self.xml_path)
      
      def restore_state(self):
          """Restore window state"""
          geometry = self.settings.value("geometry")
          if geometry:
              self.restoreGeometry(geometry)
  ```
- **Purpose**: Persist UI state
- **Integration**: All UI components

### Task 1.4.4: Implement Update Outcome

**What to Build**
- Update checker service
- Update dialog UI
- Update feed generation
- Update installation flow

**Implementation Details**

**1.4.4.1 Update Checker Service**
- **File to Create**: `SRC/cuepoint/services/update_checker.py`
- **Implementation**: See Step 5 for full implementation
- **Purpose**: Check for available updates
- **Dependencies**: Sparkle (macOS) or WinSparkle (Windows)

**1.4.4.2 Update Dialog UI**
- **File to Create**: `SRC/cuepoint/ui/dialogs/update_dialog.py`
- **Implementation**: See Step 5 for full implementation
- **Purpose**: Show update prompt to user
- **Integration**: Called from update checker

**1.4.4.3 Update Feed Generation**
- **File to Create**: `scripts/generate_appcast.py`
- **Implementation**: See Step 5 for full implementation
- **Purpose**: Generate appcast XML for updates
- **Integration**: Part of CI/CD release process

**1.4.4.4 Update Installation Flow**
- **Implementation**: Handled by Sparkle/WinSparkle
- **Purpose**: Download and install updates
- **Dependencies**: Signed update packages

## Implementation Checklist

### Installation
- [ ] Create PyInstaller spec file
- [ ] Create macOS DMG script
- [ ] Create Windows NSIS installer
- [ ] Create installation tests
- [ ] Test on clean VMs

### Trust
- [ ] Set up macOS code signing
- [ ] Set up macOS notarization
- [ ] Set up Windows code signing
- [ ] Create trust verification tests
- [ ] Test on fresh machines

### Reliability
- [ ] Implement standard paths
- [ ] Enhance error handling
- [ ] Implement safe file writes
- [ ] Implement state persistence
- [ ] Test data integrity

### Update
- [ ] Implement update checker (Step 5)
- [ ] Create update dialog (Step 5)
- [ ] Set up update feed (Step 5)
- [ ] Test update flow (Step 5)

## Files to Create/Modify

### Build Files
1. `build/pyinstaller.spec` - PyInstaller configuration
2. `scripts/create_dmg.sh` - macOS DMG creation
3. `scripts/installer.nsi` - Windows installer script
4. `scripts/sign_macos.sh` - macOS signing
5. `scripts/notarize_macos.sh` - macOS notarization
6. `scripts/sign_windows.ps1` - Windows signing
7. `scripts/generate_appcast.py` - Update feed generation (Step 5)

### Code Files
1. `SRC/cuepoint/utils/paths.py` - Standard paths
2. `SRC/cuepoint/utils/error_handler.py` - Error handling (enhance)
3. `SRC/cuepoint/services/output_writer.py` - Safe writes (enhance)
4. `SRC/cuepoint/ui/main_window.py` - State persistence (enhance)
5. `SRC/cuepoint/services/update_checker.py` - Update checking (Step 5)
6. `SRC/cuepoint/ui/dialogs/update_dialog.py` - Update dialog (Step 5)

### Test Files
1. `SRC/tests/acceptance/test_installation.py` - Installation tests
2. `SRC/tests/acceptance/test_trust.py` - Trust verification tests

## Implementation Dependencies

### Prerequisites
- Step 1.1-1.3: Product definition and workflows
- Step 2: Build system (for CI/CD integration)

### Enables
- Step 3: macOS packaging (uses installation scripts)
- Step 4: Windows packaging (uses installer script)
- Step 5: Update system (uses update components)

## Success Criteria

### Installation
- ✅ Installation success rate > 95%
- ✅ Installation time < 2 minutes
- ✅ No Python required

### Trust
- ✅ macOS: 0% Gatekeeper warnings
- ✅ Windows: < 10% SmartScreen blocks
- ✅ All artifacts signed

### Reliability
- ✅ Export success rate > 99%
- ✅ Error recovery rate > 90%
- ✅ No data loss incidents

### Update
- ✅ Update check success > 95%
- ✅ Update adoption > 80%
- ✅ Update installation success > 90%

## Next Implementation Steps

After completing Step 1.4:
1. **Step 2**: Build system (integrates installation/trust)
2. **Step 3**: macOS packaging (implements installation/trust)
3. **Step 4**: Windows packaging (implements installation/trust)
4. **Step 5**: Update system (implements update outcome)
5. **Step 6**: Runtime design (implements reliability)

## Detailed Implementation Analysis

### Installation Outcome - Deep Dive

**1.4.1.5 PyInstaller Configuration Details**
- **Complete Spec File Structure**:
  ```python
  # -*- mode: python ; coding: utf-8 -*-
  import sys
  from PyInstaller.utils.hooks import collect_data_files, collect_submodules
  
  # Collect all data files
  datas = [
      ('SRC/cuepoint/ui/resources', 'cuepoint/ui/resources'),
      ('config', 'config'),
      ('SRC/cuepoint/data', 'cuepoint/data'),
  ]
  
  # Collect hidden imports
  hiddenimports = [
      # PySide6 modules
      'PySide6.QtCore',
      'PySide6.QtWidgets',
      'PySide6.QtGui',
      'PySide6.QtNetwork',
      # Core modules
      'cuepoint.core.scraper',
      'cuepoint.core.matcher',
      'cuepoint.data.xml_parser',
      # Services
      'cuepoint.services.output_writer',
      # Utils
      'cuepoint.utils.paths',
      'cuepoint.utils.error_handler',
      # Third-party
      'requests',
      'requests_cache',
      'bs4',
      'lxml',
  ]
  
  # Analysis
  a = Analysis(
      ['SRC/main.py'],
      pathex=['SRC'],
      binaries=[],
      datas=datas,
      hiddenimports=hiddenimports,
      hookspath=[],
      hooksconfig={},
      runtime_hooks=[],
      excludes=['tkinter', 'matplotlib', 'numpy.distutils'],
      win_no_prefer_redirects=False,
      win_private_assemblies=False,
      cipher=None,
      noarchive=False,
  )
  
  # PYZ archive
  pyz = PYZ(a.pure, a.zipped_data, cipher=None)
  
  # Executable
  exe = EXE(
      pyz,
      a.scripts,
      a.binaries,
      a.zipfiles,
      a.datas,
      [],
      name='CuePoint',
      debug=False,
      bootloader_ignore_signals=False,
      strip=False,
      upx=True,
      upx_exclude=[],
      runtime_tmpdir=None,
      console=False,
      disable_windowed_traceback=False,
      argv_emulation=False,
      target_arch=None,
      codesign_identity=None,
      entitlements_file=None,
      icon='SRC/cuepoint/ui/resources/icon.icns',  # macOS
      # icon='SRC/cuepoint/ui/resources/icon.ico',  # Windows
  )
  
  # macOS app bundle
  app = BUNDLE(
      exe,
      name='CuePoint.app',
      icon='SRC/cuepoint/ui/resources/icon.icns',
      bundle_identifier='com.stuchain.cuepoint',
      info_plist={
          'NSPrincipalClass': 'NSApplication',
          'NSHighResolutionCapable': 'True',
          'LSMinimumSystemVersion': '10.15',
      },
  )
  ```
- **Platform-Specific Considerations**:
  - **macOS**: Create .app bundle with Info.plist
  - **Windows**: Create single executable or directory structure
  - **Dependencies**: Ensure all DLLs/dylibs included
  - **Size Optimization**: Use UPX compression, exclude unused modules

**1.4.1.6 macOS DMG Creation - Complete Script**
- **Enhanced DMG Script**:
  ```bash
  #!/bin/bash
  set -e
  
  # Configuration
  APP_NAME="CuePoint"
  VERSION="${1:-1.0.0}"
  DMG_NAME="${APP_NAME}-v${VERSION}-macos-universal"
  TEMP_DIR=$(mktemp -d)
  DMG_DIR="${TEMP_DIR}/${APP_NAME}"
  
  # Cleanup function
  cleanup() {
      rm -rf "${TEMP_DIR}"
  }
  trap cleanup EXIT
  
  # Create DMG directory structure
  mkdir -p "${DMG_DIR}"
  
  # Copy app bundle
  if [ ! -d "dist/${APP_NAME}.app" ]; then
      echo "Error: App bundle not found at dist/${APP_NAME}.app"
      exit 1
  fi
  cp -R "dist/${APP_NAME}.app" "${DMG_DIR}/"
  
  # Create Applications symlink
  ln -s /Applications "${DMG_DIR}/Applications"
  
  # Create README
  cat > "${DMG_DIR}/README.txt" << EOF
  CuePoint ${VERSION}
  
  Installation:
  1. Drag CuePoint.app to the Applications folder
  2. Open Applications and launch CuePoint
  
  System Requirements:
  - macOS 10.15 or later
  - 100MB free disk space
  EOF
  
  # Create DMG
  echo "Creating DMG..."
  hdiutil create -volname "${APP_NAME}" \
    -srcfolder "${DMG_DIR}" \
    -ov -format UDZO \
    -fs HFS+ \
    -imagekey zlib-level=9 \
    "dist/${DMG_NAME}.dmg"
  
  echo "DMG created: dist/${DMG_NAME}.dmg"
  ```
- **DMG Customization**:
  - Background image
  - Window size and position
  - Icon positions
  - **Implementation**: Use `create-dmg` tool or manual layout

**1.4.1.7 Windows NSIS Installer - Complete Script**
- **Enhanced NSIS Script**:
  ```nsis
  !include "MUI2.nsh"
  !include "FileFunc.nsh"
  
  # Application information
  Name "CuePoint"
  OutFile "CuePoint-v${VERSION}-windows-x64-setup.exe"
  InstallDir "$LOCALAPPDATA\CuePoint"
  RequestExecutionLevel user
  
  # Version information
  VIProductVersion "${VERSION}.0"
  VIAddVersionKey "ProductName" "CuePoint"
  VIAddVersionKey "FileDescription" "CuePoint Installer"
  VIAddVersionKey "FileVersion" "${VERSION}"
  VIAddVersionKey "ProductVersion" "${VERSION}"
  VIAddVersionKey "CompanyName" "StuChain"
  
  # Interface settings
  !define MUI_ICON "SRC\cuepoint\ui\resources\icon.ico"
  !define MUI_UNICON "SRC\cuepoint\ui\resources\icon.ico"
  !define MUI_HEADERIMAGE
  !define MUI_HEADERIMAGE_BITMAP "SRC\cuepoint\ui\resources\header.bmp"
  
  # Pages
  !insertmacro MUI_PAGE_WELCOME
  !insertmacro MUI_PAGE_LICENSE "LICENSE.txt"
  !insertmacro MUI_PAGE_DIRECTORY
  !insertmacro MUI_PAGE_INSTFILES
  !define MUI_FINISHPAGE_RUN "$INSTDIR\CuePoint.exe"
  !define MUI_FINISHPAGE_RUN_TEXT "Launch CuePoint"
  !insertmacro MUI_PAGE_FINISH
  
  !insertmacro MUI_UNPAGE_CONFIRM
  !insertmacro MUI_UNPAGE_INSTFILES
  
  # Languages
  !insertmacro MUI_LANGUAGE "English"
  
  # Installation section
  Section "Install" SecMain
      SetOutPath "$INSTDIR"
      
      # Install files
      File /r "dist\CuePoint\*"
      
      # Create Start Menu shortcut
      CreateDirectory "$SMPROGRAMS\CuePoint"
      CreateShortcut "$SMPROGRAMS\CuePoint\CuePoint.lnk" "$INSTDIR\CuePoint.exe"
      CreateShortcut "$SMPROGRAMS\CuePoint\Uninstall.lnk" "$INSTDIR\uninstall.exe"
      
      # Create Desktop shortcut (optional)
      ; CreateShortcut "$DESKTOP\CuePoint.lnk" "$INSTDIR\CuePoint.exe"
      
      # Create uninstaller
      WriteUninstaller "$INSTDIR\uninstall.exe"
      
      # Registry entries
      WriteRegStr HKCU "Software\CuePoint" "InstallPath" "$INSTDIR"
      WriteRegStr HKCU "Software\CuePoint" "Version" "${VERSION}"
      
      # Uninstaller registry
      WriteRegStr HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\CuePoint" \
          "DisplayName" "CuePoint"
      WriteRegStr HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\CuePoint" \
          "UninstallString" "$INSTDIR\uninstall.exe"
      WriteRegStr HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\CuePoint" \
          "DisplayVersion" "${VERSION}"
      WriteRegDWORD HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\CuePoint" \
          "NoModify" 1
      WriteRegDWORD HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\CuePoint" \
          "NoRepair" 1
  SectionEnd
  
  # Uninstaller section
  Section "Uninstall"
      # Remove files
      RMDir /r "$INSTDIR"
      
      # Remove shortcuts
      RMDir /r "$SMPROGRAMS\CuePoint"
      ; Delete "$DESKTOP\CuePoint.lnk"
      
      # Remove registry entries
      DeleteRegKey HKCU "Software\CuePoint"
      DeleteRegKey HKCU "Software\Microsoft\Windows\CurrentVersion\Uninstall\CuePoint"
  SectionEnd
  ```
- **Installer Features**:
  - License page
  - Directory selection
  - Progress indication
  - Launch option
  - Uninstaller
  - Registry entries

**1.4.1.8 Installation Testing - Complete Test Suite**
- **Comprehensive Installation Tests**:
  ```python
  # SRC/tests/acceptance/test_installation.py
  import pytest
  import subprocess
  import shutil
  from pathlib import Path
  import platform
  
  @pytest.fixture
  def clean_install_dir():
      """Clean installation directory"""
      if platform.system() == "Windows":
          install_dir = Path.home() / "AppData" / "Local" / "CuePoint"
      else:
          install_dir = Path.home() / "Applications" / "CuePoint.app"
      
      if install_dir.exists():
          shutil.rmtree(install_dir)
      
      yield install_dir
      
      # Cleanup after test
      if install_dir.exists():
          shutil.rmtree(install_dir)
  
  def test_macos_dmg_mounts():
      """Test macOS DMG can be mounted"""
      dmg_path = Path("dist/CuePoint-v1.0.0-macos-universal.dmg")
      assert dmg_path.exists(), "DMG file not found"
      
      # Mount DMG
      result = subprocess.run(
          ["hdiutil", "attach", str(dmg_path)],
          capture_output=True,
          text=True
      )
      assert result.returncode == 0, f"Failed to mount DMG: {result.stderr}"
      
      # Verify contents
      # ... check for app bundle, Applications symlink
      
      # Unmount
      subprocess.run(["hdiutil", "detach", "/Volumes/CuePoint"])
  
  def test_macos_app_structure():
      """Test macOS app bundle structure"""
      app_path = Path("dist/CuePoint.app")
      assert app_path.exists(), "App bundle not found"
      
      # Check required structure
      assert (app_path / "Contents" / "MacOS" / "CuePoint").exists()
      assert (app_path / "Contents" / "Info.plist").exists()
      assert (app_path / "Contents" / "Resources").exists()
      
      # Check Info.plist
      import plistlib
      with open(app_path / "Contents" / "Info.plist", "rb") as f:
          plist = plistlib.load(f)
          assert plist["CFBundleIdentifier"] == "com.stuchain.cuepoint"
          assert "CFBundleShortVersionString" in plist
  
  def test_windows_installer_runs():
      """Test Windows installer can run"""
      installer_path = Path("dist/CuePoint-v1.0.0-windows-x64-setup.exe")
      assert installer_path.exists(), "Installer not found"
      
      # Test silent install
      result = subprocess.run(
          [str(installer_path), "/S", "/D=test_install"],
          capture_output=True,
          text=True
      )
      assert result.returncode == 0, f"Installer failed: {result.stderr}"
      
      # Verify installation
      install_dir = Path("test_install")
      assert (install_dir / "CuePoint.exe").exists()
      
      # Cleanup
      shutil.rmtree(install_dir)
  
  def test_app_launches_without_python():
      """Test app launches without Python installed"""
      # This test requires clean VM
      # Verify app executable runs
      # Verify no Python dependency errors
      pass
  
  def test_installation_success_rate():
      """Test installation success rate on various systems"""
      # Test on:
      # - Clean macOS 10.15+
      # - Clean macOS 11+
      # - Clean macOS 12+
      # - Clean Windows 10
      # - Clean Windows 11
      # Measure success rate
      pass
  ```

### Trust Outcome - Deep Dive

**1.4.2.5 macOS Code Signing - Complete Implementation**
- **Enhanced Signing Script**:
  ```bash
  #!/bin/bash
  set -e
  
  APP_PATH="${1:-dist/CuePoint.app}"
  CERT_NAME="${2:-Developer ID Application: StuChain (TEAM_ID)}"
  ENTITLEMENTS="${3:-build/entitlements.plist}"
  
  if [ ! -d "$APP_PATH" ]; then
      echo "Error: App bundle not found: $APP_PATH"
      exit 1
  fi
  
  echo "Signing app bundle: $APP_PATH"
  
  # Sign nested frameworks and libraries
  echo "Signing frameworks and libraries..."
  find "$APP_PATH" -type f \( -name "*.dylib" -o -name "*.so" \) -print0 | while IFS= read -r -d '' file; do
      echo "  Signing: $file"
      codesign --force --options runtime --timestamp \
          --sign "$CERT_NAME" "$file" || exit 1
  done
  
  # Sign Python frameworks if present
  if [ -d "$APP_PATH/Contents/Frameworks/Python.framework" ]; then
      echo "Signing Python framework..."
      codesign --force --options runtime --timestamp \
          --sign "$CERT_NAME" \
          "$APP_PATH/Contents/Frameworks/Python.framework/Versions/Current/Python" || exit 1
  fi
  
  # Sign Qt frameworks if present
  find "$APP_PATH/Contents/Frameworks" -name "Qt*.framework" -print0 | while IFS= read -r -d '' framework; do
      echo "Signing Qt framework: $framework"
      codesign --force --options runtime --timestamp \
          --sign "$CERT_NAME" "$framework" || exit 1
  done
  
  # Sign app bundle
  echo "Signing app bundle..."
  codesign --force --deep --options runtime --timestamp \
      --sign "$CERT_NAME" \
      --entitlements "$ENTITLEMENTS" \
      "$APP_PATH" || exit 1
  
  # Verify signing
  echo "Verifying signature..."
  codesign --verify --deep --strict --verbose=2 "$APP_PATH" || exit 1
  
  # Verify Gatekeeper
  echo "Verifying Gatekeeper..."
  spctl -a -vv --type execute "$APP_PATH" || exit 1
  
  echo "Signing complete and verified!"
  ```
- **Entitlements File**:
  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
      <key>com.apple.security.cs.allow-jit</key>
      <false/>
      <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
      <false/>
      <key>com.apple.security.cs.allow-dyld-environment-variables</key>
      <false/>
      <key>com.apple.security.cs.disable-library-validation</key>
      <false/>
      <key>com.apple.security.network.client</key>
      <true/>
      <key>com.apple.security.network.server</key>
      <false/>
      <key>com.apple.security.files.user-selected.read-write</key>
      <true/>
      <key>com.apple.security.files.downloads.read-write</key>
      <true/>
  </dict>
  </plist>
  ```

**1.4.2.6 macOS Notarization - Complete Workflow**
- **Enhanced Notarization Script**:
  ```bash
  #!/bin/bash
  set -e
  
  DMG_PATH="${1:-dist/CuePoint-v1.0.0-macos-universal.dmg}"
  PROFILE="${2:-notarytool-profile}"
  
  if [ ! -f "$DMG_PATH" ]; then
      echo "Error: DMG not found: $DMG_PATH"
      exit 1
  fi
  
  echo "Submitting DMG for notarization: $DMG_PATH"
  
  # Submit for notarization
  xcrun notarytool submit "$DMG_PATH" \
      --keychain-profile "$PROFILE" \
      --wait \
      --timeout 30m || exit 1
  
  echo "Notarization successful!"
  
  # Staple ticket
  echo "Stapling notarization ticket..."
  xcrun stapler staple "$DMG_PATH" || exit 1
  
  # Verify
  echo "Verifying notarization..."
  spctl -a -vv -t install "$DMG_PATH" || exit 1
  
  echo "Notarization complete and verified!"
  ```
- **Notarization Setup**:
  ```bash
  # Configure notarytool profile
  xcrun notarytool store-credentials notarytool-profile \
      --apple-id "your@email.com" \
      --team-id "TEAM_ID" \
      --key-id "KEY_ID" \
      --key "path/to/AuthKey_KEY_ID.p8" \
      --password "app-specific-password"
  ```

**1.4.2.7 Windows Code Signing - Complete Implementation**
- **Enhanced PowerShell Script**:
  ```powershell
  # Sign Windows executable and installer
  param(
      [string]$ExePath = "dist\CuePoint.exe",
      [string]$InstallerPath = "dist\CuePoint-v1.0.0-windows-x64-setup.exe",
      [string]$CertPath = $env:WINDOWS_CERT_PFX,
      [string]$CertPassword = $env:WINDOWS_CERT_PASSWORD
  )
  
  if (-not $CertPath -or -not $CertPassword) {
      Write-Error "Certificate path and password must be provided"
      exit 1
  }
  
  # Sign executable
  if (Test-Path $ExePath) {
      Write-Host "Signing executable: $ExePath"
      & signtool sign /f $CertPath /p $CertPassword `
          /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 `
          $ExePath
      
      if ($LASTEXITCODE -ne 0) {
          Write-Error "Failed to sign executable"
          exit 1
      }
      
      # Verify
      Write-Host "Verifying signature..."
      & signtool verify /pa /v $ExePath
      
      if ($LASTEXITCODE -ne 0) {
          Write-Error "Signature verification failed"
          exit 1
      }
      
      Write-Host "Executable signed successfully"
  }
  
  # Sign installer
  if (Test-Path $InstallerPath) {
      Write-Host "Signing installer: $InstallerPath"
      & signtool sign /f $CertPath /p $CertPassword `
          /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 `
          $InstallerPath
      
      if ($LASTEXITCODE -ne 0) {
          Write-Error "Failed to sign installer"
          exit 1
      }
      
      # Verify
      Write-Host "Verifying signature..."
      & signtool verify /pa /v $InstallerPath
      
      if ($LASTEXITCODE -ne 0) {
          Write-Error "Signature verification failed"
          exit 1
      }
      
      Write-Host "Installer signed successfully"
  }
  ```

### Reliability Outcome - Deep Dive

**1.4.3.5 Standard Storage Paths - Complete Implementation**
- **Enhanced Paths Module**:
  ```python
  # SRC/cuepoint/utils/paths.py
  from pathlib import Path
  from PySide6.QtCore import QStandardPaths
  import os
  
  class AppPaths:
      """Standard application paths using QStandardPaths"""
      
      @staticmethod
      def ensure_dir(path: Path) -> Path:
          """Ensure directory exists, create if needed"""
          path.mkdir(parents=True, exist_ok=True)
          return path
      
      @staticmethod
      def config_dir() -> Path:
          """Configuration directory"""
          path = Path(QStandardPaths.writableLocation(
              QStandardPaths.AppConfigLocation
          )) / "CuePoint"
          return AppPaths.ensure_dir(path)
      
      @staticmethod
      def config_file() -> Path:
          """Main configuration file"""
          return AppPaths.config_dir() / "config.yaml"
      
      @staticmethod
      def data_dir() -> Path:
          """Application data directory"""
          path = Path(QStandardPaths.writableLocation(
              QStandardPaths.AppLocalDataLocation
          )) / "CuePoint"
          return AppPaths.ensure_dir(path)
      
      @staticmethod
      def cache_dir() -> Path:
          """Cache directory"""
          path = Path(QStandardPaths.writableLocation(
              QStandardPaths.CacheLocation
          )) / "CuePoint"
          return AppPaths.ensure_dir(path)
      
      @staticmethod
      def logs_dir() -> Path:
          """Logs directory"""
          path = AppPaths.data_dir() / "Logs"
          return AppPaths.ensure_dir(path)
      
      @staticmethod
      def exports_dir() -> Path:
          """Default exports directory"""
          # Use Downloads on first run, allow user to change
          downloads = Path(QStandardPaths.writableLocation(
              QStandardPaths.DownloadLocation
          ))
          exports = downloads / "CuePoint Exports"
          return AppPaths.ensure_dir(exports)
      
      @staticmethod
      def temp_dir() -> Path:
          """Temporary files directory"""
          path = AppPaths.cache_dir() / "temp"
          return AppPaths.ensure_dir(path)
      
      @staticmethod
      def app_dir() -> Path:
          """Application installation directory"""
          if getattr(sys, 'frozen', False):
              # Running as bundled app
              return Path(sys.executable).parent
          else:
              # Running from source
              return Path(__file__).parent.parent.parent
      
      @staticmethod
      def get_all_paths() -> dict:
          """Get all paths for diagnostics"""
          return {
              "config": str(AppPaths.config_dir()),
              "data": str(AppPaths.data_dir()),
              "cache": str(AppPaths.cache_dir()),
              "logs": str(AppPaths.logs_dir()),
              "exports": str(AppPaths.exports_dir()),
              "app": str(AppPaths.app_dir()),
          }
  ```

**1.4.3.6 Error Handling Framework - Complete Implementation**
- **Enhanced Error Handler**:
  ```python
  # SRC/cuepoint/utils/error_handler.py
  import logging
  from typing import Optional, Dict, Any
  from pathlib import Path
  from cuepoint.utils.paths import AppPaths
  
  logger = logging.getLogger(__name__)
  
  class ErrorHandler:
      """Centralized error handling with user-friendly messages"""
      
      ERROR_MESSAGES = {
          FileNotFoundError: {
              "title": "File Not Found",
              "message": "The file could not be found.",
              "suggestions": [
                  "Check that the file path is correct",
                  "Verify the file hasn't been moved or deleted",
                  "Try selecting the file again"
              ]
          },
          PermissionError: {
              "title": "Permission Denied",
              "message": "You don't have permission to access this file or location.",
              "suggestions": [
                  "Check file permissions",
                  "Try running as administrator (Windows) or with sudo (macOS)",
                  "Select a different location"
              ]
          },
          # ... more error types
      }
      
      @staticmethod
      def handle_error(error: Exception, context: str = "", 
                      user_context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
          """Handle error and return user-friendly information"""
          # Log error
          logger.error(f"{context}: {error}", exc_info=True)
          
          # Get error type
          error_type = type(error)
          
          # Get user-friendly message
          if error_type in ErrorHandler.ERROR_MESSAGES:
              error_info = ErrorHandler.ERROR_MESSAGES[error_type]
              message = error_info["message"]
              suggestions = error_info["suggestions"]
          else:
              message = f"An unexpected error occurred: {str(error)}"
              suggestions = [
                  "Check the logs for more details",
                  "Try the operation again",
                  "Contact support if the problem persists"
              ]
          
          # Add context-specific information
          if user_context:
              if "file_path" in user_context:
                  message += f"\n\nFile: {user_context['file_path']}"
          
          return {
              "title": error_info.get("title", "Error"),
              "message": message,
              "suggestions": suggestions,
              "technical_details": str(error),
              "log_location": str(AppPaths.logs_dir())
          }
      
      @staticmethod
      def show_error_dialog(parent, error: Exception, context: str = ""):
          """Show error dialog to user"""
          from PySide6.QtWidgets import QMessageBox
            
          error_info = ErrorHandler.handle_error(error, context)
          
          msg = QMessageBox(parent)
          msg.setIcon(QMessageBox.Critical)
          msg.setWindowTitle(error_info["title"])
          msg.setText(error_info["message"])
          
          # Add detailed text
          detailed_text = "\n".join(error_info["suggestions"])
          detailed_text += f"\n\nTechnical details:\n{error_info['technical_details']}"
          detailed_text += f"\n\nLogs: {error_info['log_location']}"
          msg.setDetailedText(detailed_text)
          
          msg.exec()
  ```

**1.4.3.7 Safe File Operations - Complete Implementation**
- **Atomic File Writing**:
  ```python
  # SRC/cuepoint/utils/file_ops.py
  import os
  import shutil
  from pathlib import Path
  from typing import Union, Callable
  
  def atomic_write(file_path: Path, content: Union[str, bytes], 
                  mode: str = 'w', encoding: str = 'utf-8'):
      """Atomically write file to prevent corruption"""
      file_path = Path(file_path)
      temp_path = file_path.with_suffix(f'{file_path.suffix}.tmp')
      
      try:
          # Write to temp file
          if mode == 'wb' or isinstance(content, bytes):
              with open(temp_path, 'wb') as f:
                  f.write(content)
                  f.flush()
                  os.fsync(f.fileno())
          else:
              with open(temp_path, mode, encoding=encoding) as f:
                  f.write(content)
                  f.flush()
                  os.fsync(f.fileno())
          
          # Atomic rename
          temp_path.replace(file_path)
          
          # Verify
          if not file_path.exists():
              raise IOError("File was not created after atomic write")
          
          if file_path.stat().st_size == 0:
              raise IOError("File is empty after write")
          
      except Exception as e:
          # Clean up temp file
          if temp_path.exists():
              temp_path.unlink()
          raise
  
  def safe_backup(file_path: Path, backup_suffix: str = '.bak'):
      """Create safe backup of file"""
      backup_path = file_path.with_suffix(f'{file_path.suffix}{backup_suffix}')
      
      if file_path.exists():
          # Copy to backup
          shutil.copy2(file_path, backup_path)
          return backup_path
      
      return None
  ```

## Testing and Validation

### Installation Testing Scenarios
- **Scenario 1**: Clean macOS installation
- **Scenario 2**: Clean Windows installation
- **Scenario 3**: Upgrade from previous version
- **Scenario 4**: Installation with insufficient disk space
- **Scenario 5**: Installation with no admin rights (Windows)

### Trust Testing Scenarios
- **Scenario 1**: Fresh macOS - Gatekeeper acceptance
- **Scenario 2**: Fresh Windows - SmartScreen behavior
- **Scenario 3**: Signed artifact verification
- **Scenario 4**: Notarization status check

### Reliability Testing Scenarios
- **Scenario 1**: Export with disk full
- **Scenario 2**: Export with file locked
- **Scenario 3**: Network interruption during processing
- **Scenario 4**: App crash recovery

## Performance Benchmarks

### Installation Performance
- **DMG Mount Time**: < 2 seconds
- **App Copy Time**: < 10 seconds
- **Installer Run Time**: < 30 seconds
- **Total Installation**: < 2 minutes

### Trust Verification
- **Code Signing Time**: < 30 seconds
- **Notarization Time**: < 10 minutes (Apple processing)
- **Gatekeeper Check**: < 1 second

## Edge Cases and Error Handling

### Installation Edge Cases
- **Case 1**: App already installed
  - **Handling**: Allow reinstall, preserve user data
- **Case 2**: Insufficient disk space
  - **Handling**: Check before install, show clear error
- **Case 3**: Corrupted installer
  - **Handling**: Verify checksum, show error

### Trust Edge Cases
- **Case 1**: Certificate expired
  - **Handling**: Fail build, require new certificate
- **Case 2**: Notarization timeout
  - **Handling**: Retry, show warning
- **Case 3**: Signature verification failure
  - **Handling**: Fail build, investigate

## References

- Main document: `../01_Product_Requirements_and_Definition.md`
- Related: Step 2 (Build System), Step 3-4 (Packaging), Step 5 (Updates), Step 6 (Runtime)
- PyInstaller: https://pyinstaller.org/
- NSIS: https://nsis.sourceforge.io/
- Code Signing: Apple Developer Documentation

