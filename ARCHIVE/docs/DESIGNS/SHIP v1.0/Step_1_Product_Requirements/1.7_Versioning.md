# Implementation Step 1.7: Versioning System

## Implementation Overview
**What We're Building**: Version management system using SemVer, with version embedding in app metadata and build identifiers for traceability.

## Implementation Tasks

### Task 1.7.1: Create Version Management System

**What to Build**
- Single source of truth for version
- Version embedding in app metadata
- Build identifier system
- Version display in UI

**Implementation Details**

**1.7.1.1 Version Definition File**
- **File to Create**: `SRC/cuepoint/version.py`
- **Implementation**:
  ```python
  """Version information for CuePoint"""
  
  # Version follows Semantic Versioning (SemVer): MAJOR.MINOR.PATCH
  __version__ = "1.0.0"
  
  # Build identifier (set by CI or build script)
  __build_number__ = None  # Will be set during build
  __commit_sha__ = None     # Will be set during build
  
  def get_version_string() -> str:
      """Get full version string"""
      version = __version__
      if __build_number__:
          version += f".{__build_number__}"
      return version
  
  def get_build_info() -> dict:
      """Get build information for diagnostics"""
      return {
          "version": __version__,
          "build_number": __build_number__,
          "commit_sha": __commit_sha__,
      }
  ```
- **Purpose**: Single source of truth for version
- **Usage**: Imported throughout app for version display

**1.7.1.2 Version Embedding in App Metadata**
- **File to Modify**: `build/pyinstaller.spec` (Step 2)
- **Implementation**:
  ```python
  # In pyinstaller.spec
  exe = EXE(
      # ... other options
      version='version_info.txt',  # Windows version info
  )
  
  # Create version_info.txt for Windows
  # File: build/version_info.txt
  VSVersionInfo(
    ffi=FixedFileInfo(
      filevers=(1, 0, 0, 0),
      prodvers=(1, 0, 0, 0),
      # ...
    ),
    kids=[
      StringFileInfo([
        StringTable('040904B0', [
          StringStruct('FileDescription', 'CuePoint'),
          StringStruct('FileVersion', '1.0.0'),
          StringStruct('ProductVersion', '1.0.0'),
          # ...
        ])
      ]),
      VarFileInfo([VarStruct('Translation', [1033, 1200])])
    ]
  )
  ```
- **Purpose**: Embed version in Windows executable metadata
- **Dependencies**: PyInstaller, version file

**1.7.1.3 macOS Info.plist Version**
- **File to Create**: `build/Info.plist.template`
- **Implementation**:
  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
    <key>CFBundleShortVersionString</key>
    <string>{{VERSION}}</string>
    <key>CFBundleVersion</key>
    <string>{{BUILD_NUMBER}}</string>
    <key>CFBundleIdentifier</key>
    <string>com.stuchain.cuepoint</string>
    <!-- ... other keys -->
  </dict>
  </plist>
  ```
- **Purpose**: Embed version in macOS app bundle
- **Processing**: Template processed during build (Step 2)

**1.7.1.4 Version Display in UI**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  from cuepoint.version import get_version_string, get_build_info
  
  def show_about_dialog(self):
      """Show About dialog with version info"""
      version = get_version_string()
      build_info = get_build_info()
      
      about_text = f"""
      <h2>CuePoint</h2>
      <p>Version: {version}</p>
      """
      if build_info.get("build_number"):
          about_text += f"<p>Build: {build_info['build_number']}</p>"
      if build_info.get("commit_sha"):
          about_text += f"<p>Commit: {build_info['commit_sha'][:8]}</p>"
      
      QMessageBox.about(self, "About CuePoint", about_text)
  ```
- **Purpose**: Display version in About dialog
- **Integration**: Add to Help menu

**1.7.1.5 Build Identifier System**
- **File to Create**: `scripts/set_build_info.py`
- **Implementation**:
  ```python
  """Set build information during CI build"""
  import os
  import subprocess
  from pathlib import Path
    
  def get_commit_sha():
      """Get current git commit SHA"""
      try:
          result = subprocess.run(
              ["git", "rev-parse", "HEAD"],
              capture_output=True,
              text=True,
              check=True
          )
          return result.stdout.strip()
      except Exception:
          return None
    
  def get_build_number():
      """Get build number from CI or generate"""
      # Try CI environment variable
      build_num = os.environ.get("GITHUB_RUN_NUMBER")
      if build_num:
          return build_num
      
      # Fallback: date-based
      from datetime import datetime
      return datetime.now().strftime("%Y%m%d%H%M")
    
  def update_version_file():
      """Update version.py with build info"""
      version_file = Path("SRC/cuepoint/version.py")
      content = version_file.read_text()
      
      # Replace placeholders
      content = content.replace(
          "__build_number__ = None",
          f"__build_number__ = \"{get_build_number()}\""
      )
      content = content.replace(
          "__commit_sha__ = None",
          f"__commit_sha__ = \"{get_commit_sha()}\""
      )
      
      version_file.write_text(content)
  ```
- **Purpose**: Set build identifiers during CI build
- **Integration**: Called in CI/CD pipeline (Step 2)

### Task 1.7.2: Implement Version Tagging Policy

**What to Build**
- Git tagging workflow
- Version validation
- Tag-based release triggers

**Implementation Details**

**1.7.2.1 Git Tagging Workflow**
- **File to Create**: `scripts/create_release_tag.sh`
- **Implementation**:
  ```bash
  #!/bin/bash
  # Create release tag
  VERSION=$1
  
  # Validate version format (SemVer)
  if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      echo "Error: Version must be SemVer format (X.Y.Z)"
      exit 1
  fi
  
  # Check if tag exists
  if git rev-parse "v${VERSION}" >/dev/null 2>&1; then
      echo "Error: Tag v${VERSION} already exists"
      exit 1
  fi
  
  # Update version file
  python scripts/set_build_info.py
  
  # Create tag
  git tag -a "v${VERSION}" -m "Release v${VERSION}"
  
  echo "Created tag v${VERSION}"
  echo "Push with: git push origin v${VERSION}"
  ```
- **Purpose**: Standardized release tagging
- **Usage**: Run before creating release

**1.7.2.2 Version Validation**
- **File to Create**: `scripts/validate_version.py`
- **Implementation**:
  ```python
  """Validate version format and consistency"""
  import re
  from pathlib import Path
    
  def validate_semver(version: str) -> bool:
      """Validate SemVer format"""
      pattern = r'^\d+\.\d+\.\d+$'
      return bool(re.match(pattern, version))
    
  def check_version_consistency():
      """Check version is consistent across files"""
      # Read version from version.py
      # Check against git tag
      # Check against package.json/pyproject.toml if exists
      # Return True if consistent
  ```
- **Purpose**: Ensure version consistency
- **Integration**: CI validation step (Step 2)

### Task 1.7.3: Implement Version in Diagnostics

**What to Build**
- Version display in diagnostics
- Build info in support bundles
- Version in logs

**Implementation Details**

**1.7.3.1 Version in Diagnostics**
- **File to Modify**: `SRC/cuepoint/utils/diagnostics.py` (Step 6)
- **Implementation**:
  ```python
  from cuepoint.version import get_build_info
    
  def collect_diagnostics() -> dict:
      """Collect diagnostic information"""
      build_info = get_build_info()
      return {
          "app_version": build_info["version"],
          "build_number": build_info.get("build_number"),
          "commit_sha": build_info.get("commit_sha"),
          # ... other diagnostics
      }
  ```
- **Purpose**: Include version in diagnostic exports
- **Integration**: Used in support bundle generation

**1.7.3.2 Version in Logs**
- **File to Modify**: `SRC/cuepoint/utils/logger.py` (Step 6)
- **Implementation**:
  ```python
  from cuepoint.version import get_version_string
    
  def setup_logging():
      """Setup logging with version info"""
      logging.basicConfig(
          format='%(asctime)s [%(levelname)s] [v{}] %(message)s'.format(
              get_version_string()
          ),
          # ...
      )
  ```
- **Purpose**: Include version in log entries
- **Integration**: Logging setup (Step 6)

## Implementation Checklist

### Version Management
- [ ] Create version.py file
- [ ] Implement version embedding (macOS Info.plist)
- [ ] Implement version embedding (Windows version info)
- [ ] Add version to About dialog
- [ ] Create build info script

### Tagging and Validation
- [ ] Create release tagging script
- [ ] Create version validation script
- [ ] Add CI validation step

### Diagnostics Integration
- [ ] Add version to diagnostics
- [ ] Add version to logs
- [ ] Add version to support bundles

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/version.py` - Version definition
2. `build/Info.plist.template` - macOS version template
3. `build/version_info.txt` - Windows version info
4. `scripts/set_build_info.py` - Build info script
5. `scripts/create_release_tag.sh` - Tagging script
6. `scripts/validate_version.py` - Version validation

### Files to Modify
1. `build/pyinstaller.spec` - Add version info (Step 2)
2. `SRC/cuepoint/ui/main_window.py` - Add About dialog
3. `SRC/cuepoint/utils/diagnostics.py` - Add version (Step 6)
4. `SRC/cuepoint/utils/logger.py` - Add version to logs (Step 6)

## Implementation Dependencies

### Prerequisites
- Step 1.1: Product statement (defines versioning needs)

### Enables
- Step 2: Build system (uses version in builds)
- Step 5: Update system (uses version for updates)
- Step 6: Diagnostics (includes version info)

## Success Criteria

### Version Management
- ✅ Single source of truth for version
- ✅ Version embedded in all app metadata
- ✅ Build identifiers set during CI
- ✅ Version displayed in UI

### Validation
- ✅ Version format validated (SemVer)
- ✅ Version consistency checked
- ✅ Tagging workflow functional

## Next Implementation Steps

After completing Step 1.7:
1. **Step 2**: Build system (uses version in builds)
2. **Step 5**: Update system (uses version for update checks)
3. **Step 6**: Diagnostics (includes version in exports)

## Detailed Versioning Implementation

### Version Management System - Complete Implementation

**1.7.1.6 Enhanced Version Module**
- **Complete Version Module**:
  ```python
  # SRC/cuepoint/version.py
  """Version information for CuePoint
  
  This module serves as the single source of truth for version information.
  Version follows Semantic Versioning (SemVer): MAJOR.MINOR.PATCH
  """
  import sys
  from typing import Optional, Dict, Any
  from datetime import datetime
  
  # Version follows Semantic Versioning (SemVer): MAJOR.MINOR.PATCH
  __version__ = "1.0.0"
  
  # Build identifier (set by CI or build script)
  __build_number__: Optional[str] = None  # Will be set during build
  __commit_sha__: Optional[str] = None     # Will be set during build
  __build_date__: Optional[str] = None     # Will be set during build
  
  def get_version() -> str:
      """Get version string (MAJOR.MINOR.PATCH)"""
      return __version__
  
  def get_version_string() -> str:
      """Get full version string with build number if available"""
      version = __version__
      if __build_number__:
          version += f".{__build_number__}"
      return version
  
  def get_build_number() -> Optional[str]:
      """Get build number"""
      return __build_number__
  
  def get_commit_sha() -> Optional[str]:
      """Get commit SHA"""
      return __commit_sha__
  
  def get_short_commit_sha() -> Optional[str]:
      """Get short commit SHA (8 characters)"""
      if __commit_sha__:
          return __commit_sha__[:8]
      return None
  
  def get_build_date() -> Optional[str]:
      """Get build date"""
      return __build_date__
  
  def get_build_info() -> Dict[str, Any]:
      """Get complete build information for diagnostics"""
      return {
          "version": __version__,
          "version_string": get_version_string(),
          "build_number": __build_number__,
          "commit_sha": __commit_sha__,
          "short_commit_sha": get_short_commit_sha(),
          "build_date": __build_date__,
          "python_version": sys.version,
          "python_executable": sys.executable,
      }
  
  def is_dev_build() -> bool:
      """Check if this is a development build"""
      return __build_number__ is None or __commit_sha__ is None
  
  def get_version_display_string() -> str:
      """Get formatted version string for display"""
      version_str = f"Version {__version__}"
      if __build_number__:
          version_str += f" (Build {__build_number__})"
      if __commit_sha__:
          version_str += f" - {get_short_commit_sha()}"
      return version_str
  ```

**1.7.1.7 Complete Build Info Script**
- **Enhanced Build Info Script**:
  ```python
  # scripts/set_build_info.py
  """Set build information during CI build"""
  import os
  import subprocess
  import sys
  from pathlib import Path
  from datetime import datetime
  
  def get_commit_sha() -> Optional[str]:
      """Get current git commit SHA"""
      try:
          result = subprocess.run(
              ["git", "rev-parse", "HEAD"],
              capture_output=True,
              text=True,
              check=True,
              timeout=10
          )
          return result.stdout.strip()
      except subprocess.TimeoutExpired:
          print("Warning: Git command timed out")
          return None
      except subprocess.CalledProcessError as e:
          print(f"Warning: Could not get commit SHA: {e}")
          return None
      except FileNotFoundError:
          print("Warning: Git not found")
          return None
  
  def get_build_number() -> Optional[str]:
      """Get build number from CI or generate"""
      # Try CI environment variables (GitHub Actions)
      build_num = os.environ.get("GITHUB_RUN_NUMBER")
      if build_num:
          return build_num
      
      # Try other CI systems
      build_num = os.environ.get("BUILD_NUMBER")
      if build_num:
          return build_num
      
      # Try CI build ID
      build_id = os.environ.get("GITHUB_RUN_ID")
      if build_id:
          return build_id
      
      # Fallback: date-based build number
      return datetime.now().strftime("%Y%m%d%H%M")
  
  def get_build_date() -> str:
      """Get build date in ISO format"""
      return datetime.now().isoformat()
  
  def update_version_file():
      """Update version.py with build info"""
      version_file = Path("SRC/cuepoint/version.py")
      
      if not version_file.exists():
          print(f"Error: Version file not found: {version_file}")
          sys.exit(1)
      
      # Read current content
      content = version_file.read_text()
      
      # Get build info
      build_number = get_build_number()
      commit_sha = get_commit_sha()
      build_date = get_build_date()
      
      # Replace placeholders
      replacements = [
          ("__build_number__: Optional[str] = None", 
           f"__build_number__: Optional[str] = \"{build_number}\""),
          ("__commit_sha__: Optional[str] = None", 
           f"__commit_sha__: Optional[str] = \"{commit_sha}\""),
          ("__build_date__: Optional[str] = None", 
           f"__build_date__: Optional[str] = \"{build_date}\""),
      ]
      
      for old, new in replacements:
          if old in content:
              content = content.replace(old, new)
          else:
              print(f"Warning: Could not find '{old}' in version file")
      
      # Write updated content
      version_file.write_text(content)
      
      print(f"Updated version file:")
      print(f"  Build number: {build_number}")
      print(f"  Commit SHA: {commit_sha}")
      print(f"  Build date: {build_date}")
  
  if __name__ == "__main__":
      update_version_file()
  ```

**1.7.1.8 Complete Version Embedding - Windows**
- **Windows Version Info File**:
  ```python
  # build/version_info.txt
  # This file is used by PyInstaller to embed version info in Windows executable
  VSVersionInfo(
    ffi=FixedFileInfo(
      filevers=(1, 0, 0, 0),
      prodvers=(1, 0, 0, 0),
      mask=0x3f,
      flags=0x0,
      OS=0x40004,
      fileType=0x1,
      subtype=0x0,
      date=(0, 0)
    ),
    kids=[
      StringFileInfo([
        StringTable('040904B0', [
          StringStruct('CompanyName', 'StuChain'),
          StringStruct('FileDescription', 'CuePoint - Rekordbox Metadata Enrichment Tool'),
          StringStruct('FileVersion', '1.0.0.0'),
          StringStruct('InternalName', 'CuePoint'),
          StringStruct('LegalCopyright', 'Copyright © 2024 StuChain. All rights reserved.'),
          StringStruct('OriginalFilename', 'CuePoint.exe'),
          StringStruct('ProductName', 'CuePoint'),
          StringStruct('ProductVersion', '1.0.0.0'),
        ])
      ]),
      VarFileInfo([VarStruct('Translation', [1033, 1200])])
    ]
  )
  ```

**1.7.1.9 Complete Version Embedding - macOS**
- **Info.plist Template Processing**:
  ```python
  # scripts/process_info_plist.py
  """Process Info.plist template with version info"""
  from pathlib import Path
  from cuepoint.version import get_version, get_build_number
  
  def process_info_plist_template():
      """Process Info.plist template"""
      template_path = Path("build/Info.plist.template")
      output_path = Path("build/Info.plist")
      
      if not template_path.exists():
          raise FileNotFoundError(f"Template not found: {template_path}")
      
      # Read template
      content = template_path.read_text()
      
      # Replace placeholders
      version = get_version()
      build_number = get_build_number() or "1"
      
      content = content.replace("{{VERSION}}", version)
      content = content.replace("{{BUILD_NUMBER}}", build_number)
      
      # Write processed file
      output_path.write_text(content)
      print(f"Processed Info.plist: version={version}, build={build_number}")
  ```

### Version Tagging - Complete Implementation

**1.7.2.3 Complete Release Tagging Script**
- **Enhanced Tagging Script**:
  ```bash
  #!/bin/bash
  # scripts/create_release_tag.sh
  set -e
  
  VERSION="${1}"
  
  if [ -z "$VERSION" ]; then
      echo "Usage: $0 <version>"
      echo "Example: $0 1.0.0"
      exit 1
  fi
  
  # Validate version format (SemVer)
  if [[ ! $VERSION =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
      echo "Error: Version must be SemVer format (X.Y.Z)"
      echo "Example: 1.0.0"
      exit 1
  fi
  
  # Check if working directory is clean
  if [ -n "$(git status --porcelain)" ]; then
      echo "Error: Working directory is not clean"
      echo "Please commit or stash changes before creating a release tag"
      exit 1
  fi
  
  # Check if tag exists
  if git rev-parse "v${VERSION}" >/dev/null 2>&1; then
      echo "Error: Tag v${VERSION} already exists"
      exit 1
  fi
  
  # Verify version in version.py matches
  VERSION_IN_FILE=$(python -c "from SRC.cuepoint.version import get_version; print(get_version())")
  if [ "$VERSION_IN_FILE" != "$VERSION" ]; then
      echo "Error: Version in version.py ($VERSION_IN_FILE) does not match tag version ($VERSION)"
      echo "Please update version.py first"
      exit 1
  fi
  
  # Update build info
      echo "Setting build info..."
      python scripts/set_build_info.py
  
  # Create annotated tag
      echo "Creating tag v${VERSION}..."
      git tag -a "v${VERSION}" -m "Release v${VERSION}"
  
  echo ""
  echo "✓ Created tag v${VERSION}"
  echo ""
  echo "Next steps:"
  echo "  1. Review the tag: git show v${VERSION}"
  echo "  2. Push the tag: git push origin v${VERSION}"
  echo "  3. This will trigger the release workflow"
  ```

**1.7.2.4 Complete Version Validation**
- **Enhanced Version Validator**:
  ```python
  # scripts/validate_version.py
  """Validate version format and consistency"""
  import re
  import subprocess
  from pathlib import Path
  from typing import Tuple, List
  
  def validate_semver(version: str) -> Tuple[bool, Optional[str]]:
      """Validate SemVer format"""
      pattern = r'^\d+\.\d+\.\d+$'
      if not re.match(pattern, version):
          return False, f"Version must be SemVer format (X.Y.Z), got: {version}"
      
      # Check version components are reasonable
      parts = version.split('.')
      major, minor, patch = map(int, parts)
      
      if major > 100:
          return False, f"Major version seems too high: {major}"
      if minor > 100:
          return False, f"Minor version seems too high: {minor}"
      if patch > 1000:
          return False, f"Patch version seems too high: {patch}"
      
      return True, None
  
  def get_version_from_file() -> Optional[str]:
      """Get version from version.py"""
      version_file = Path("SRC/cuepoint/version.py")
      if not version_file.exists():
          return None
      
      content = version_file.read_text()
      match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
      if match:
          return match.group(1)
      return None
  
  def get_version_from_git_tag() -> Optional[str]:
      """Get latest version from git tags"""
      try:
          result = subprocess.run(
              ["git", "tag", "--list", "v*", "--sort=-version:refname"],
              capture_output=True,
              text=True,
              check=True
          )
          tags = result.stdout.strip().split('\n')
          if tags and tags[0]:
              # Remove 'v' prefix
              return tags[0][1:]
          return None
      except Exception:
          return None
  
  def check_version_consistency() -> Tuple[bool, List[str]]:
      """Check version is consistent across files"""
      errors = []
      
      # Get version from version.py
      file_version = get_version_from_file()
      if not file_version:
          errors.append("Could not read version from version.py")
          return False, errors
      
      # Validate format
      valid, error_msg = validate_semver(file_version)
      if not valid:
          errors.append(f"Invalid version format: {error_msg}")
          return False, errors
      
      # Check against git tag (if exists)
      git_version = get_version_from_git_tag()
      if git_version and git_version != file_version:
          errors.append(
              f"Version mismatch: version.py has {file_version}, "
              f"latest git tag is v{git_version}"
          )
      
      # Check pyproject.toml if exists
      pyproject = Path("pyproject.toml")
      if pyproject.exists():
          content = pyproject.read_text()
          match = re.search(r'version\s*=\s*["\']([^"\']+)["\']', content)
          if match:
              toml_version = match.group(1)
              if toml_version != file_version:
                  errors.append(
                      f"Version mismatch: version.py has {file_version}, "
                      f"pyproject.toml has {toml_version}"
                  )
      
      return len(errors) == 0, errors
  
  if __name__ == "__main__":
      import sys
      valid, errors = check_version_consistency()
      if not valid:
          print("Version validation failed:")
          for error in errors:
              print(f"  ERROR: {error}")
          sys.exit(1)
      else:
          version = get_version_from_file()
          print(f"✓ Version validation passed: {version}")
  ```

### Version in Diagnostics - Complete Implementation

**1.7.3.3 Enhanced About Dialog**
- **Complete About Dialog Implementation**:
  ```python
  # SRC/cuepoint/ui/dialogs/about_dialog.py
  """About dialog with version information"""
  from PySide6.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton, QTextEdit
  from PySide6.QtCore import Qt
  from cuepoint.version import (
      get_version_string, get_build_info, get_version_display_string,
      is_dev_build
  )
  from cuepoint.utils.platform import get_platform_string
  
  class AboutDialog(QDialog):
      """About dialog showing version and system information"""
      
      def __init__(self, parent=None):
          super().__init__(parent)
          self.setWindowTitle("About CuePoint")
          self.setMinimumWidth(400)
          self.init_ui()
      
      def init_ui(self):
          """Initialize UI"""
          layout = QVBoxLayout()
          
          # App name and version
          title_label = QLabel("CuePoint")
          title_label.setStyleSheet("font-size: 24px; font-weight: bold;")
          title_label.setAlignment(Qt.AlignCenter)
          layout.addWidget(title_label)
          
          # Version info
          version_label = QLabel(get_version_display_string())
          version_label.setAlignment(Qt.AlignCenter)
          layout.addWidget(version_label)
          
          # Build info (if available)
          build_info = get_build_info()
          if build_info.get("build_date"):
              build_date_label = QLabel(f"Built: {build_info['build_date']}")
              build_date_label.setAlignment(Qt.AlignCenter)
              build_date_label.setStyleSheet("color: gray; font-size: 11px;")
              layout.addWidget(build_date_label)
          
          # Dev build indicator
          if is_dev_build():
              dev_label = QLabel("Development Build")
              dev_label.setAlignment(Qt.AlignCenter)
              dev_label.setStyleSheet("color: orange; font-weight: bold;")
              layout.addWidget(dev_label)
          
          # System info
          system_label = QLabel(f"Platform: {get_platform_string()}")
          system_label.setAlignment(Qt.AlignCenter)
          system_label.setStyleSheet("color: gray; font-size: 11px;")
          layout.addWidget(system_label)
          
          # Copyright
          copyright_label = QLabel("Copyright © 2024 StuChain. All rights reserved.")
          copyright_label.setAlignment(Qt.AlignCenter)
          copyright_label.setStyleSheet("color: gray; font-size: 10px;")
          layout.addWidget(copyright_label)
          
          # Detailed info button (for diagnostics)
          details_button = QPushButton("Show Details")
          details_button.clicked.connect(self.show_details)
          layout.addWidget(details_button)
          
          # Close button
          close_button = QPushButton("Close")
          close_button.clicked.connect(self.accept)
          layout.addWidget(close_button)
          
          self.setLayout(layout)
      
      def show_details(self):
          """Show detailed version and system information"""
          from cuepoint.utils.diagnostics import DiagnosticCollector
          
          dialog = QDialog(self)
          dialog.setWindowTitle("Version & System Information")
          dialog.setMinimumSize(600, 400)
          
          layout = QVBoxLayout()
          
          # Text area with details
          text_area = QTextEdit()
          text_area.setReadOnly(True)
          text_area.setFontFamily("monospace")
          
          # Collect diagnostic info
          collector = DiagnosticCollector()
          diagnostics = collector.collect_all()
          
          # Format as text
          details_text = f"""
  Version Information:
  ====================
  Version: {diagnostics['application']['version']}
  Build Number: {diagnostics['application'].get('build_number', 'N/A')}
  Commit SHA: {diagnostics['application'].get('commit_sha', 'N/A')}
  Build Date: {diagnostics['application'].get('build_date', 'N/A')}
  
  System Information:
  ===================
  Platform: {diagnostics['system']['platform']}
  OS Version: {diagnostics['system']['os_version']}
  Architecture: {diagnostics['system']['architecture']}
  Python Version: {diagnostics['system']['python_version']}
  
  Application Paths:
  =================
  Install Path: {diagnostics['application']['install_path']}
  Data Path: {diagnostics['application']['data_path']}
  Config Path: {diagnostics['application']['config_path']}
  Logs Path: {diagnostics['application']['logs_path']}
          """
          
          text_area.setPlainText(details_text)
          layout.addWidget(text_area)
          
          # Close button
          close_button = QPushButton("Close")
          close_button.clicked.connect(dialog.accept)
          layout.addWidget(close_button)
          
          dialog.setLayout(layout)
          dialog.exec()
  ```

**1.7.3.4 Version in Logs - Complete**
- **Enhanced Logging with Version**:
  ```python
  # In SRC/cuepoint/utils/logger.py
  from cuepoint.version import get_version_string, get_build_info
  
  def setup_logging():
      """Setup logging with version info"""
      import logging
      from logging.handlers import RotatingFileHandler
      from cuepoint.utils.paths import AppPaths
      
      # Get version info
      version = get_version_string()
      build_info = get_build_info()
      
      # Create formatter with version
      formatter = logging.Formatter(
          '%(asctime)s [%(levelname)s] [v{}] [%(name)s] %(message)s'.format(version),
          datefmt='%Y-%m-%d %H:%M:%S'
      )
      
      # File handler
      log_file = AppPaths.logs_dir() / "cuepoint.log"
      file_handler = RotatingFileHandler(
          log_file,
          maxBytes=10*1024*1024,  # 10MB
          backupCount=5
      )
      file_handler.setFormatter(formatter)
      file_handler.setLevel(logging.DEBUG)
      
      # Console handler
      console_handler = logging.StreamHandler()
      console_handler.setFormatter(formatter)
      console_handler.setLevel(logging.INFO)
      
      # Root logger
      root_logger = logging.getLogger()
      root_logger.setLevel(logging.DEBUG)
      root_logger.addHandler(file_handler)
      root_logger.addHandler(console_handler)
      
      # Log startup with version info
      root_logger.info(f"CuePoint starting - Version: {version}")
      if build_info.get("build_number"):
          root_logger.info(f"Build: {build_info['build_number']}")
      if build_info.get("commit_sha"):
          root_logger.info(f"Commit: {build_info['commit_sha'][:8]}")
  ```

## Version Management Workflow

### Development Workflow
1. **Development**: Work on features, version stays at current
2. **Release Preparation**: Update version in `version.py`
3. **Tag Creation**: Run `create_release_tag.sh`
4. **CI Build**: Tag triggers CI, sets build info
5. **Release**: CI publishes release with artifacts

### Version Bumping Strategy
- **MAJOR**: Breaking changes, major feature additions
- **MINOR**: New features, backward compatible
- **PATCH**: Bug fixes, minor improvements

## Testing and Validation

### Version Validation Tests
- **Test 1**: SemVer format validation
- **Test 2**: Version consistency across files
- **Test 3**: Build info injection
- **Test 4**: Version display in UI
- **Test 5**: Version in diagnostics

## Edge Cases

### Version Edge Cases
- **Case 1**: Version file missing
  - **Handling**: Use default version, log warning
- **Case 2**: Invalid version format
  - **Handling**: Fail build, show error
- **Case 3**: Git not available
  - **Handling**: Use date-based build number
- **Case 4**: Build info not set
  - **Handling**: Show as dev build

## Version Management Best Practices

### Version Bumping Guidelines
- **When to bump MAJOR**:
  - Breaking API changes
  - Incompatible configuration changes
  - Major architectural changes
  - Significant feature removals

- **When to bump MINOR**:
  - New features (backward compatible)
  - New export formats
  - Enhanced filtering options
  - Performance improvements

- **When to bump PATCH**:
  - Bug fixes
  - Security patches
  - Minor improvements
  - Documentation updates

### Version Consistency Checks
- **Pre-commit Hook**:
  ```python
  # .git/hooks/pre-commit
  #!/usr/bin/env python3
  """Pre-commit hook to check version consistency"""
  import subprocess
  import sys
  
  result = subprocess.run(
      ["python", "scripts/validate_version.py"],
      capture_output=True
  )
  
  if result.returncode != 0:
      print("Version validation failed:")
      print(result.stdout.decode())
      sys.exit(1)
  ```

### Version in CI/CD Integration
- **Build Step**: Set build info before building
- **Release Step**: Validate version matches tag
- **Artifact Naming**: Include version in artifact names
- **Release Notes**: Auto-generate from version

## Version Display Locations

### Where Version Appears
1. **About Dialog**: Full version string with build info
2. **Window Title**: Optional version in title bar
3. **Logs**: Version in every log entry
4. **Diagnostics**: Version in diagnostic exports
5. **Support Bundles**: Version in bundle metadata
6. **Error Messages**: Version in error context
7. **Update Checks**: Version for update comparison

## Version Testing Scenarios

### Test Scenarios
- **Scenario 1**: Version file updated, git tag created
- **Scenario 2**: Build info injected during CI
- **Scenario 3**: Version displayed in all locations
- **Scenario 4**: Version used in update checks
- **Scenario 5**: Version in diagnostic exports

## References

- Main document: `../01_Product_Requirements_and_Definition.md`
- Related: Step 2 (Build System), Step 5 (Updates), Step 6 (Diagnostics)
- SemVer: https://semver.org/
- Git Tagging: Git documentation

