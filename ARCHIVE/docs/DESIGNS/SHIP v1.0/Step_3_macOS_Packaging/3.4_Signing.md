# Implementation Step 3.4: Code Signing Implementation

## Implementation Overview
**What We're Building**: A comprehensive code signing system for macOS that ensures all code in the CuePoint application bundle is properly signed with a valid Developer ID certificate, enabling Gatekeeper trust, supporting notarization, and providing cryptographic verification of the app's authenticity and integrity. This includes signing automation, verification procedures, error handling, and integration with the CI/CD pipeline.

## Implementation Tasks

### Task 3.4.1: Define Signing Architecture

**What to Build**
- Signing process architecture
- Signing order and dependencies
- Signing identity management
- Certificate handling
- Signing automation framework

**Implementation Details**

**3.4.1.1 Signing Process Architecture**
- **Process Flow**:
  1. **Certificate Import**: Import Developer ID certificate to keychain
  2. **Nested Binary Signing**: Sign all nested executables and libraries
  3. **Framework Signing**: Sign all embedded frameworks
  4. **Helper Signing**: Sign any helper executables
  5. **App Bundle Signing**: Sign the main app bundle
  6. **Verification**: Verify all signatures
  7. **Gatekeeper Assessment**: Test Gatekeeper acceptance
- **Signing Order**: Critical - must sign nested items before parent
  - **Rationale**: Parent signature includes hashes of nested items
  - **Order**: Deepest items first, app bundle last
  - **Failure Impact**: Wrong order causes signature invalidation
- **Parallel Signing**: Some items can be signed in parallel
  - **Frameworks**: Can sign multiple frameworks simultaneously
  - **Nested Binaries**: Can sign multiple binaries simultaneously
  - **App Bundle**: Must be signed last (after all nested items)
- **Atomic Operations**: Signing should be atomic where possible
  - **Rationale**: Prevents partial signing states
  - **Implementation**: Sign to temporary location, then move
  - **Rollback**: Ability to rollback if signing fails

**3.4.1.2 Signing Identity Management**
- **Identity Format**: `Developer ID Application: {Name} ({Team ID})`
- **Identity Source**: Extracted from certificate
- **Identity Validation**: Verify identity matches expected
- **Identity Storage**: Environment variable or script parameter
- **Identity Usage**: Passed to codesign with `--sign` flag
- **Identity Consistency**: Must be consistent across all signing operations
- **Identity Documentation**: Document expected identity in scripts

**3.4.1.3 Certificate Management Architecture**
- **Certificate Storage**: GitHub Secrets (base64 encoded)
- **Certificate Format**: .p12 (PKCS#12)
- **Certificate Import**: Temporary keychain for CI builds
- **Certificate Lifecycle**:
  - **Acquisition**: From Apple Developer portal
  - **Export**: From Keychain Access (with password)
  - **Encoding**: Base64 encode for GitHub Secrets
  - **Storage**: GitHub Secrets (encrypted)
  - **Import**: To temporary keychain during build
  - **Usage**: For code signing
  - **Cleanup**: Remove from keychain after build
- **Certificate Security**:
  - Never commit to repository
  - Store only in GitHub Secrets
  - Use temporary keychains
  - Clean up after use
  - Rotate regularly

**3.4.1.4 Signing Automation Framework**
- **Automation Level**: Fully automated
- **Trigger**: Automatic on tag push (release builds)
- **Manual Override**: Workflow dispatch for testing
- **Error Handling**: Fail-fast with clear errors
- **Logging**: Comprehensive signing logs
- **Verification**: Automatic verification after signing
- **Integration**: Seamless CI/CD integration

### Task 3.4.2: Implement Nested Item Signing

**What to Build**
- Nested binary identification
- Framework identification
- Signing script for nested items
- Signing order management
- Nested item verification

**Implementation Details**

**3.4.2.1 Nested Binary Identification**
- **Nested Binaries**: Executables within app bundle
- **Locations**:
  - `Contents/MacOS/CuePoint` (main executable)
  - `Contents/MacOS/*` (helper executables, if any)
  - `Contents/Helpers/*` (helper tools, if any)
  - `Contents/Frameworks/*/Versions/*/` (framework executables)
- **Identification Method**: Find all executable files
  - **Command**: `find "$APP_PATH" -type f -perm +111`
  - **Filter**: Exclude already-signed items
  - **Sort**: Sign in dependency order (if applicable)
- **Binary Types**:
  - **Mach-O Executables**: Main executables
  - **Dynamic Libraries**: .dylib files
  - **Framework Executables**: Within frameworks
  - **Helper Tools**: Background processes, CLI tools

**3.4.2.2 Framework Identification**
- **Framework Locations**: `Contents/Frameworks/*.framework/`
- **Framework Structure**: Standard macOS framework bundle
  - `FrameworkName.framework/`
    - `Versions/Current/`
      - `FrameworkName` (executable)
      - `Resources/`
      - `Headers/`
- **Framework Types**:
  - **Qt Frameworks**: QtCore, QtGui, QtWidgets, QtNetwork
  - **Python Libraries**: May be in frameworks or embedded
  - **Third-Party Frameworks**: Any embedded frameworks
- **Framework Signing Requirements**:
  - Each framework must be signed individually
  - Framework executable must be signed
  - Framework resources may need signing (if executable)
  - Framework must be signed before app bundle

**3.4.2.3 Nested Item Signing Script**
- **Script**: `scripts/sign_macos.sh` (enhanced)
- **Functionality**:
  - Find all nested binaries
  - Find all frameworks
  - Sign each item with hardened runtime
  - Verify each signature
  - Report signing status
- **Signing Command**:
  ```bash
  codesign --force --sign "$IDENTITY" \
    --options runtime \
    --timestamp \
    "$ITEM_PATH"
  ```
- **Signing Options**:
  - `--force`: Replace existing signature
  - `--sign "$IDENTITY"`: Signing identity
  - `--options runtime`: Enable hardened runtime
  - `--timestamp`: Add timestamp (required for notarization)
- **Error Handling**:
  - Fail on signing error
  - Report which item failed
  - Provide troubleshooting guidance

**3.4.2.4 Signing Order Management**
- **Order Requirements**:
  1. Deepest nested items first
  2. Frameworks before app bundle
  3. Helpers before app bundle
  4. App bundle last
- **Dependency Resolution**:
  - Sign frameworks first (no dependencies on app)
  - Sign helpers next (may depend on frameworks)
  - Sign app bundle last (depends on all nested items)
- **Parallel Signing**:
  - Frameworks can be signed in parallel
  - Nested binaries can be signed in parallel
  - App bundle must wait for all nested items
- **Order Validation**:
  - Verify signing order is correct
  - Check dependencies before signing
  - Report order violations

**3.4.2.5 Nested Item Verification**
- **Verification After Signing**:
  - Verify each nested item signature
  - Check signing identity
  - Verify hardened runtime enabled
  - Check timestamp present
- **Verification Command**:
  ```bash
  codesign --verify --verbose "$ITEM_PATH"
  ```
- **Verification Checks**:
  - Signature valid
  - Identity correct
  - Hardened runtime enabled
  - Timestamp valid
  - No errors or warnings

### Task 3.4.3: Implement App Bundle Signing

**What to Build**
- App bundle signing procedure
- Deep signing configuration
- Entitlements application
- App bundle verification
- Signing script enhancement

**Implementation Details**

**3.4.3.1 App Bundle Signing Procedure**
- **Signing Command**:
  ```bash
  codesign --force --deep --sign "$IDENTITY" \
    --options runtime \
    --timestamp \
    --entitlements "$ENTITLEMENTS_FILE" \
    "$APP_PATH"
  ```
- **Signing Options Explained**:
  - `--force`: Replace existing signature
  - `--deep`: Sign nested items (but prefer explicit signing)
  - `--sign "$IDENTITY"`: Signing identity
  - `--options runtime`: Enable hardened runtime (required for notarization)
  - `--timestamp`: Add timestamp (required for notarization)
  - `--entitlements "$ENTITLEMENTS_FILE"`: Apply entitlements (if needed)
- **Signing Order**: After all nested items are signed
- **Signing Location**: App bundle root (`CuePoint.app/`)
- **Signing Result**: Code signature embedded in bundle

**3.4.3.2 Deep Signing Considerations**
- **--deep Flag**: Signs nested items automatically
  - **Advantage**: Simpler command
  - **Disadvantage**: Less control, may miss items
  - **Recommendation**: Use explicit signing instead
- **Explicit Signing**: Sign each item individually
  - **Advantage**: Full control, verifiable
  - **Disadvantage**: More complex script
  - **Recommendation**: Use explicit signing for reliability
- **Hybrid Approach**: Sign nested items explicitly, use --deep for app bundle
  - **Rationale**: Best of both worlds
  - **Implementation**: Sign nested items first, then app bundle with --deep
  - **Note**: --deep still verifies nested signatures

**3.4.3.3 Entitlements Application**
- **Entitlements File**: `build/entitlements.plist` (if needed)
- **Entitlements Application**: Via `--entitlements` flag
- **Entitlements Content**: Minimal, only required entitlements
- **Entitlements Validation**: Verify entitlements are necessary
- **Default**: No entitlements file (no special entitlements needed)
- **When to Add**: Only if app requires special capabilities
- **Entitlements Review**: Security review before adding

**3.4.3.4 App Bundle Verification**
- **Verification Command**:
  ```bash
  codesign --verify --deep --strict --verbose "$APP_PATH"
  ```
- **Verification Options**:
  - `--verify`: Verify signature
  - `--deep`: Verify nested items
  - `--strict`: Strict verification (fails on warnings)
  - `--verbose`: Detailed output
- **Verification Checks**:
  - App bundle signature valid
  - All nested items signed
  - Signing identity correct
  - Hardened runtime enabled
  - Timestamp present
  - Entitlements correct (if applied)
  - No errors or warnings
- **Gatekeeper Assessment**:
  ```bash
  spctl -a -vv --type execute "$APP_PATH"
  ```
- **Assessment Checks**:
  - Gatekeeper accepts app
  - Assessment source correct
  - No security warnings

**3.4.3.5 Signing Script Enhancement**
- **Current Script**: `scripts/sign_macos.sh`
- **Enhancements Needed**:
  - Better nested item detection
  - Explicit signing order
  - Comprehensive verification
  - Better error messages
  - Progress reporting
  - Signing summary
- **Script Structure**:
  1. Validate inputs
  2. Import certificate (if not already imported)
  3. Find and sign nested binaries
  4. Find and sign frameworks
  5. Sign app bundle
  6. Verify all signatures
  7. Gatekeeper assessment
  8. Report results

### Task 3.4.4: Implement Signing Verification

**What to Build**
- Comprehensive verification procedures
- Verification scripts
- Verification automation
- Verification reporting
- Failure diagnostics

**Implementation Details**

**3.4.4.1 Signature Verification Procedures**
- **Individual Item Verification**:
  - Verify each nested binary
  - Verify each framework
  - Verify app bundle
  - Check signing identity
  - Check hardened runtime
  - Check timestamp
- **Bundle-Wide Verification**:
  - Verify app bundle signature
  - Verify all nested items
  - Check signature consistency
  - Verify no unsigned items
- **Gatekeeper Verification**:
  - Test Gatekeeper acceptance
  - Verify assessment source
  - Check for warnings
- **Notarization Readiness**:
  - Verify hardened runtime enabled
  - Verify timestamp present
  - Verify entitlements correct
  - Check for common notarization blockers

**3.4.4.2 Verification Scripts**
- **Script**: `scripts/validate_signing.py` (exists, enhance)
- **Functionality**:
  - Verify app bundle signature
  - Verify all nested items
  - Check signing identity
  - Verify hardened runtime
  - Gatekeeper assessment
  - Generate verification report
- **Verification Commands**:
  - `codesign --verify --deep --strict`
  - `codesign -dvv` (signature details)
  - `spctl -a -vv` (Gatekeeper assessment)
  - `codesign --display --verbose` (signature display)
- **Output**: Detailed verification report

**3.4.4.3 Verification Automation**
- **Automation Points**:
  - After nested item signing
  - After app bundle signing
  - Before DMG creation
  - Before notarization
  - After notarization
- **CI Integration**: Automatic verification in build workflow
- **Failure Handling**: Build fails if verification fails
- **Reporting**: Verification results in build logs

**3.4.4.4 Verification Reporting**
- **Report Format**: Human-readable and machine-parseable
- **Report Content**:
  - Signing status (success/failure)
  - Signing identity
  - Hardened runtime status
  - Timestamp status
  - Entitlements (if any)
  - Gatekeeper assessment
  - Any warnings or errors
- **Report Location**: Build logs, artifact metadata
- **Report Usage**: Debugging, compliance, documentation

**3.4.4.5 Failure Diagnostics**
- **Diagnostic Information**:
  - Which item failed to sign
  - Signing error message
  - Certificate status
  - Keychain status
  - Identity availability
  - File permissions
- **Diagnostic Commands**:
  - `codesign -dvv` (signature details)
  - `security find-identity` (available identities)
  - `codesign --display --verbose` (signature display)
  - `spctl --assess --verbose` (Gatekeeper details)
- **Troubleshooting Guide**: Document common issues and solutions

### Task 3.4.5: Implement Certificate Import and Management

**What to Build**
- Certificate import automation
- Keychain management
- Certificate validation
- Certificate cleanup
- Certificate security

**Implementation Details**

**3.4.5.1 Certificate Import Process**
- **Import Script**: `scripts/import_macos_cert.sh` (exists)
- **Import Steps**:
  1. Create temporary keychain
  2. Set keychain as default
  3. Unlock keychain
  4. Decode base64 certificate
  5. Import certificate to keychain
  6. Set keychain partition list
  7. Verify certificate import
  8. Clean up certificate file
- **Import Command**:
  ```bash
  security import cert.p12 -k "$KEYCHAIN" \
    -P "$CERT_PASSWORD" \
    -T /usr/bin/codesign
  ```
- **Keychain Partition List**:
  ```bash
  security set-key-partition-list \
    -S apple-tool:,apple:,codesign: \
    -s -k "$KEYCHAIN_PASSWORD" \
    "$KEYCHAIN"
  ```
- **Rationale**: Allows codesign to access certificate without keychain password prompts

**3.4.5.2 Keychain Management**
- **Temporary Keychain**: `build.keychain`
- **Keychain Creation**:
  ```bash
  security create-keychain -p "" build.keychain
  security default-keychain -s build.keychain
  security unlock-keychain -p "" build.keychain
  security set-keychain-settings -t 3600 -u build.keychain
  ```
- **Keychain Settings**:
  - **Password**: Empty (temporary keychain)
  - **Timeout**: 3600 seconds (1 hour)
  - **Lock on sleep**: Disabled
- **Keychain Cleanup**: Remove after build (if possible)
- **Keychain Security**: Temporary, not persisted

**3.4.5.3 Certificate Validation**
- **Validation Checks**:
  - Certificate exists in keychain
  - Certificate type correct (Developer ID Application)
  - Certificate not expired
  - Certificate identity matches expected
  - Certificate accessible to codesign
- **Validation Commands**:
  ```bash
  security find-identity -v -p codesigning "$KEYCHAIN"
  security find-certificate -c "Developer ID Application" -p "$KEYCHAIN"
  ```
- **Validation Script**: `scripts/validate_certificate.py`
- **Validation Timing**: Before signing, after import

**3.4.5.4 Certificate Cleanup**
- **Cleanup Steps**:
  1. Remove certificate file (if temporary)
  2. Remove keychain (if temporary)
  3. Clear environment variables (if set)
  4. Log cleanup actions
- **Cleanup Timing**: After signing, after verification
- **Cleanup Security**: Ensure no certificate data remains
- **Cleanup Verification**: Verify cleanup completed

**3.4.5.5 Certificate Security**
- **Security Principles**:
  - Never commit certificates to repository
  - Store only in GitHub Secrets
  - Use temporary keychains
  - Clean up after use
  - Rotate regularly
  - Monitor for compromise
- **Security Measures**:
  - Base64 encoding for storage
  - Encrypted storage (GitHub Secrets)
  - Temporary keychains
  - Automatic cleanup
  - Access logging
  - Regular rotation

### Task 3.4.6: Implement Signing Error Handling

**What to Build**
- Error detection and classification
- Error recovery procedures
- Error reporting and logging
- Error prevention measures
- Troubleshooting documentation

**Implementation Details**

**3.4.6.1 Error Detection and Classification**
- **Error Types**:
  - **Certificate Errors**: Missing, expired, wrong type
  - **Signing Errors**: Failed to sign, invalid identity
  - **Verification Errors**: Signature invalid, identity mismatch
  - **Permission Errors**: File permissions, keychain access
  - **System Errors**: Keychain issues, system problems
- **Error Detection**:
  - Check command exit codes
  - Parse error messages
  - Verify expected outputs
  - Validate intermediate states
- **Error Classification**:
  - **Critical**: Blocks signing, must fix
  - **Warning**: May cause issues, should fix
  - **Info**: Informational, no action needed

**3.4.6.2 Error Recovery Procedures**
- **Certificate Errors**:
  - Check certificate availability
  - Verify certificate validity
  - Re-import certificate if needed
  - Update certificate if expired
- **Signing Errors**:
  - Retry signing (transient errors)
  - Check file permissions
  - Verify identity availability
  - Review signing order
- **Verification Errors**:
  - Re-sign if needed
  - Check signing order
  - Verify nested items
  - Review error messages
- **Recovery Automation**: Automatic retry for transient errors
- **Manual Intervention**: Clear error messages for manual fixes

**3.4.6.3 Error Reporting and Logging**
- **Logging Requirements**:
  - All signing commands logged
  - All errors logged with context
  - All warnings logged
  - Signing summary logged
- **Error Messages**:
  - Clear and actionable
  - Include error context
  - Suggest solutions
  - Reference documentation
- **Error Reporting**:
  - Console output
  - Build logs
  - Error artifacts (if applicable)
  - Notification (on failure)

**3.4.6.4 Error Prevention Measures**
- **Pre-Signing Validation**:
  - Validate certificate before signing
  - Check file permissions
  - Verify identity availability
  - Validate bundle structure
- **Signing Best Practices**:
  - Use explicit signing order
  - Verify after each step
  - Use hardened runtime
  - Add timestamps
- **Post-Signing Validation**:
  - Verify all signatures
  - Check Gatekeeper
  - Validate for notarization
  - Comprehensive testing

**3.4.6.5 Troubleshooting Documentation**
- **Troubleshooting Guide**: `DOCS/TROUBLESHOOTING/Signing_Issues.md`
- **Common Issues**:
  - Certificate not found
  - Signing identity invalid
  - Hardened runtime errors
  - Gatekeeper warnings
  - Notarization failures
- **Solutions**: Step-by-step solutions for each issue
- **Diagnostic Commands**: Commands to diagnose issues
- **Support**: Contact information for help

### Task 3.4.7: Implement CI/CD Integration

**What to Build**
- GitHub Actions workflow integration
- Signing automation in CI
- Certificate import in CI
- Verification in CI
- Error handling in CI

**Implementation Details**

**3.4.7.1 Workflow Integration**
- **Workflow File**: `.github/workflows/build-macos.yml`
- **Signing Steps**:
  1. Import certificate
  2. Sign app bundle
  3. Verify signing
  4. Create DMG
  5. Sign DMG (if needed)
  6. Verify DMG signing
- **Conditional Execution**: Only on version tags
- **Error Handling**: Fail workflow on signing failure
- **Artifact Upload**: Upload signed app bundle

**3.4.7.2 Certificate Import in CI**
- **Import Step**: Before signing
- **Certificate Source**: GitHub Secrets
- **Import Script**: `scripts/import_macos_cert.sh`
- **Environment Variables**:
  - `MACOS_SIGNING_CERT_P12`: Base64 certificate
  - `MACOS_SIGNING_CERT_PASSWORD`: Certificate password
- **Keychain Management**: Temporary keychain for CI
- **Cleanup**: Automatic cleanup after build

**3.4.7.3 Signing Automation in CI**
- **Signing Step**: After app bundle creation
- **Signing Script**: `scripts/sign_macos.sh`
- **Identity Source**: Environment variable or script parameter
- **Signing Options**: Hardened runtime, timestamp
- **Verification**: Automatic after signing
- **Failure Handling**: Workflow fails on signing failure

**3.4.7.4 Verification in CI**
- **Verification Steps**:
  - After nested item signing
  - After app bundle signing
  - Before DMG creation
  - After DMG creation (if DMG signed)
- **Verification Scripts**:
  - `scripts/validate_signing.py`
  - `codesign` verification commands
  - `spctl` Gatekeeper assessment
- **Failure Handling**: Workflow fails on verification failure

**3.4.7.5 Error Handling in CI**
- **Error Detection**: Check command exit codes
- **Error Reporting**: Clear error messages in logs
- **Error Notification**: Notify on signing failure
- **Error Artifacts**: Save diagnostic information
- **Retry Logic**: Retry transient errors
- **Failure Recovery**: Manual intervention procedures

### Task 3.4.8: Implement Signing Best Practices

**What to Build**
- Signing best practices documentation
- Signing checklist
- Signing validation procedures
- Signing performance optimization
- Signing security hardening

**Implementation Details**

**3.4.8.1 Signing Best Practices**
- **Explicit Signing**: Sign each item explicitly, not just --deep
- **Signing Order**: Sign nested items before parent
- **Hardened Runtime**: Always enable for notarization
- **Timestamps**: Always add timestamps
- **Entitlements**: Minimal entitlements only
- **Verification**: Verify after each signing step
- **Documentation**: Document all signing steps
- **Automation**: Automate all signing steps

**3.4.8.2 Signing Checklist**
- **Pre-Signing**:
  - [ ] Certificate valid and not expired
  - [ ] Certificate imported to keychain
  - [ ] Signing identity verified
  - [ ] App bundle structure correct
  - [ ] All files present
- **Signing**:
  - [ ] Nested binaries signed
  - [ ] Frameworks signed
  - [ ] App bundle signed
  - [ ] Hardened runtime enabled
  - [ ] Timestamps added
- **Post-Signing**:
  - [ ] All signatures verified
  - [ ] Gatekeeper assessment passes
  - [ ] Signing identity correct
  - [ ] Ready for notarization

**3.4.8.3 Signing Validation Procedures**
- **Validation Levels**:
  - **Basic**: Signature exists and is valid
  - **Standard**: Basic + identity verification
  - **Strict**: Standard + Gatekeeper assessment
  - **Comprehensive**: Strict + notarization readiness
- **Validation Frequency**:
  - After each signing step
  - Before DMG creation
  - Before notarization
  - After notarization
  - Before release
- **Validation Automation**: Automated in CI/CD

**3.4.8.4 Signing Performance Optimization**
- **Parallel Signing**: Sign independent items in parallel
- **Caching**: Cache signing results where possible
- **Incremental Signing**: Only re-sign changed items
- **Optimization Trade-offs**: Balance speed vs. reliability
- **Performance Monitoring**: Track signing times

**3.4.8.5 Signing Security Hardening**
- **Certificate Security**: Secure storage and handling
- **Keychain Security**: Temporary keychains, automatic cleanup
- **Identity Verification**: Verify identity before signing
- **Signature Verification**: Verify after signing
- **Audit Logging**: Log all signing operations
- **Access Control**: Limit who can trigger signing
- **Rotation**: Regular certificate rotation

## Implementation Checklist

### Signing Architecture
- [ ] Define signing process architecture
- [ ] Define signing order
- [ ] Define certificate management
- [ ] Create signing automation framework

### Nested Item Signing
- [ ] Implement nested binary identification
- [ ] Implement framework identification
- [ ] Create nested item signing script
- [ ] Implement signing order management
- [ ] Create nested item verification

### App Bundle Signing
- [ ] Implement app bundle signing procedure
- [ ] Configure deep signing
- [ ] Implement entitlements application
- [ ] Create app bundle verification
- [ ] Enhance signing script

### Signing Verification
- [ ] Create verification procedures
- [ ] Create verification scripts
- [ ] Automate verification
- [ ] Create verification reporting
- [ ] Create failure diagnostics

### Certificate Management
- [ ] Implement certificate import
- [ ] Implement keychain management
- [ ] Create certificate validation
- [ ] Implement certificate cleanup
- [ ] Implement certificate security

### Error Handling
- [ ] Implement error detection
- [ ] Create error recovery procedures
- [ ] Implement error reporting
- [ ] Create error prevention measures
- [ ] Create troubleshooting documentation

### CI/CD Integration
- [ ] Integrate with GitHub Actions
- [ ] Automate certificate import
- [ ] Automate signing
- [ ] Automate verification
- [ ] Implement error handling

### Best Practices
- [ ] Document best practices
- [ ] Create signing checklist
- [ ] Create validation procedures
- [ ] Optimize performance
- [ ] Harden security

## Files to Create/Modify

### New Files
1. `DOCS/DESIGNS/SHIP v1.0/Step_3_macOS_Packaging/3.4_Signing.md` - This document
2. `scripts/validate_certificate.py` - Certificate validation
3. `DOCS/TROUBLESHOOTING/Signing_Issues.md` - Troubleshooting guide

### Files to Modify
1. `scripts/sign_macos.sh` - Enhanced signing script
2. `scripts/validate_signing.py` - Enhanced verification
3. `.github/workflows/build-macos.yml` - Signing integration
4. `DOCS/DESIGNS/SHIP v1.0/Step_3_macOS_Packaging/README.md` - Add reference

## Implementation Dependencies

### Prerequisites
- Step 2: Build System (provides infrastructure)
- Step 3.2: Build Output (app bundle structure)
- Step 3.3: Bundle Identity (bundle ID and metadata)
- Apple Developer account and certificate

### Enables
- Step 3.5: Notarization (requires signed app)
- Step 5: Auto-Update (requires signed app)

## Success Criteria

### Signing
- ✅ All code properly signed
- ✅ Signing identity correct
- ✅ Hardened runtime enabled
- ✅ Timestamps present
- ✅ All signatures verified

### Verification
- ✅ All verification passes
- ✅ Gatekeeper assessment passes
- ✅ Ready for notarization
- ✅ No signing errors

### Automation
- ✅ Fully automated signing
- ✅ CI/CD integration complete
- ✅ Error handling robust
- ✅ Documentation complete

## Next Implementation Steps

After completing Step 3.4:
1. **Step 3.5**: Notarization (notarizes signed app)
2. **Step 3.6**: Runtime Requirements (validates architecture support)

## Detailed Implementation Guidance

### Signing Script Example

**Enhanced Signing Script**:
```bash
#!/bin/bash
# Enhanced macOS signing script

set -e

APP_PATH="$1"
IDENTITY="${APPLE_DEVELOPER_ID:-Developer ID Application: StuChain (TEAM_ID)}"
ENTITLEMENTS="${ENTITLEMENTS_FILE:-}"

if [ -z "$APP_PATH" ]; then
    echo "Usage: $0 <path-to-app> [identity] [entitlements]"
    exit 1
fi

echo "Signing application: $APP_PATH"
echo "Using identity: $IDENTITY"

# Step 1: Sign nested binaries
echo "Step 1: Signing nested binaries..."
find "$APP_PATH/Contents/MacOS" -type f -perm +111 | while read binary; do
    echo "  Signing: $binary"
    codesign --force --sign "$IDENTITY" \
        --options runtime \
        --timestamp \
        "$binary"
done

# Step 2: Sign frameworks
echo "Step 2: Signing frameworks..."
find "$APP_PATH/Contents/Frameworks" -name "*.framework" | while read framework; do
    echo "  Signing: $framework"
    codesign --force --sign "$IDENTITY" \
        --options runtime \
        --timestamp \
        "$framework"
done

# Step 3: Sign app bundle
echo "Step 3: Signing app bundle..."
SIGN_CMD="codesign --force --deep --sign \"$IDENTITY\" --options runtime --timestamp"
if [ -n "$ENTITLEMENTS" ]; then
    SIGN_CMD="$SIGN_CMD --entitlements \"$ENTITLEMENTS\""
fi
eval "$SIGN_CMD \"$APP_PATH\""

# Step 4: Verify
echo "Step 4: Verifying signatures..."
codesign --verify --deep --strict --verbose "$APP_PATH"
spctl -a -vv --type execute "$APP_PATH"

echo "Signing complete"
```

### Verification Script Example

**Comprehensive Verification**:
```bash
#!/bin/bash
# Comprehensive signing verification

APP_PATH="$1"

echo "Verifying signatures for: $APP_PATH"

# Verify app bundle
echo "1. Verifying app bundle signature..."
codesign --verify --deep --strict --verbose "$APP_PATH"
if [ $? -ne 0 ]; then
    echo "ERROR: App bundle signature verification failed"
    exit 1
fi

# Check signing identity
echo "2. Checking signing identity..."
IDENTITY=$(codesign -dvv "$APP_PATH" 2>&1 | grep "Authority=" | head -1)
echo "  Identity: $IDENTITY"
if [[ "$IDENTITY" != *"Developer ID Application"* ]]; then
    echo "ERROR: Invalid signing identity"
    exit 1
fi

# Check hardened runtime
echo "3. Checking hardened runtime..."
RUNTIME=$(codesign -dvv "$APP_PATH" 2>&1 | grep "runtime")
if [ -z "$RUNTIME" ]; then
    echo "ERROR: Hardened runtime not enabled"
    exit 1
fi
echo "  Hardened runtime: Enabled"

# Gatekeeper assessment
echo "4. Gatekeeper assessment..."
spctl -a -vv --type execute "$APP_PATH"
if [ $? -ne 0 ]; then
    echo "WARNING: Gatekeeper assessment failed (may need notarization)"
fi

echo "Verification complete"
```

## References

- Main document: `../03_macOS_Packaging_Signing_Notarization.md`
- Related: Step 3.3 (Bundle Identity), Step 3.5 (Notarization)
- Apple Code Signing Guide: https://developer.apple.com/documentation/security/code_signing_services
- codesign Manual: `man codesign`
- Gatekeeper Documentation: https://support.apple.com/en-us/HT202491
