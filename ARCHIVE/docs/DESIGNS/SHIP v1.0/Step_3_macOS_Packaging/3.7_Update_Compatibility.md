# Implementation Step 3.7: Update Compatibility and Integration

## Implementation Overview
**What We're Building**: A comprehensive update compatibility system that ensures CuePoint's auto-update mechanism works correctly with signed and notarized app bundles, maintains bundle identity consistency across updates, preserves user data during updates, and provides a seamless update experience. This includes update system integration, bundle ID stability, signing identity consistency, and update validation procedures.

## Implementation Tasks

### Task 3.7.1: Define Update System Requirements

**What to Build**
- Update system architecture requirements
- Bundle ID stability requirements
- Signing identity consistency requirements
- Update compatibility validation
- Update system integration points

**Implementation Details**

**3.7.1.1 Update System Architecture**
- **Update Framework**: Sparkle (macOS standard)
  - **Purpose**: In-app update checking and installation
  - **Format**: Appcast XML feed
  - **Integration**: Embedded in app bundle
  - **Functionality**: Check for updates, download, install
- **Update Feed**: Appcast XML on GitHub Pages
  - **Location**: `updates/macos/appcast.xml`
  - **Format**: Sparkle appcast format
  - **Content**: Version, download URL, release notes, signatures
  - **Updates**: Updated on each release
- **Update Process**:
  1. App checks appcast for updates
  2. User prompted if update available
  3. User downloads new DMG
  4. User installs new version (replaces old)
  5. App launches new version
- **Update Compatibility**: Must work with signed/notarized apps

**3.7.1.2 Bundle ID Stability Requirement**
- **Stability Requirement**: Bundle ID must never change
  - **Rationale**: Changing bundle ID creates new app identity
  - **Impact**: Updates fail, user data lost, app conflicts
  - **Rule**: Bundle ID is permanent, set once, never changed
- **Bundle ID Value**: `com.stuchain.cuepoint`
  - **Format**: Reverse domain notation
  - **Consistency**: Must be identical across all versions
  - **Validation**: Automated validation in CI
- **Bundle ID Usage**:
  - **Update System**: Sparkle uses bundle ID to identify app
  - **System Integration**: macOS uses bundle ID for app identification
  - **User Data**: Application Support uses bundle ID for data location
  - **File Associations**: Bundle ID used for file type associations
- **Bundle ID Validation**:
  - Pre-release: Verify bundle ID matches previous version
  - Post-build: Verify bundle ID in app bundle
  - Update test: Verify update preserves bundle ID

**3.7.1.3 Signing Identity Consistency**
- **Consistency Requirement**: Signing identity must be consistent
  - **Rationale**: Inconsistent identity breaks update trust
  - **Impact**: Updates may be rejected, security warnings
  - **Rule**: Use same Developer ID certificate for all releases
- **Signing Identity**: `Developer ID Application: StuChain (TEAM_ID)`
  - **Format**: Standard Developer ID format
  - **Consistency**: Must be identical across all versions
  - **Validation**: Automated validation in CI
- **Identity Usage**:
  - **Update System**: Sparkle verifies signing identity
  - **Gatekeeper**: Uses identity for trust decisions
  - **User Trust**: Users trust consistent identity
- **Identity Validation**:
  - Pre-release: Verify identity matches previous version
  - Post-build: Verify identity in code signature
  - Update test: Verify update preserves identity

**3.7.1.4 Update Compatibility Validation**
- **Validation Requirements**:
  - Bundle ID matches previous version
  - Signing identity matches previous version
  - Update process completes successfully
  - User data preserved
  - App launches correctly after update
- **Validation Procedures**:
  - Automated update simulation
  - Manual update testing
  - User acceptance testing
  - Compatibility matrix testing
- **Validation Script**: `scripts/validate_update_compatibility.py`
- **Validation Timing**: Before release, after build

### Task 3.7.2: Implement Bundle ID Stability

**What to Build**
- Bundle ID definition and enforcement
- Bundle ID validation procedures
- Bundle ID consistency checks
- Bundle ID documentation
- Bundle ID change prevention

**Implementation Details**

**3.7.2.1 Bundle ID Definition**
- **Bundle ID**: `com.stuchain.cuepoint`
- **Definition Location**: Multiple places (must be consistent)
  - `build/pyinstaller.spec`: `bundle_identifier='com.stuchain.cuepoint'`
  - `build/Info.plist.template`: `CFBundleIdentifier` key
  - `build/Info.plist`: Processed template (final)
  - `CuePoint.app/Contents/Info.plist`: In app bundle
- **Bundle ID Format**: Reverse domain notation
- **Bundle ID Rules**:
  - Must be unique
  - Must be consistent
  - Must never change
  - Must be valid format

**3.7.2.2 Bundle ID Validation**
- **Validation Points**:
  - Pre-build: Verify bundle ID in source files
  - Post-build: Verify bundle ID in app bundle
  - Pre-release: Compare with previous release
  - Update test: Verify update preserves bundle ID
- **Validation Script**: `scripts/validate_bundle_id.py`
- **Validation Checks**:
  - Bundle ID present in all locations
  - Bundle ID format valid
  - Bundle ID consistent across files
  - Bundle ID matches previous version
- **Validation Failure**: Build fails if bundle ID inconsistent

**3.7.2.3 Bundle ID Consistency Enforcement**
- **Enforcement Methods**:
  - Single source of truth (Info.plist template)
  - Automated validation in CI
  - Pre-commit hooks (optional)
  - Code review requirements
- **Consistency Checks**:
  - Compare bundle ID across all files
  - Compare with previous release
  - Verify no accidental changes
- **Change Prevention**:
  - Document bundle ID as permanent
  - Code review for bundle ID changes
  - Automated checks prevent changes
  - Clear warnings if change detected

**3.7.2.4 Bundle ID Documentation**
- **Documentation Location**: `DOCS/METADATA/Bundle_ID.md`
- **Documentation Content**:
  - Bundle ID value
  - Bundle ID format
  - Bundle ID usage
  - Bundle ID stability policy
  - Bundle ID change procedure (if ever needed)
- **Documentation Updates**: Update if bundle ID changes (should never happen)

### Task 3.7.3: Implement Update Process Integration

**What to Build**
- Update process design
- Update installation procedures
- Update validation
- Update rollback procedures
- Update user experience

**Implementation Details**

**3.7.3.1 Update Process Design**
- **Update Flow**:
  1. App checks appcast for updates (on startup or scheduled)
  2. If update available, show notification to user
  3. User chooses to update or skip
  4. If update, download new DMG
  5. Verify DMG signature and notarization
  6. Install new version (replace old app)
  7. Launch new version
  8. Verify update successful
- **Update Triggers**:
  - On app startup
  - Scheduled check (daily, weekly)
  - Manual check (user-initiated)
  - Background check (optional)
- **Update User Experience**:
  - Non-blocking notification
  - Clear version information
  - Release notes preview
  - One-click update (if enabled)
  - Progress indication

**3.7.3.2 Update Installation Procedures**
- **Installation Method**: Replace app bundle
  - **Source**: New DMG from update
  - **Target**: `/Applications/CuePoint.app`
  - **Method**: Replace existing app bundle
  - **Backup**: Optional backup of old version
- **Installation Steps**:
  1. Download new DMG
  2. Mount DMG
  3. Verify DMG signature and notarization
  4. Quit current app (if running)
  5. Replace app bundle in Applications
  6. Verify new app launches
  7. Clean up old files (if any)
- **Installation Validation**:
  - Verify new app launches
  - Verify version updated
  - Verify functionality works
  - Verify user data preserved

**3.7.3.3 Update Validation**
- **Pre-Update Validation**:
  - Verify update available
  - Verify update is newer version
  - Verify update is compatible
  - Verify disk space available
- **Post-Update Validation**:
  - Verify new app launches
  - Verify version correct
  - Verify functionality works
  - Verify user data preserved
- **Validation Script**: `scripts/validate_update.py`
- **Validation Automation**: Automated in update process

**3.7.3.4 Update Rollback Procedures**
- **Rollback Scenarios**:
  - Update fails
  - Update causes issues
  - User requests rollback
- **Rollback Methods**:
  - **Automatic**: Restore from backup (if available)
  - **Manual**: User reinstalls previous version
  - **Appcast**: Remove update from appcast
- **Rollback Prevention**:
  - Thorough testing before release
  - Staged rollouts (if possible)
  - Quick hotfix capability
- **Rollback Documentation**: Document rollback procedures

**3.7.3.5 Update User Experience**
- **Update Notification**:
  - Clear and informative
  - Non-intrusive
  - Actionable (update now or later)
  - Includes version and release notes
- **Update Progress**:
  - Download progress
  - Installation progress
  - Clear status messages
  - Error handling
- **Update Completion**:
  - Success confirmation
  - Launch new version
  - Show what's new (optional)

### Task 3.7.4: Implement Update Compatibility Testing

**What to Build**
- Update compatibility test procedures
- Update simulation automation
- Update test scenarios
- Update test reporting
- Update test documentation

**Implementation Details**

**3.7.4.1 Update Compatibility Test Procedures**
- **Test Scenarios**:
  - Update from previous version
  - Update across multiple versions
  - Update with app running
  - Update with app not running
  - Update with user data present
  - Update with custom settings
- **Test Environments**:
  - Different macOS versions
  - Different architectures
  - Different user configurations
- **Test Automation**: Automated update simulation
- **Manual Testing**: Manual testing on physical hardware

**3.7.4.2 Update Simulation Automation**
- **Simulation Script**: `scripts/simulate_update.py`
- **Simulation Steps**:
  1. Install previous version
  2. Create test user data
  3. Simulate update check
  4. Download new version
  5. Install new version
  6. Verify update successful
  7. Verify data preserved
- **Simulation Automation**: Automated in CI (if possible)
- **Simulation Reporting**: Comprehensive test reports

**3.7.4.3 Update Test Scenarios**
- **Scenario 1: Standard Update**
  - Previous version installed
  - Update to new version
  - Verify update successful
- **Scenario 2: Skip Versions**
  - Old version installed
  - Update to much newer version
  - Verify update successful
- **Scenario 3: Data Preservation**
  - Previous version with user data
  - Update to new version
  - Verify data preserved
- **Scenario 4: Settings Preservation**
  - Previous version with settings
  - Update to new version
  - Verify settings preserved

**3.7.4.4 Update Test Reporting**
- **Report Format**: Comprehensive test report
- **Report Content**:
  - Test scenarios executed
  - Test results (pass/fail)
  - Issues found
  - Recommendations
- **Report Location**: Test artifacts, build logs
- **Report Usage**: Debugging, compliance, documentation

### Task 3.7.5: Implement Update System Security

**What to Build**
- Update signature verification
- Update integrity checks
- Update source validation
- Update security documentation
- Update security testing

**Implementation Details**

**3.7.5.1 Update Signature Verification**
- **Verification Requirements**:
  - DMG signature verified
  - Notarization verified
  - App bundle signature verified
  - All nested items signed
- **Verification Process**:
  - Verify DMG signature before mounting
  - Verify notarization ticket
  - Verify app bundle signature after installation
  - Verify all nested items
- **Verification Automation**: Automatic in update process
- **Verification Failure**: Reject update if verification fails

**3.7.5.2 Update Integrity Checks**
- **Integrity Requirements**:
  - DMG integrity verified
  - App bundle integrity verified
  - No tampering detected
  - Checksums match
- **Integrity Checks**:
  - Verify DMG checksum
  - Verify app bundle checksum
  - Verify code signatures
  - Verify notarization
- **Integrity Automation**: Automatic in update process

**3.7.5.3 Update Source Validation**
- **Source Requirements**:
  - Appcast from trusted source
  - Download URLs from trusted domain
  - HTTPS connections only
  - Certificate validation
- **Source Validation**:
  - Verify appcast source
  - Verify download URL domain
  - Verify HTTPS certificate
  - Verify source authenticity
- **Source Security**: Secure appcast hosting, HTTPS only

**3.7.5.4 Update Security Documentation**
- **Documentation Location**: `DOCS/SECURITY/Update_Security.md`
- **Documentation Content**:
  - Update security measures
  - Signature verification process
  - Integrity checks
  - Source validation
  - Security best practices
- **Documentation Updates**: Update when security measures change

## Implementation Checklist

### Update Requirements
- [ ] Define update system requirements
- [ ] Define bundle ID stability
- [ ] Define signing identity consistency
- [ ] Create compatibility validation

### Bundle ID Stability
- [ ] Define bundle ID
- [ ] Create bundle ID validation
- [ ] Enforce bundle ID consistency
- [ ] Document bundle ID policy

### Update Integration
- [ ] Design update process
- [ ] Implement installation procedures
- [ ] Create update validation
- [ ] Create rollback procedures
- [ ] Design user experience

### Update Testing
- [ ] Create test procedures
- [ ] Create simulation automation
- [ ] Define test scenarios
- [ ] Create test reporting

### Update Security
- [ ] Implement signature verification
- [ ] Implement integrity checks
- [ ] Implement source validation
- [ ] Create security documentation

## Files to Create/Modify

### New Files
1. `DOCS/DESIGNS/SHIP v1.0/Step_3_macOS_Packaging/3.7_Update_Compatibility.md` - This document
2. `scripts/validate_update_compatibility.py` - Update compatibility validation
3. `scripts/simulate_update.py` - Update simulation
4. `scripts/validate_update.py` - Update validation
5. `DOCS/METADATA/Bundle_ID.md` - Bundle ID documentation
6. `DOCS/SECURITY/Update_Security.md` - Update security documentation

### Files to Modify
1. `scripts/validate_bundle_id.py` - Bundle ID validation
2. `DOCS/DESIGNS/SHIP v1.0/Step_3_macOS_Packaging/README.md` - Add reference

## Implementation Dependencies

### Prerequisites
- Step 3.3: Bundle Identity (bundle ID definition)
- Step 3.4: Signing (signing identity)
- Step 5: Auto-Update System (update mechanism)

### Enables
- Step 5: Auto-Update System (update compatibility)
- User updates (seamless update experience)

## Success Criteria

### Update Compatibility
- ✅ Bundle ID stable across versions
- ✅ Signing identity consistent
- ✅ Updates work correctly
- ✅ User data preserved

### Update Testing
- ✅ Update tests pass
- ✅ Update simulation works
- ✅ Test scenarios covered
- ✅ Test reporting complete

### Update Security
- ✅ Signatures verified
- ✅ Integrity checked
- ✅ Source validated
- ✅ Security documented

## Next Implementation Steps

After completing Step 3.7:
1. **Step 3.8**: Common Pitfalls (prevents known issues)
2. **Step 5**: Auto-Update System (implements update mechanism)

## Detailed Implementation Guidance

### Bundle ID Stability Enforcement

**Automated Bundle ID Validation**:
```python
#!/usr/bin/env python3
"""Validate bundle ID stability across versions"""

import plistlib
import subprocess
import sys
from pathlib import Path

EXPECTED_BUNDLE_ID = 'com.stuchain.cuepoint'

def get_bundle_id_from_app(app_path):
    """Get bundle ID from app bundle"""
    info_plist = Path(app_path) / 'Contents' / 'Info.plist'
    if not info_plist.exists():
        return None
    
    with open(info_plist, 'rb') as f:
        plist = plistlib.load(f)
    
    return plist.get('CFBundleIdentifier')

def get_bundle_id_from_spec():
    """Get bundle ID from PyInstaller spec"""
    spec_path = Path('build/pyinstaller.spec')
    if not spec_path.exists():
        return None
    
    content = spec_path.read_text()
    # Extract bundle_identifier value
    import re
    match = re.search(r"bundle_identifier\s*=\s*['\"]([^'\"]+)['\"]", content)
    if match:
        return match.group(1)
    return None

def get_previous_bundle_id():
    """Get bundle ID from previous release (if available)"""
    # Try to get from git tag or release
    try:
        result = subprocess.run(
            ['git', 'describe', '--tags', '--abbrev=0'],
            capture_output=True,
            text=True
        )
        if result.returncode == 0:
            tag = result.stdout.strip()
            # Could check previous release's bundle ID
            # For now, assume it matches expected
            return EXPECTED_BUNDLE_ID
    except:
        pass
    return None

def validate_bundle_id_stability():
    """Validate bundle ID is stable"""
    errors = []
    
    # Check spec file
    spec_id = get_bundle_id_from_spec()
    if spec_id and spec_id != EXPECTED_BUNDLE_ID:
        errors.append(f"Spec file has wrong bundle ID: {spec_id}")
    
    # Check app bundle (if exists)
    app_path = Path('dist/CuePoint.app')
    if app_path.exists():
        app_id = get_bundle_id_from_app(app_path)
        if app_id != EXPECTED_BUNDLE_ID:
            errors.append(f"App bundle has wrong bundle ID: {app_id}")
    
    # Check previous version (if available)
    previous_id = get_previous_bundle_id()
    if previous_id and previous_id != EXPECTED_BUNDLE_ID:
        errors.append(f"Previous version had different bundle ID: {previous_id}")
    
    return len(errors) == 0, errors

if __name__ == '__main__':
    valid, errors = validate_bundle_id_stability()
    
    if valid:
        print(f"Bundle ID validation passed: {EXPECTED_BUNDLE_ID}")
        sys.exit(0)
    else:
        print("Bundle ID validation failed:")
        for error in errors:
            print(f"  {error}")
        sys.exit(1)
```

### Update Process Integration

**Update Installation Script**:
```python
#!/usr/bin/env python3
"""Update installation helper"""

import shutil
import subprocess
import sys
from pathlib import Path

def install_update(dmg_path, applications_path='/Applications'):
    """Install update from DMG"""
    # Mount DMG
    mount_point = mount_dmg(dmg_path)
    
    try:
        # Find app in DMG
        app_in_dmg = Path(mount_point) / 'CuePoint.app'
        if not app_in_dmg.exists():
            raise FileNotFoundError("CuePoint.app not found in DMG")
        
        # Quit current app (if running)
        quit_current_app()
        
        # Replace app in Applications
        app_in_apps = Path(applications_path) / 'CuePoint.app'
        if app_in_apps.exists():
            shutil.rmtree(app_in_apps)
        
        shutil.copytree(app_in_dmg, app_in_apps)
        
        # Verify new app launches
        verify_app_launches(app_in_apps)
        
    finally:
        # Unmount DMG
        unmount_dmg(mount_point)

def mount_dmg(dmg_path):
    """Mount DMG and return mount point"""
    result = subprocess.run(
        ['hdiutil', 'attach', str(dmg_path), '-nobrowse', '-quiet'],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        raise RuntimeError(f"Failed to mount DMG: {result.stderr}")
    
    # Parse mount point from output
    # Format: /dev/diskX  /Volumes/CuePoint
    lines = result.stdout.strip().split('\n')
    for line in lines:
        if '/Volumes/' in line:
            return line.split()[-1]
    
    raise RuntimeError("Could not determine mount point")

def unmount_dmg(mount_point):
    """Unmount DMG"""
    subprocess.run(
        ['hdiutil', 'detach', mount_point, '-quiet'],
        check=False
    )

def quit_current_app():
    """Quit current app instance"""
    subprocess.run(
        ['osascript', '-e', 'tell application "CuePoint" to quit'],
        check=False
    )

def verify_app_launches(app_path):
    """Verify app can launch"""
    # Try to launch app
    result = subprocess.run(
        ['open', str(app_path)],
        check=False,
        timeout=10
    )
    
    if result.returncode != 0:
        raise RuntimeError("App failed to launch after update")
```

### Update Compatibility Testing

**Update Simulation Script**:
```python
#!/usr/bin/env python3
"""Simulate update process"""

import shutil
import subprocess
import sys
import tempfile
from pathlib import Path

def simulate_update(old_version_path, new_version_dmg):
    """Simulate update from old version to new"""
    print("Simulating update process...")
    
    # Step 1: Install old version
    print("1. Installing old version...")
    install_app(old_version_path, '/tmp/CuePoint_old.app')
    
    # Step 2: Create test user data
    print("2. Creating test user data...")
    user_data = create_test_user_data()
    
    # Step 3: Simulate update check
    print("3. Simulating update check...")
    update_available = check_for_update()
    
    if not update_available:
        print("No update available")
        return False
    
    # Step 4: Download new version
    print("4. Downloading new version...")
    # (In real scenario, download from URL)
    
    # Step 5: Install new version
    print("5. Installing new version...")
    install_app_from_dmg(new_version_dmg, '/tmp/CuePoint_new.app')
    
    # Step 6: Verify update
    print("6. Verifying update...")
    verify_update_successful('/tmp/CuePoint_new.app', user_data)
    
    print("Update simulation complete")
    return True

def create_test_user_data():
    """Create test user data"""
    data_dir = Path.home() / 'Library' / 'Application Support' / 'CuePoint'
    data_dir.mkdir(parents=True, exist_ok=True)
    
    # Create test files
    test_file = data_dir / 'test_data.json'
    test_file.write_text('{"test": "data"}')
    
    return data_dir

def verify_update_successful(app_path, user_data):
    """Verify update was successful"""
    # Check app launches
    # Check user data preserved
    # Check version updated
    pass
```

### Update Security Implementation

**Update Signature Verification**:
```python
#!/usr/bin/env python3
"""Verify update signatures"""

import subprocess
import sys
from pathlib import Path

def verify_dmg_signature(dmg_path):
    """Verify DMG signature"""
    result = subprocess.run(
        ['codesign', '--verify', '--verbose', str(dmg_path)],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        return False, result.stderr
    
    return True, "DMG signature valid"

def verify_dmg_notarization(dmg_path):
    """Verify DMG notarization"""
    result = subprocess.run(
        ['xcrun', 'stapler', 'validate', str(dmg_path)],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        return False, result.stderr
    
    return True, "DMG notarization valid"

def verify_update_security(dmg_path):
    """Verify update security"""
    checks = [
        ("DMG Signature", verify_dmg_signature),
        ("DMG Notarization", verify_dmg_notarization),
    ]
    
    errors = []
    for name, check_func in checks:
        success, message = check_func(dmg_path)
        if success:
            print(f"✓ {name}: {message}")
        else:
            print(f"✗ {name}: {message}")
            errors.append(f"{name}: {message}")
    
    return len(errors) == 0, errors

if __name__ == '__main__':
    dmg_path = sys.argv[1] if len(sys.argv) > 1 else 'dist/CuePoint.dmg'
    valid, errors = verify_update_security(dmg_path)
    
    if valid:
        print("Update security verification passed")
        sys.exit(0)
    else:
        print("Update security verification failed:")
        for error in errors:
            print(f"  {error}")
        sys.exit(1)
```

## Advanced Update Compatibility Analysis

### Update System Architecture

**Sparkle Integration Architecture**:
- **Update Checker**: Embedded in app bundle
  - **Location**: App bundle or separate framework
  - **Functionality**: Checks appcast for updates
  - **Frequency**: On startup, scheduled, or manual
- **Appcast Feed**: XML feed on GitHub Pages
  - **Location**: `updates/macos/appcast.xml`
  - **Format**: Sparkle appcast XML
  - **Content**: Version, download URL, release notes, signatures
  - **Updates**: Updated on each release
- **Update Download**: Secure download from GitHub Releases
  - **Source**: GitHub Releases assets
  - **Verification**: Signature and notarization verification
  - **Security**: HTTPS, signature validation
- **Update Installation**: Replace app bundle
  - **Method**: Replace existing app in Applications
  - **Preservation**: User data and settings preserved
  - **Verification**: Launch new version, verify functionality

**Update Compatibility Requirements**:
- **Bundle ID Stability**: Must never change
  - **Rationale**: Update system uses bundle ID to identify app
  - **Impact**: Changing bundle ID breaks updates
  - **Enforcement**: Automated validation prevents changes
- **Signing Identity Consistency**: Must be consistent
  - **Rationale**: Update system verifies signing identity
  - **Impact**: Inconsistent identity breaks update trust
  - **Enforcement**: Automated validation ensures consistency
- **Version Progression**: Must always increase
  - **Rationale**: Update system compares versions
  - **Impact**: Version regression breaks updates
  - **Enforcement**: Version validation prevents regression

### Update Testing Matrix

**Comprehensive Test Scenarios**:
- **Scenario 1: Standard Update**
  - Previous: v1.0.0 installed
  - Update: v1.1.0 available
  - Process: Check, download, install
  - Verification: Version updated, data preserved, app works
- **Scenario 2: Skip Version Update**
  - Previous: v1.0.0 installed
  - Update: v1.2.0 available (skipping v1.1.0)
  - Process: Check, download, install
  - Verification: Version updated correctly, data preserved
- **Scenario 3: Major Version Update**
  - Previous: v1.x.x installed
  - Update: v2.0.0 available
  - Process: Check, download, install
  - Verification: Major version updated, compatibility maintained
- **Scenario 4: Update with App Running**
  - Previous: v1.0.0 installed and running
  - Update: v1.1.0 available
  - Process: Check, prompt user, quit app, install
  - Verification: Update completes, app restarts correctly
- **Scenario 5: Update with User Data**
  - Previous: v1.0.0 with user data and settings
  - Update: v1.1.0 available
  - Process: Check, download, install
  - Verification: Data and settings preserved

**Test Environment Matrix**:
- **macOS Versions**: 10.15, 11, 12, 13, 14
- **Architectures**: Intel (x86_64), Apple Silicon (arm64)
- **Update Scenarios**: All test scenarios above
- **Test Frequency**: Every release, automated where possible

### Update Security Deep Dive

**Security Measures**:
- **Signature Verification**: Verify DMG and app signatures
  - **Method**: codesign verification
  - **Timing**: Before installation
  - **Failure**: Reject update if verification fails
- **Notarization Verification**: Verify notarization status
  - **Method**: stapler validation
  - **Timing**: Before installation
  - **Failure**: Reject update if not notarized
- **Source Validation**: Verify update source
  - **Method**: URL and certificate validation
  - **Timing**: Before download
  - **Failure**: Reject update if source invalid
- **Integrity Checks**: Verify file integrity
  - **Method**: Checksum verification
  - **Timing**: After download
  - **Failure**: Reject update if checksum mismatch

**Security Implementation**:
```python
#!/usr/bin/env python3
"""Comprehensive update security verification"""

import hashlib
import subprocess
import sys
from pathlib import Path

def verify_dmg_security(dmg_path):
    """Comprehensive DMG security verification"""
    checks = []
    
    # Check signature
    result = subprocess.run(
        ['codesign', '--verify', '--verbose', str(dmg_path)],
        capture_output=True,
        text=True
    )
    checks.append(("Signature", result.returncode == 0, result.stderr))
    
    # Check notarization
    result = subprocess.run(
        ['xcrun', 'stapler', 'validate', str(dmg_path)],
        capture_output=True,
        text=True
    )
    checks.append(("Notarization", result.returncode == 0, result.stderr))
    
    # Check Gatekeeper
    result = subprocess.run(
        ['spctl', '-a', '-vv', str(dmg_path)],
        capture_output=True,
        text=True
    )
    checks.append(("Gatekeeper", result.returncode == 0, result.stderr))
    
    return checks

def verify_app_security(app_path):
    """Comprehensive app security verification"""
    checks = []
    
    # Check signature
    result = subprocess.run(
        ['codesign', '--verify', '--deep', '--strict', str(app_path)],
        capture_output=True,
        text=True
    )
    checks.append(("Signature", result.returncode == 0, result.stderr))
    
    # Check signing identity
    result = subprocess.run(
        ['codesign', '-dvv', str(app_path)],
        capture_output=True,
        text=True
    )
    identity_valid = 'Developer ID Application' in result.stdout
    checks.append(("Identity", identity_valid, "Invalid signing identity"))
    
    return checks

if __name__ == '__main__':
    # Verify DMG
    dmg_path = sys.argv[1] if len(sys.argv) > 1 else 'dist/CuePoint.dmg'
    dmg_checks = verify_dmg_security(dmg_path)
    
    print("DMG Security Verification:")
    for name, passed, error in dmg_checks:
        status = "✓" if passed else "✗"
        print(f"  {status} {name}: {'OK' if passed else error}")
    
    # Verify app (if extracted)
    app_path = sys.argv[2] if len(sys.argv) > 2 else None
    if app_path:
        app_checks = verify_app_security(app_path)
        print("\nApp Security Verification:")
        for name, passed, error in app_checks:
            status = "✓" if passed else "✗"
            print(f"  {status} {name}: {'OK' if passed else error}")
    
    all_passed = all(passed for _, passed, _ in dmg_checks)
    if app_path:
        all_passed = all_passed and all(passed for _, passed, _ in app_checks)
    
    if all_passed:
        print("\n✓ All security checks passed")
        sys.exit(0)
    else:
        print("\n✗ Some security checks failed")
        sys.exit(1)
```

## References

- Main document: `../03_macOS_Packaging_Signing_Notarization.md`
- Related: Step 3.3 (Bundle Identity), Step 5 (Auto-Update)
- Sparkle Documentation: https://sparkle-project.org/documentation/
- Apple Code Signing: https://developer.apple.com/documentation/security/code_signing_services
- Update System Security: https://sparkle-project.org/documentation/security/
