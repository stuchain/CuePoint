# Implementation Step 9.4: Onboarding

## Implementation Overview
**What We're Building**: A comprehensive onboarding system that guides new users through their first experience with CuePoint, explains key concepts (Collection XML, processing modes, results), provides contextual help, and implements thoughtful empty states throughout the application. The onboarding system reduces the learning curve, prevents user confusion, and ensures users understand how to use CuePoint effectively from their first launch. This includes a first-run welcome flow, empty state designs for all major views, contextual tooltips and help, and progressive disclosure of features to avoid overwhelming new users while still providing power user features.

## Implementation Tasks

### Task 9.4.1: Design and Implement First-Run Onboarding Flow

**What to Build**
- First-run detection and tracking
- Welcome screen and introduction
- Feature explanation screens
- Onboarding state persistence
- Skip and "don't show again" functionality
- Onboarding completion tracking

**Implementation Details**

**9.4.1.1 First-Run Detection System**
- **Purpose**: Detect when CuePoint is launched for the first time and trigger the onboarding flow, while respecting user preferences to skip or not show again.
- **Rationale**:
  - First-run detection enables personalized onboarding
  - User preferences prevent annoying repeated prompts
  - Onboarding should only show when needed
  - Respecting user choices builds trust
  - Onboarding state must persist across sessions
- **Implementation Location**: `SRC/cuepoint/services/onboarding_service.py` (new), `SRC/cuepoint/ui/dialogs/onboarding_dialog.py` (new)
- **First-Run Detection**:
  ```python
  from pathlib import Path
  from PySide6.QtCore import QSettings
  from typing import Optional
  
  class OnboardingService:
      """Manages onboarding state and first-run detection."""
      
      def __init__(self):
          self.settings = QSettings()
          self.settings.beginGroup("Onboarding")
      
      def is_first_run(self) -> bool:
          """Check if this is the first run of the application."""
          return not self.settings.value("first_run_complete", False, type=bool)
      
      def mark_first_run_complete(self):
          """Mark first run as complete."""
          self.settings.setValue("first_run_complete", True)
      
      def should_show_onboarding(self) -> bool:
          """Check if onboarding should be shown."""
          if not self.is_first_run():
              return False
          
          # Check if user has dismissed onboarding
          if self.settings.value("onboarding_dismissed", False, type=bool):
              return False
          
          return True
      
      def dismiss_onboarding(self, dont_show_again: bool = False):
          """Dismiss onboarding, optionally never show again."""
          if dont_show_again:
              self.settings.setValue("onboarding_dismissed", True)
          self.mark_first_run_complete()
      
      def reset_onboarding(self):
          """Reset onboarding state (for testing or user preference)."""
          self.settings.setValue("first_run_complete", False)
          self.settings.setValue("onboarding_dismissed", False)
      
      def get_onboarding_version(self) -> Optional[str]:
          """Get version of onboarding that was shown."""
          return self.settings.value("onboarding_version", None, type=str)
      
      def set_onboarding_version(self, version: str):
          """Set version of onboarding that was shown."""
          self.settings.setValue("onboarding_version", version)
  ```
- **First-Run Integration**:
  ```python
  # In main_window.py or application entry point
  from cuepoint.services.onboarding_service import OnboardingService
  
  onboarding_service = OnboardingService()
  
  if onboarding_service.should_show_onboarding():
      # Show onboarding dialog
      from cuepoint.ui.dialogs.onboarding_dialog import OnboardingDialog
      dialog = OnboardingDialog()
      result = dialog.exec()
      
      if result == QDialog.Accepted:
          onboarding_service.mark_first_run_complete()
      else:
          # User dismissed, check if "don't show again" was checked
          if dialog.dont_show_again():
              onboarding_service.dismiss_onboarding(dont_show_again=True)
  ```
- **Benefits**:
  - Automatic first-run detection
  - User preference respect
  - Persistent state
  - Configurable behavior

**9.4.1.2 Welcome Screen Design**
- **Purpose**: Create an engaging welcome screen that introduces CuePoint, sets expectations, and guides users to the next step.
- **Design Principles**:
  - **Clear Value Proposition**: Explain what CuePoint does clearly
  - **Visual Appeal**: Use appropriate visuals (screenshots, icons)
  - **Concise**: Keep text brief and scannable
  - **Action-Oriented**: Guide users to next step
  - **Professional**: Match application's visual style
- **Welcome Screen Content**:
  ```
  Screen 1: Welcome to CuePoint
  - Title: "Welcome to CuePoint"
  - Subtitle: "Beatport Metadata Enricher"
  - Description: "CuePoint helps you enrich your Rekordbox collection with 
    Beatport metadata, making it easy to find and add missing track information."
  - Visual: Application icon or screenshot
  - Button: "Get Started" (primary)
  - Checkbox: "Don't show this again" (optional, at bottom)
  ```
- **Welcome Screen Implementation**:
  ```python
  from PySide6.QtWidgets import (
      QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton, QCheckBox
  )
  from PySide6.QtCore import Qt
  from PySide6.QtGui import QPixmap, QFont
  
  class WelcomeScreen(QWidget):
      """Welcome screen for onboarding."""
      
      def __init__(self, parent=None):
          super().__init__(parent)
          self._setup_ui()
      
      def _setup_ui(self):
          layout = QVBoxLayout()
          layout.setSpacing(20)
          layout.setContentsMargins(40, 40, 40, 40)
          
          # Title
          title = QLabel("Welcome to CuePoint")
          title_font = QFont()
          title_font.setPointSize(24)
          title_font.setBold(True)
          title.setFont(title_font)
          title.setAlignment(Qt.AlignCenter)
          layout.addWidget(title)
          
          # Subtitle
          subtitle = QLabel("Beatport Metadata Enricher")
          subtitle_font = QFont()
          subtitle_font.setPointSize(14)
          subtitle.setFont(subtitle_font)
          subtitle.setAlignment(Qt.AlignCenter)
          subtitle.setStyleSheet("color: {text_secondary};")
          layout.addWidget(subtitle)
          
          # Description
          description = QLabel(
              "CuePoint helps you enrich your Rekordbox collection with "
              "Beatport metadata, making it easy to find and add missing "
              "track information."
          )
          description.setWordWrap(True)
          description.setAlignment(Qt.AlignCenter)
          description.setStyleSheet("color: {text_primary}; padding: 20px;")
          layout.addWidget(description)
          
          # Visual (icon or screenshot)
          # TODO: Add application icon or screenshot
          
          # Spacer
          layout.addStretch()
          
          # Button
          button_layout = QHBoxLayout()
          button_layout.addStretch()
          
          get_started = QPushButton("Get Started")
          get_started.setDefault(True)
          get_started.clicked.connect(self.accepted)
          button_layout.addWidget(get_started)
          
          button_layout.addStretch()
          layout.addLayout(button_layout)
          
          self.setLayout(layout)
      
      def accepted(self):
          """Emit accepted signal."""
          # Signal will be handled by parent dialog
          pass
  ```
- **Benefits**:
  - Professional first impression
  - Clear value proposition
  - User guidance
  - Brand consistency

**9.4.1.3 Feature Explanation Screens**
- **Purpose**: Explain key CuePoint concepts and features in a step-by-step manner, helping users understand how to use the application.
- **Screen Sequence**:
  1. **Welcome Screen**: Introduction to CuePoint
  2. **Collection XML Screen**: Explain what Collection XML is and how to get it
  3. **Processing Mode Screen**: Explain Single vs Batch processing
  4. **Results Screen**: Explain results view and export functionality
  5. **Completion Screen**: Summary and next steps
- **Collection XML Explanation Screen**:
  ```
  Screen 2: Select Collection XML
  - Title: "Select Your Collection XML File"
  - Description: "CuePoint reads your Rekordbox collection XML file to find "
    "tracks that need metadata. Export your collection from Rekordbox to get "
    "started."
  - Instructions:
    1. Open Rekordbox
    2. Go to File → Export Collection
    3. Save the XML file
    4. Select it in CuePoint
  - Visual: Screenshot or diagram showing Rekordbox export
  - Link: "View detailed instructions" (opens help dialog)
  - Button: "Next" (primary), "Skip" (secondary)
  ```
- **Processing Mode Explanation Screen**:
  ```
  Screen 3: Choose Processing Mode
  - Title: "Choose Your Processing Mode"
  - Description: "CuePoint offers two processing modes:"
  - Single Mode:
    - Title: "Single Playlist"
    - Description: "Process one playlist at a time. Perfect for targeted updates."
    - Visual: Icon or illustration
  - Batch Mode:
    - Title: "Batch Processing"
    - Description: "Process multiple playlists automatically. Great for large collections."
    - Visual: Icon or illustration
  - Button: "Next" (primary), "Back" (secondary), "Skip" (secondary)
  ```
- **Results Explanation Screen**:
  ```
  Screen 4: Results & Export
  - Title: "View Results and Export"
  - Description: "After processing, you'll see results with metadata matches. "
    "Review, filter, and export your results."
  - Features:
    - Search and filter results
    - View candidate matches
    - Export to CSV or JSON
  - Visual: Screenshot of results view
  - Button: "Get Started" (primary), "Back" (secondary)
  ```
- **Onboarding Dialog Implementation**:
  ```python
  from PySide6.QtWidgets import (
      QDialog, QVBoxLayout, QHBoxLayout, QPushButton, QCheckBox, QStackedWidget
  )
  
  class OnboardingDialog(QDialog):
      """Multi-screen onboarding dialog."""
      
      def __init__(self, parent=None):
          super().__init__(parent)
          self.current_screen = 0
          self.dont_show_again = False
          self._setup_ui()
      
      def _setup_ui(self):
          layout = QVBoxLayout()
          
          # Stacked widget for screens
          self.screens = QStackedWidget()
          self.screens.addWidget(WelcomeScreen())
          self.screens.addWidget(CollectionXMLScreen())
          self.screens.addWidget(ProcessingModeScreen())
          self.screens.addWidget(ResultsScreen())
          layout.addWidget(self.screens)
          
          # Navigation buttons
          button_layout = QHBoxLayout()
          
          # Back button (hidden on first screen)
          self.back_button = QPushButton("Back")
          self.back_button.clicked.connect(self.previous_screen)
          self.back_button.setVisible(False)
          button_layout.addWidget(self.back_button)
          
          button_layout.addStretch()
          
          # Skip button (visible on all screens except last)
          self.skip_button = QPushButton("Skip")
          self.skip_button.clicked.connect(self.skip_onboarding)
          button_layout.addWidget(self.skip_button)
          
          # Next/Get Started button
          self.next_button = QPushButton("Next")
          self.next_button.setDefault(True)
          self.next_button.clicked.connect(self.next_screen)
          button_layout.addWidget(self.next_button)
          
          layout.addLayout(button_layout)
          
          # Don't show again checkbox (bottom)
          self.dont_show_checkbox = QCheckBox("Don't show this again")
          layout.addWidget(self.dont_show_checkbox)
          
          self.setLayout(layout)
          self.setWindowTitle("Welcome to CuePoint")
          self.resize(600, 500)
      
      def next_screen(self):
          """Move to next screen."""
          if self.current_screen < self.screens.count() - 1:
              self.current_screen += 1
              self.screens.setCurrentIndex(self.current_screen)
              self._update_buttons()
          else:
              # Last screen, complete onboarding
              self.accept()
      
      def previous_screen(self):
          """Move to previous screen."""
          if self.current_screen > 0:
              self.current_screen -= 1
              self.screens.setCurrentIndex(self.current_screen)
              self._update_buttons()
      
      def skip_onboarding(self):
          """Skip remaining screens."""
          self.dont_show_again = self.dont_show_checkbox.isChecked()
          self.reject()
      
      def _update_buttons(self):
          """Update button visibility based on current screen."""
          is_first = self.current_screen == 0
          is_last = self.current_screen == self.screens.count() - 1
          
          self.back_button.setVisible(not is_first)
          self.skip_button.setVisible(not is_last)
          
          if is_last:
              self.next_button.setText("Get Started")
          else:
              self.next_button.setText("Next")
      
      def dont_show_again_checked(self) -> bool:
          """Check if 'don't show again' is checked."""
          return self.dont_show_checkbox.isChecked()
  ```
- **Benefits**:
  - Step-by-step guidance
  - Feature education
  - Reduced learning curve
  - Professional onboarding experience

### Task 9.4.2: Design and Implement Empty States

**What to Build**
- Empty state designs for all major views
- Empty state messaging and guidance
- Empty state visuals and illustrations
- Empty state actions and next steps
- Empty state consistency across application

**Implementation Details**

**9.4.2.1 Empty State Design Principles**
- **Purpose**: Create thoughtful empty states that guide users when no data is available, explain what should be there, and provide clear next steps.
- **Design Principles**:
  - **Clear Communication**: Explain why the state is empty
  - **Helpful Guidance**: Tell users what to do next
  - **Visual Appeal**: Use appropriate icons or illustrations
  - **Action-Oriented**: Provide clear actions to resolve empty state
  - **Consistent Design**: Maintain visual consistency across empty states
- **Empty State Components**:
  - **Icon/Illustration**: Visual representation of the empty state
  - **Title**: Brief title explaining the state
  - **Description**: Detailed explanation and guidance
  - **Action Button**: Primary action to resolve empty state
  - **Secondary Actions**: Optional additional actions or links
- **Empty State Locations**:
  1. **No XML File Selected**: Main window when no file is selected
  2. **No Playlist Selected**: When file is selected but no playlist chosen
  3. **No Results**: Results view when processing hasn't run or no results found
  4. **No Search History**: History view when no past searches exist
  5. **No Filters Applied**: When filters clear all results
  6. **Empty Export**: When export has no data

**9.4.2.2 No XML File Selected Empty State**
- **Purpose**: Guide users to select their Collection XML file when none is selected.
- **Design**:
  ```
  Empty State: No XML File Selected
  - Icon: File/document icon
  - Title: "No Collection XML File Selected"
  - Description: "Select your Rekordbox collection XML file to get started. "
    "Export your collection from Rekordbox, then browse to select it here."
  - Primary Action: "Browse for XML File" (opens file dialog)
  - Secondary Action: "View Instructions" (opens help dialog)
  - Visual: File icon or illustration
  ```
- **Implementation**:
  ```python
  from PySide6.QtWidgets import (
      QWidget, QVBoxLayout, QLabel, QPushButton
  )
  from PySide6.QtCore import Qt
  from PySide6.QtGui import QPixmap, QIcon
  
  class NoFileSelectedEmptyState(QWidget):
      """Empty state when no XML file is selected."""
      
      def __init__(self, parent=None):
          super().__init__(parent)
          self._setup_ui()
      
      def _setup_ui(self):
          layout = QVBoxLayout()
          layout.setSpacing(16)
          layout.setContentsMargins(40, 40, 40, 40)
          layout.setAlignment(Qt.AlignCenter)
          
          # Icon
          icon_label = QLabel()
          icon_pixmap = QPixmap(":/icons/file_icon.png")  # Or use QIcon
          icon_label.setPixmap(icon_pixmap.scaled(64, 64, Qt.KeepAspectRatio))
          icon_label.setAlignment(Qt.AlignCenter)
          layout.addWidget(icon_label)
          
          # Title
          title = QLabel("No Collection XML File Selected")
          title_font = title.font()
          title_font.setPointSize(16)
          title_font.setBold(True)
          title.setFont(title_font)
          title.setAlignment(Qt.AlignCenter)
          layout.addWidget(title)
          
          # Description
          description = QLabel(
              "Select your Rekordbox collection XML file to get started. "
              "Export your collection from Rekordbox, then browse to select it here."
          )
          description.setWordWrap(True)
          description.setAlignment(Qt.AlignCenter)
          description.setStyleSheet("color: {text_secondary};")
          layout.addWidget(description)
          
          # Action button
          button_layout = QHBoxLayout()
          button_layout.addStretch()
          
          browse_button = QPushButton("Browse for XML File")
          browse_button.setDefault(True)
          browse_button.clicked.connect(self.browse_clicked)
          button_layout.addWidget(browse_button)
          
          instructions_button = QPushButton("View Instructions")
          instructions_button.clicked.connect(self.instructions_clicked)
          button_layout.addWidget(instructions_button)
          
          button_layout.addStretch()
          layout.addLayout(button_layout)
          
          layout.addStretch()
          self.setLayout(layout)
      
      def browse_clicked(self):
          """Emit signal to browse for file."""
          # Signal handled by parent
          pass
      
      def instructions_clicked(self):
          """Emit signal to show instructions."""
          # Signal handled by parent
          pass
  ```
- **Benefits**:
  - Clear guidance
  - Action-oriented
  - Reduces confusion
  - Professional appearance

**9.4.2.3 No Playlist Selected Empty State**
- **Purpose**: Guide users to select a playlist when a file is selected but no playlist is chosen.
- **Design**:
  ```
  Empty State: No Playlist Selected
  - Icon: Playlist/music icon
  - Title: "No Playlist Selected"
  - Description: "Select a playlist from the dropdown above to begin processing. "
    "You can process a single playlist or use batch mode to process multiple."
  - Primary Action: "Select Playlist" (focuses playlist dropdown)
  - Visual: Playlist icon
  ```
- **Implementation**: Similar structure to NoFileSelectedEmptyState
- **Benefits**:
  - Clear next step
  - Contextual guidance
  - Reduced confusion

**9.4.2.4 No Results Empty State**
- **Purpose**: Explain why results view is empty and what users can do.
- **Design**:
  ```
  Empty State: No Results
  - Icon: Search/magnifying glass icon
  - Title: "No Results Yet"
  - Description: "Start processing to see results here. After processing, you'll "
    "see tracks with their Beatport metadata matches."
  - Primary Action: "Start Processing" (if ready) or "Select Playlist" (if not ready)
  - Visual: Search icon
  ```
- **Variations**:
  - **No Results After Processing**: "No matches found. Try adjusting your search or processing different playlists."
  - **Processing Not Started**: "Start processing to see results here."
  - **Filters Applied**: "No results match your current filters. Clear filters to see all results."
- **Implementation**: Similar structure with conditional messaging
- **Benefits**:
  - Context-aware messaging
  - Clear guidance
  - Action-oriented

**9.4.2.5 Empty State Widget System**
- **Purpose**: Create a reusable empty state widget system for consistency.
- **Implementation**:
  ```python
  class EmptyStateWidget(QWidget):
      """Reusable empty state widget."""
      
      def __init__(
          self,
          icon: Optional[QPixmap] = None,
          title: str = "",
          description: str = "",
          primary_action: Optional[str] = None,
          secondary_actions: Optional[List[Tuple[str, Callable]]] = None,
          parent=None
      ):
          super().__init__(parent)
          self.icon = icon
          self.title = title
          self.description = description
          self.primary_action = primary_action
          self.secondary_actions = secondary_actions or []
          self._setup_ui()
      
      def _setup_ui(self):
          layout = QVBoxLayout()
          layout.setSpacing(16)
          layout.setContentsMargins(40, 40, 40, 40)
          layout.setAlignment(Qt.AlignCenter)
          
          # Icon
          if self.icon:
              icon_label = QLabel()
              icon_label.setPixmap(self.icon.scaled(64, 64, Qt.KeepAspectRatio))
              icon_label.setAlignment(Qt.AlignCenter)
              layout.addWidget(icon_label)
          
          # Title
          if self.title:
              title_label = QLabel(self.title)
              title_font = title_label.font()
              title_font.setPointSize(16)
              title_font.setBold(True)
              title_label.setFont(title_font)
              title_label.setAlignment(Qt.AlignCenter)
              layout.addWidget(title_label)
          
          # Description
          if self.description:
              desc_label = QLabel(self.description)
              desc_label.setWordWrap(True)
              desc_label.setAlignment(Qt.AlignCenter)
              desc_label.setStyleSheet("color: {text_secondary};")
              layout.addWidget(desc_label)
          
          # Actions
          if self.primary_action or self.secondary_actions:
              button_layout = QHBoxLayout()
              button_layout.addStretch()
              
              if self.primary_action:
                  primary_btn = QPushButton(self.primary_action)
                  primary_btn.setDefault(True)
                  button_layout.addWidget(primary_btn)
              
              for action_text, action_callback in self.secondary_actions:
                  btn = QPushButton(action_text)
                  btn.clicked.connect(action_callback)
                  button_layout.addWidget(btn)
              
              button_layout.addStretch()
              layout.addLayout(button_layout)
          
          layout.addStretch()
          self.setLayout(layout)
  ```
- **Usage**:
  ```python
  empty_state = EmptyStateWidget(
      icon=file_icon,
      title="No Collection XML File Selected",
      description="Select your Rekordbox collection XML file to get started.",
      primary_action="Browse for XML File",
      secondary_actions=[
          ("View Instructions", show_instructions),
      ]
  )
  ```
- **Benefits**:
  - Consistent empty states
  - Reusable components
  - Easy to maintain
  - Professional appearance

### Task 9.4.3: Implement Contextual Help and Tooltips

**What to Build**
- Contextual help system
- Tooltip implementation
- Help text for all controls
- Help dialog integration
- Contextual help triggers

**Implementation Details**

**9.4.3.1 Tooltip System**
- **Purpose**: Provide helpful tooltips for all interactive elements, explaining their purpose and usage.
- **Implementation**: Use Qt's built-in tooltip system with enhanced content
- **Tooltip Guidelines**:
  - **Concise**: Keep tooltips brief (1-2 sentences)
  - **Helpful**: Explain purpose and usage
  - **Contextual**: Provide relevant information
  - **Keyboard Shortcuts**: Include keyboard shortcuts in tooltips
  - **Consistent**: Use consistent tooltip style
- **Tooltip Implementation**:
  ```python
  from PySide6.QtWidgets import QWidget
  from cuepoint.utils.i18n import tr
  
  # Set tooltips for widgets
  file_input.setToolTip(
      tr("tooltip.file_input",
         "Path to your Rekordbox collection XML file. "
         "Export your collection from Rekordbox to get this file.")
  )
  
  start_button.setToolTip(
      tr("tooltip.start_button",
         "Start processing the selected playlist to find Beatport metadata. "
         "Shortcut: Enter")
  )
  
  export_button.setToolTip(
      tr("tooltip.export_button",
         "Export results to CSV or JSON format. "
         "Shortcut: Ctrl+E")
  )
  ```
- **Benefits**:
  - Inline help
  - Reduced learning curve
  - Better discoverability
  - Professional polish

**9.4.3.2 Contextual Help Dialog**
- **Purpose**: Provide detailed help for specific features or concepts when users need more information.
- **Implementation**:
  ```python
  class ContextualHelpDialog(QDialog):
      """Dialog for contextual help."""
      
      def __init__(self, topic: str, parent=None):
          super().__init__(parent)
          self.topic = topic
          self._setup_ui()
      
      def _setup_ui(self):
          layout = QVBoxLayout()
          
          # Title
          title = QLabel(f"Help: {self.topic}")
          title_font = title.font()
          title_font.setPointSize(18)
          title_font.setBold(True)
          title.setFont(title_font)
          layout.addWidget(title)
          
          # Content (loaded based on topic)
          content = self._get_help_content(self.topic)
          content_label = QLabel(content)
          content_label.setWordWrap(True)
          layout.addWidget(content_label)
          
          # Close button
          button_layout = QHBoxLayout()
          button_layout.addStretch()
          close_button = QPushButton("Close")
          close_button.clicked.connect(self.accept)
          button_layout.addWidget(close_button)
          layout.addLayout(button_layout)
          
          self.setLayout(layout)
          self.setWindowTitle("Help")
          self.resize(500, 400)
      
      def _get_help_content(self, topic: str) -> str:
          """Get help content for topic."""
          help_content = {
              "collection_xml": """
              Collection XML File
              
              CuePoint reads your Rekordbox collection XML file to find tracks
              that need metadata enrichment.
              
              To export your collection:
              1. Open Rekordbox
              2. Go to File → Export Collection
              3. Save the XML file
              4. Select it in CuePoint
              """,
              "processing_modes": """
              Processing Modes
              
              Single Playlist: Process one playlist at a time. Perfect for
              targeted updates and reviewing results.
              
              Batch Processing: Process multiple playlists automatically. Great
              for large collections and bulk updates.
              """,
              # ... more help topics
          }
          return help_content.get(topic, "Help content not available.")
  ```
- **Benefits**:
  - Detailed help when needed
  - Contextual information
  - Reduced support burden
  - Better user experience

## Success Criteria

### Onboarding Goals
- ✅ First-run onboarding implemented
- ✅ All empty states designed and implemented
- ✅ Contextual help available
- ✅ Tooltips for all controls
- ✅ Onboarding state persists
- ✅ User preferences respected
- ✅ Onboarding tested and validated

### Validation Methods
- First-run testing
- Empty state testing
- Help system testing
- User testing
- Onboarding flow validation

## Implementation Files

### Onboarding Infrastructure
1. `SRC/cuepoint/services/onboarding_service.py` - Onboarding state management (new)
2. `SRC/cuepoint/ui/dialogs/onboarding_dialog.py` - Onboarding dialog (new)
3. `SRC/cuepoint/ui/widgets/empty_states.py` - Empty state widgets (new)
4. `SRC/cuepoint/ui/widgets/contextual_help.py` - Contextual help (new)

### Onboarding Screens
1. `SRC/cuepoint/ui/widgets/onboarding/welcome_screen.py` - Welcome screen (new)
2. `SRC/cuepoint/ui/widgets/onboarding/collection_xml_screen.py` - Collection XML screen (new)
3. `SRC/cuepoint/ui/widgets/onboarding/processing_mode_screen.py` - Processing mode screen (new)
4. `SRC/cuepoint/ui/widgets/onboarding/results_screen.py` - Results screen (new)

## Dependencies

### Prerequisites
- Step 9.1: Visual Consistency (for empty state styling)
- Step 9.3: Localization Readiness (for translatable strings)
- Basic UI components implemented

### Enables
- Better first-run experience
- Reduced learning curve
- Improved user guidance
- Professional onboarding
- Reduced support burden

## References

- Empty State Design: https://www.nngroup.com/articles/empty-state-ux-design/
- Onboarding Best Practices: https://www.nngroup.com/articles/onboarding-ux/
- Progressive Disclosure: https://www.nngroup.com/articles/progressive-disclosure/
