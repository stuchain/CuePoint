# Implementation Step 2.7: Secrets and Certificate Handling

## Implementation Overview
**What We're Building**: A comprehensive secrets and certificate management system that securely stores, retrieves, and uses signing certificates and API keys for code signing and notarization on both macOS and Windows platforms. This includes secret storage, certificate import, keychain management, and secure secret rotation procedures.

## Implementation Tasks

### Task 2.7.1: Define Secret Inventory

**What to Build**
- Complete list of required secrets
- Secret naming conventions
- Secret format requirements
- Secret access scoping

**Implementation Details**

**2.7.1.1 macOS Secrets**
- **APPLE_TEAM_ID**
  - **Type**: String
  - **Format**: 10-character alphanumeric (e.g., `ABC123DEF4`)
  - **Source**: Apple Developer account
  - **Location**: Apple Developer → Membership
  - **Usage**: Notarization, code signing
  - **Sensitivity**: Low (publicly visible in signed apps)
  - **Storage**: GitHub Secrets

- **APPLE_NOTARYTOOL_ISSUER_ID**
  - **Type**: String
  - **Format**: UUID (e.g., `12345678-1234-1234-1234-123456789abc`)
  - **Source**: App Store Connect API key
  - **Location**: App Store Connect → Users and Access → Keys
  - **Usage**: Notarization authentication
  - **Sensitivity**: High (API access)
  - **Storage**: GitHub Secrets

- **APPLE_NOTARYTOOL_KEY_ID**
  - **Type**: String
  - **Format**: 10-character alphanumeric (e.g., `ABC123DEF4`)
  - **Source**: App Store Connect API key
  - **Location**: App Store Connect → Users and Access → Keys
  - **Usage**: Notarization authentication
  - **Sensitivity**: High (API access)
  - **Storage**: GitHub Secrets

- **APPLE_NOTARYTOOL_KEY**
  - **Type**: String (PEM format)
  - **Format**: Private key in PEM format
  - **Source**: App Store Connect API key download
  - **Location**: Downloaded `.p8` file
  - **Usage**: Notarization authentication
  - **Sensitivity**: Critical (private key)
  - **Storage**: GitHub Secrets (base64 encoded)

- **MACOS_SIGNING_CERT_P12**
  - **Type**: Binary (base64 encoded)
  - **Format**: PKCS#12 certificate (.p12)
  - **Source**: Apple Developer certificate export
  - **Location**: Keychain Access → Export
  - **Usage**: Code signing
  - **Sensitivity**: Critical (signing certificate)
  - **Storage**: GitHub Secrets (base64 encoded)

- **MACOS_SIGNING_CERT_PASSWORD**
  - **Type**: String
  - **Format**: Password used when exporting .p12
  - **Source**: User-defined during export
  - **Location**: User memory/secure storage
  - **Usage**: Certificate import
  - **Sensitivity**: Critical (certificate password)
  - **Storage**: GitHub Secrets

**2.7.1.2 Windows Secrets**
- **WINDOWS_CERT_PFX**
  - **Type**: Binary (base64 encoded)
  - **Format**: PKCS#12 certificate (.pfx)
  - **Source**: Code signing certificate purchase/export
  - **Location**: Certificate store export
  - **Usage**: Code signing
  - **Sensitivity**: Critical (signing certificate)
  - **Storage**: GitHub Secrets (base64 encoded)
  - **Note**: Prefer EV (Extended Validation) certificate for production

- **WINDOWS_CERT_PASSWORD**
  - **Type**: String
  - **Format**: Password used when exporting .pfx
  - **Source**: User-defined during export
  - **Location**: User memory/secure storage
  - **Usage**: Certificate import
  - **Sensitivity**: Critical (certificate password)
  - **Storage**: GitHub Secrets

**2.7.1.3 GitHub Secrets**
- **GITHUB_TOKEN**
  - **Type**: String (token)
  - **Format**: GitHub Personal Access Token or GITHUB_TOKEN
  - **Source**: GitHub → Settings → Developer settings → Personal access tokens
  - **Location**: Auto-provided in workflows or manually created
  - **Usage**: Release creation, artifact upload, Pages deployment
  - **Sensitivity**: High (repository access)
  - **Storage**: Auto-provided or GitHub Secrets
  - **Scopes**: `repo`, `write:packages`, `pages:write`

**2.7.1.4 Secret Naming Convention**
- **Format**: `{PLATFORM}_{PURPOSE}_{TYPE}`
- **Examples**:
  - `MACOS_SIGNING_CERT_P12`
  - `WINDOWS_CERT_PFX`
  - `APPLE_NOTARYTOOL_KEY`
- **Rules**:
  - UPPERCASE
  - Underscore separators
  - Platform prefix (MACOS, WINDOWS, APPLE)
  - Purpose (SIGNING, NOTARYTOOL, CERT)
  - Type suffix (P12, PFX, PASSWORD, KEY, ID)

### Task 2.7.2: Implement Secret Storage

**What to Build**
- GitHub Secrets configuration
- Secret encoding procedures
- Secret validation
- Secret documentation

**Implementation Details**

**2.7.2.1 GitHub Secrets Setup**
- **Location**: Repository → Settings → Secrets and variables → Actions
- **Access**: Repository admin required
- **Limits**: 
  - 100 secrets per repository
  - 64KB per secret value
  - No secret names > 255 characters
- **Visibility**: Only admins can view/edit secrets
- **Usage**: Secrets are masked in logs (never printed)

**2.7.2.2 Secret Encoding**
- **Binary Certificates**: Base64 encode before storing
  ```bash
  # macOS certificate
  base64 -i certificate.p12 -o certificate.p12.b64
  
  # Windows certificate
  base64 -i certificate.pfx -o certificate.pfx.b64
  ```
- **Text Secrets**: Store as-is (no encoding needed)
- **Private Keys**: Store as-is (PEM format) or base64 if binary

**2.7.2.3 Secret Upload Process**
1. **Encode binary secrets** (if needed)
2. **Navigate to**: Repository → Settings → Secrets
3. **Click**: "New repository secret"
4. **Enter**: Name and value
5. **Save**: Secret is encrypted and stored
6. **Verify**: Secret appears in list (name only, value hidden)

**2.7.2.4 Secret Validation Script**
- **File to Create**: `scripts/validate_secrets.py`
- **Purpose**: Validate secrets are set (without exposing values)
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Validate required secrets are set"""
  import os
  import sys
  
  REQUIRED_SECRETS = {
      'macos': [
          'APPLE_TEAM_ID',
          'APPLE_NOTARYTOOL_ISSUER_ID',
          'APPLE_NOTARYTOOL_KEY_ID',
          'APPLE_NOTARYTOOL_KEY',
          'MACOS_SIGNING_CERT_P12',
          'MACOS_SIGNING_CERT_PASSWORD',
      ],
      'windows': [
          'WINDOWS_CERT_PFX',
          'WINDOWS_CERT_PASSWORD',
      ],
      'common': [
          'GITHUB_TOKEN',
      ],
  }
  
  def validate_secrets(platform):
      """Validate secrets for platform"""
      missing = []
      secrets = REQUIRED_SECRETS.get(platform, []) + REQUIRED_SECRETS['common']
      
      for secret in secrets:
          if not os.environ.get(secret):
              missing.append(secret)
      
      if missing:
          print(f"ERROR: Missing secrets for {platform}:")
          for secret in missing:
              print(f"  - {secret}")
          return False
      
      print(f"✓ All required secrets for {platform} are set")
      return True
  
  if __name__ == '__main__':
      platform = sys.argv[1] if len(sys.argv) > 1 else 'macos'
      if not validate_secrets(platform):
          sys.exit(1)
  ```

### Task 2.7.3: Implement Certificate Import (macOS)

**What to Build**
- Certificate import script
- Keychain management
- Certificate validation
- Error handling

**Implementation Details**

**2.7.3.1 Certificate Import Script**
- **File to Create**: `scripts/import_macos_cert.sh`
- **Purpose**: Import signing certificate in CI
- **Implementation**:
  ```bash
  #!/bin/bash
  # Import macOS signing certificate
  
  set -e
  
  CERT_P12="${MACOS_SIGNING_CERT_P12}"
  CERT_PASSWORD="${MACOS_SIGNING_CERT_PASSWORD}"
  KEYCHAIN="build.keychain"
  KEYCHAIN_PASSWORD=""
  
  if [ -z "$CERT_P12" ] || [ -z "$CERT_PASSWORD" ]; then
      echo "ERROR: Certificate or password not set"
      exit 1
  fi
  
  echo "Creating keychain..."
  security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN"
  security default-keychain -s "$KEYCHAIN"
  security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN"
  security set-keychain-settings -t 3600 -u "$KEYCHAIN"
  
  echo "Importing certificate..."
  echo "$CERT_P12" | base64 --decode > cert.p12
  security import cert.p12 -k "$KEYCHAIN" -P "$CERT_PASSWORD" -T /usr/bin/codesign
  security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN"
  
  echo "Cleaning up..."
  rm -f cert.p12
  
  echo "Certificate imported successfully"
  ```
- **Usage**: Called in CI workflow before signing
- **Error Handling**: Fails fast on errors, cleans up on failure

**2.7.3.2 Keychain Management**
- **Temporary Keychain**: Create `build.keychain` for CI
- **Keychain Password**: Empty (temporary keychain)
- **Keychain Settings**: 
  - Timeout: 3600 seconds (1 hour)
  - Lock on sleep: Disabled
- **Cleanup**: Delete keychain after build (if possible)

**2.7.3.3 Certificate Validation**
- **Check Certificate**: Verify certificate imported correctly
  ```bash
  security find-identity -v -p codesigning "$KEYCHAIN"
  ```
- **Verify Identity**: Check certificate identity matches expected
- **Check Expiry**: Verify certificate not expired
  ```bash
  security find-certificate -c "Developer ID Application: Your Name" -p "$KEYCHAIN" | openssl x509 -noout -dates
  ```

**2.7.3.4 Error Handling**
- **Missing Secret**: Fail with clear error message
- **Invalid Certificate**: Fail with certificate error
- **Import Failure**: Fail with import error
- **Cleanup**: Always clean up certificate file, even on failure

### Task 2.7.4: Implement Certificate Import (Windows)

**What to Build**
- Certificate import script (PowerShell)
- Certificate validation
- Error handling

**Implementation Details**

**2.7.4.1 Certificate Import Script**
- **File to Create**: `scripts/import_windows_cert.ps1`
- **Purpose**: Import signing certificate in CI
- **Implementation**:
  ```powershell
  # Import Windows signing certificate
  
  param(
      [Parameter(Mandatory=$true)]
      [string]$CertBase64,
      
      [Parameter(Mandatory=$true)]
      [string]$CertPassword,
      
      [Parameter(Mandatory=$false)]
      [string]$CertPath = "cert.pfx"
  )
  
  Write-Host "Decoding certificate..."
  try {
      $certBytes = [System.Convert]::FromBase64String($CertBase64)
      [System.IO.File]::WriteAllBytes($CertPath, $certBytes)
      Write-Host "Certificate saved to: $CertPath"
  } catch {
      Write-Error "Failed to decode certificate: $_"
      exit 1
  }
  
  Write-Host "Validating certificate..."
  try {
      $cert = New-Object System.Security.Cryptography.X509Certificates.X509Certificate2($CertPath, $CertPassword)
      Write-Host "Certificate validated: $($cert.Subject)"
      Write-Host "Certificate expires: $($cert.NotAfter)"
      
      if ($cert.NotAfter -lt (Get-Date)) {
          Write-Error "Certificate has expired"
          exit 1
      }
  } catch {
      Write-Error "Failed to validate certificate: $_"
      exit 1
  }
  
  Write-Host "Certificate imported successfully"
  ```
- **Usage**: Called in CI workflow before signing
- **Error Handling**: Validates certificate, checks expiry

**2.7.4.2 Certificate Validation**
- **Decode Check**: Verify base64 decode succeeds
- **Password Check**: Verify password is correct
- **Expiry Check**: Verify certificate not expired
- **Format Check**: Verify certificate is valid PFX

**2.7.4.3 Error Handling**
- **Missing Secret**: Fail with clear error
- **Invalid Base64**: Fail with decode error
- **Wrong Password**: Fail with password error
- **Expired Certificate**: Fail with expiry error
- **Cleanup**: Always clean up certificate file

### Task 2.7.5: Implement Notarization Credentials

**What to Build**
- Notarization credential configuration
- API key setup
- Credential storage
- Credential validation

**Implementation Details**

**2.7.5.1 Notarization Credential Setup**
- **Tool**: `xcrun notarytool`
- **Method**: Store credentials in keychain profile
- **Profile Name**: `notarytool-profile`
- **Credentials**:
  - Apple ID (Issuer ID)
  - Team ID
  - Key ID
  - Private Key

**2.7.5.2 Credential Storage**
- **Location**: macOS keychain (temporary)
- **Profile**: Named profile for reuse
- **Lifetime**: Valid for build session
- **Cleanup**: Profile removed after build

**2.7.5.3 Credential Configuration Script**
- **Implementation**:
  ```bash
  # Configure notarytool credentials
  xcrun notarytool store-credentials \
    --apple-id "$APPLE_NOTARYTOOL_ISSUER_ID" \
    --team-id "$APPLE_TEAM_ID" \
    --key-id "$APPLE_NOTARYTOOL_KEY_ID" \
    --key "$APPLE_NOTARYTOOL_KEY" \
    notarytool-profile
  ```
- **Validation**: Test credentials with dry-run
  ```bash
  xcrun notarytool history --keychain-profile notarytool-profile
  ```

**2.7.5.4 API Key Generation**
- **Location**: App Store Connect → Users and Access → Keys
- **Steps**:
  1. Log in to App Store Connect
  2. Navigate to Users and Access
  3. Click Keys tab
  4. Click "+" to create new key
  5. Select "App Manager" or "Admin" role
  6. Download key (.p8 file)
  7. Save Issuer ID and Key ID
  8. Store private key securely

### Task 2.7.6: Implement Secret Rotation

**What to Build**
- Secret rotation procedures
- Rotation schedule
- Rotation validation
- Rollback procedures

**Implementation Details**

**2.7.6.1 Rotation Schedule**
- **Certificates**: Before expiry (30 days before)
- **API Keys**: Every 90 days (recommended)
- **Passwords**: Every 180 days (if changed)
- **Emergency**: Immediately if compromised

**2.7.6.2 Rotation Process**
1. **Generate New Secret**: Create new certificate/key
2. **Test New Secret**: Verify works in test environment
3. **Update Secret**: Update in GitHub Secrets
4. **Verify Build**: Run test build with new secret
5. **Archive Old Secret**: Keep old secret for rollback (30 days)
6. **Delete Old Secret**: Remove after verification period

**2.7.6.3 Rotation Validation**
- **Test Build**: Run full build with new secret
- **Verify Signing**: Check signatures are valid
- **Verify Notarization**: Check notarization succeeds
- **Verify Artifacts**: Check artifacts are correct

**2.7.6.4 Rollback Procedures**
- **Keep Old Secret**: Archive for 30 days
- **Quick Rollback**: Revert to old secret if issues
- **Documentation**: Document rollback steps
- **Notification**: Notify team of rotation

### Task 2.7.7: Implement Secret Security

**What to Build**
- Secret access controls
- Secret audit logging
- Secret encryption
- Secret backup

**Implementation Details**

**2.7.7.1 Access Controls**
- **GitHub Secrets**: Only repository admins can view/edit
- **CI Access**: Secrets only available in workflows
- **Log Masking**: Secrets automatically masked in logs
- **No Exposure**: Never print secrets in scripts

**2.7.7.2 Audit Logging**
- **GitHub Audit**: GitHub logs secret access
- **CI Logs**: Monitor CI logs for secret usage
- **Access Review**: Regular review of secret access
- **Alerting**: Alert on unusual access patterns

**2.7.7.3 Secret Encryption**
- **GitHub**: Secrets encrypted at rest
- **Transit**: HTTPS for all secret transmission
- **Storage**: No secrets in code or config files
- **Backup**: Encrypted backups if needed

**2.7.7.4 Secret Backup**
- **Primary**: GitHub Secrets (primary storage)
- **Backup**: Encrypted backup in secure location
- **Recovery**: Document recovery procedures
- **Testing**: Test recovery procedures regularly

## Implementation Checklist

### Secret Inventory
- [ ] Document all required secrets
- [ ] Define secret naming convention
- [ ] Document secret formats
- [ ] Create secret inventory document

### Secret Storage
- [ ] Set up GitHub Secrets
- [ ] Encode binary secrets (base64)
- [ ] Upload all secrets
- [ ] Validate secrets are set
- [ ] Document secret setup process

### Certificate Import (macOS)
- [ ] Create certificate import script
- [ ] Test certificate import
- [ ] Validate certificate
- [ ] Test in CI workflow
- [ ] Document import process

### Certificate Import (Windows)
- [ ] Create certificate import script
- [ ] Test certificate import
- [ ] Validate certificate
- [ ] Test in CI workflow
- [ ] Document import process

### Notarization Credentials
- [ ] Generate API key
- [ ] Configure notarytool
- [ ] Test notarization
- [ ] Document credential setup

### Secret Rotation
- [ ] Define rotation schedule
- [ ] Create rotation procedures
- [ ] Test rotation process
- [ ] Document rotation steps

### Security
- [ ] Review access controls
- [ ] Set up audit logging
- [ ] Test secret security
- [ ] Document security procedures

## Files to Create/Modify

### New Files
1. `scripts/import_macos_cert.sh` - macOS certificate import
2. `scripts/import_windows_cert.ps1` - Windows certificate import
3. `scripts/validate_secrets.py` - Secret validation
4. `scripts/rotate_secrets.py` - Secret rotation helper
5. `DOCS/POLICY/Secrets_Management.md` - Secrets policy document

### Files to Modify
1. `.github/workflows/build-macos.yml` - Use certificate import
2. `.github/workflows/build-windows.yml` - Use certificate import
3. `scripts/sign_macos.sh` - Use imported certificate
4. `scripts/sign_windows.ps1` - Use imported certificate

## Implementation Dependencies

### Prerequisites
- Step 2.1: Goals and Principles (defines security requirements)
- Step 2.2: Tooling Choices (uses signing tools)
- Step 2.5: CI Structure (uses secrets in workflows)
- Apple Developer account (for macOS)
- Code signing certificate (for Windows)

### Enables
- Step 3: macOS Packaging (uses certificates)
- Step 4: Windows Packaging (uses certificates)
- Step 2.8: Release Gating (validates signing)

## Success Criteria

### Secret Management
- ✅ All secrets stored securely
- ✅ Secrets are accessible in CI
- ✅ Secrets are never exposed in logs
- ✅ Secret rotation works

### Certificate Import
- ✅ Certificates import successfully
- ✅ Certificates are validated
- ✅ Signing works with imported certificates
- ✅ Error handling works

### Notarization
- ✅ Notarization credentials configured
- ✅ Notarization succeeds
- ✅ Credentials are secure

### Security
- ✅ Access controls enforced
- ✅ Audit logging active
- ✅ Secrets encrypted
- ✅ No secrets in code

## Next Implementation Steps

After completing Step 2.7:
1. **Step 2.8**: Release Gating (validates signing)
2. **Step 3**: macOS Packaging (uses certificates)
3. **Step 4**: Windows Packaging (uses certificates)

## Detailed Implementation Guidance

### Certificate Export Procedures

#### macOS Certificate Export
1. **Open Keychain Access**
2. **Select**: "My Certificates"
3. **Find**: "Developer ID Application: Your Name"
4. **Right-click**: Export
5. **Format**: Personal Information Exchange (.p12)
6. **Set Password**: Choose strong password
7. **Save**: Export to secure location
8. **Encode**: Base64 encode for GitHub Secrets
   ```bash
   base64 -i certificate.p12 -o certificate.p12.b64
   ```

#### Windows Certificate Export
1. **Open Certificate Manager** (certmgr.msc)
2. **Navigate**: Personal → Certificates
3. **Find**: Code signing certificate
4. **Right-click**: All Tasks → Export
5. **Format**: PKCS #12 (.pfx)
6. **Set Password**: Choose strong password
7. **Save**: Export to secure location
8. **Encode**: Base64 encode for GitHub Secrets
   ```powershell
   [Convert]::ToBase64String([IO.File]::ReadAllBytes("certificate.pfx"))
   ```

### Secret Validation in CI

#### Pre-Build Validation
```yaml
- name: Validate secrets
  run: |
    python scripts/validate_secrets.py macos
  env:
    APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
    APPLE_NOTARYTOOL_ISSUER_ID: ${{ secrets.APPLE_NOTARYTOOL_ISSUER_ID }}
    # ... other secrets
```

#### Secret Existence Check
```bash
# Check secret exists (without exposing value)
if [ -z "$MACOS_SIGNING_CERT_P12" ]; then
    echo "ERROR: MACOS_SIGNING_CERT_P12 not set"
    exit 1
fi
```

### Certificate Expiry Monitoring

#### Expiry Check Script
```python
# scripts/check_cert_expiry.py
from datetime import datetime
import subprocess

def check_cert_expiry(cert_path, password):
    """Check certificate expiry"""
    # Extract expiry date from certificate
    # Compare with current date
    # Alert if expiring soon (< 30 days)
    pass
```

#### Automated Alerts
- **30 days before**: Warning alert
- **7 days before**: Critical alert
- **Expired**: Block builds

### Secret Backup Strategy

#### Backup Locations
1. **Primary**: GitHub Secrets
2. **Backup**: Encrypted file in secure storage
3. **Recovery**: Document recovery procedures

#### Backup Format
- **Encrypted**: Use GPG or similar
- **Compressed**: Reduce size
- **Versioned**: Track backup versions
- **Tested**: Test recovery regularly

## References

- Main document: `../02_Build_System_and_Release_Pipeline.md`
- Related: Step 2.5 (CI Structure), Step 3-4 (Packaging)
- Apple Developer: https://developer.apple.com/
- GitHub Secrets: https://docs.github.com/en/actions/security-guides/encrypted-secrets
- Code Signing: https://developer.apple.com/documentation/security
