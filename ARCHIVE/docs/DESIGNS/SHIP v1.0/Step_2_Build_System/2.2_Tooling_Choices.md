# Implementation Step 2.2: Tooling Choices

## Implementation Overview
**What We're Building**: Complete tooling infrastructure for the build system, including PyInstaller configuration, GitHub Actions setup, signing tools, installer tools, and all supporting scripts. This step establishes the technical foundation for all build and release operations.

## Implementation Tasks

### Task 2.2.1: PyInstaller Setup and Configuration

**What to Build**
- PyInstaller specification file
- Platform-specific build configurations
- Dependency bundling configuration
- Icon and resource inclusion
- Hidden imports configuration
- Binary exclusions

**Implementation Details**

**2.2.1.1 PyInstaller Specification File**
- **File to Create**: `build/pyinstaller.spec`
- **Purpose**: Central configuration for PyInstaller builds
- **Structure**: Separate configurations for macOS and Windows
- **Implementation**:
  ```python
  # -*- mode: python ; coding: utf-8 -*-
  """
  PyInstaller specification file for CuePoint
  Supports both macOS and Windows builds
  """
  
  import sys
  import os
  from pathlib import Path
  
  # Add SRC to path for imports
  sys.path.insert(0, str(Path('SRC').resolve()))
  
  # Import version
  from cuepoint.version import __version__, __build_number__
  
  # Platform detection
  is_macos = sys.platform == 'darwin'
  is_windows = sys.platform == 'win32'
  
  # Application name
  app_name = 'CuePoint'
  
  # Data files to include
  datas = [
      ('config/logging.yaml', 'config'),
      ('SRC/cuepoint', 'cuepoint'),  # Include source for imports
  ]
  
  # Hidden imports (modules PyInstaller can't auto-detect)
  hiddenimports = [
      'PySide6.QtCore',
      'PySide6.QtGui',
      'PySide6.QtWidgets',
      'requests',
      'requests_cache',
      'beautifulsoup4',
      'rapidfuzz',
      'dateutil',
      'yaml',
      'openpyxl',
      'playwright',
      'selenium',
      'aiohttp',
      'ddgs',
  ]
  
  # Binaries to exclude (reduce size)
  excludes = [
      'matplotlib',
      'numpy',
      'pandas',
      'scipy',
      'PIL',
      'tkinter',
  ]
  
  # Analysis phase
  a = Analysis(
      ['SRC/gui_app.py'],  # Main entry point
      pathex=['SRC'],
      binaries=[],
      datas=datas,
      hiddenimports=hiddenimports,
      hookspath=[],
      hooksconfig={},
      runtime_hooks=[],
      excludes=excludes,
      win_no_prefer_redirects=False,
      win_private_assemblies=False,
      cipher=None,
      noarchive=False,
  )
  
  # Remove duplicates
  pyz = PYZ(a.pure, a.zipped_data, cipher=None)
  
  # Executable configuration
  if is_macos:
      exe = EXE(
          pyz,
          a.scripts,
          a.binaries,
          a.zipfiles,
          a.datas,
          [],
          name=app_name,
          debug=False,
          bootloader_ignore_signals=False,
          strip=False,
          upx=True,
          upx_exclude=[],
          runtime_tmpdir=None,
          console=False,  # No console window
          icon='build/icon.icns' if os.path.exists('build/icon.icns') else None,
      )
      
      # macOS app bundle
      app = BUNDLE(
          exe,
          name=f'{app_name}.app',
          icon='build/icon.icns' if os.path.exists('build/icon.icns') else None,
          bundle_identifier='com.cuepoint.app',
          info_plist={
              'CFBundleName': app_name,
              'CFBundleDisplayName': app_name,
              'CFBundleVersion': __build_number__ or '1',
              'CFBundleShortVersionString': __version__,
              'CFBundlePackageType': 'APPL',
              'CFBundleExecutable': app_name,
              'CFBundleIdentifier': 'com.cuepoint.app',
              'LSMinimumSystemVersion': '10.15',
              'NSHighResolutionCapable': True,
              'NSHumanReadableCopyright': 'Copyright © 2024 CuePoint',
          },
      )
  else:
      # Windows executable
      exe = EXE(
          pyz,
          a.scripts,
          a.binaries,
          a.zipfiles,
          a.datas,
          [],
          name=f'{app_name}.exe',
          debug=False,
          bootloader_ignore_signals=False,
          strip=False,
          upx=True,
          upx_exclude=[],
          runtime_tmpdir=None,
          console=False,  # No console window
          icon='build/icon.ico' if os.path.exists('build/icon.ico') else None,
          version='build/version_info.txt' if os.path.exists('build/version_info.txt') else None,
      )
  ```
- **Integration**: Called by build scripts and CI workflows
- **Dependencies**: PyInstaller installed, version.py exists
- **Platform Differences**: macOS creates .app bundle, Windows creates .exe

**2.2.1.2 Build Script for PyInstaller**
- **File to Create**: `scripts/build_pyinstaller.py`
- **Purpose**: Wrapper script to build with PyInstaller
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Build script for PyInstaller"""
  import sys
  import subprocess
  from pathlib import Path
  
  def build():
      """Build application with PyInstaller"""
      spec_file = Path('build/pyinstaller.spec')
      if not spec_file.exists():
          print(f"Error: Spec file not found: {spec_file}")
          sys.exit(1)
      
      # Run PyInstaller
      cmd = ['pyinstaller', '--clean', '--noconfirm', str(spec_file)]
      result = subprocess.run(cmd, check=False)
      
      if result.returncode != 0:
          print("Error: PyInstaller build failed")
          sys.exit(1)
      
      print("Build completed successfully")
  
  if __name__ == '__main__':
      build()
  ```
- **Usage**: `python scripts/build_pyinstaller.py`
- **Integration**: Called by CI workflows

**2.2.1.3 Icon and Resource Files**
- **Files to Create**:
  - `build/icon.icns` - macOS icon (required)
  - `build/icon.ico` - Windows icon (required)
  - `build/icon.png` - Source icon (for conversion)
- **Purpose**: Application icons for both platforms
- **Requirements**:
  - macOS: .icns format, multiple sizes
  - Windows: .ico format, multiple sizes
  - Source: High-resolution PNG (1024x1024 recommended)
- **Tools**: Use `iconutil` (macOS) or online converters

**2.2.1.4 Version Info File (Windows)**
- **File to Create**: `build/version_info.txt` (template)
- **File to Generate**: `build/version_info.txt` (at build time)
- **Purpose**: Windows executable version metadata
- **Template**:
  ```
  VSVersionInfo(
    ffi=FixedFileInfo(
      filevers=(1, 0, 0, 0),
      prodvers=(1, 0, 0, 0),
      mask=0x3f,
      flags=0x0,
      OS=0x40004,
      fileType=0x1,
      subtype=0x0,
      date=(0, 0)
    ),
    kids=[
      StringFileInfo([
        StringTable('040904B0', [
          StringStruct('CompanyName', 'CuePoint'),
          StringStruct('FileDescription', 'CuePoint - Rekordbox Metadata Enricher'),
          StringStruct('FileVersion', '{{VERSION}}'),
          StringStruct('InternalName', 'CuePoint'),
          StringStruct('LegalCopyright', 'Copyright © 2024 CuePoint'),
          StringStruct('OriginalFilename', 'CuePoint.exe'),
          StringStruct('ProductName', 'CuePoint'),
          StringStruct('ProductVersion', '{{VERSION}}')
        ])
      ]),
      VarFileInfo([VarStruct('Translation', [1033, 1200])])
    ]
  )
  ```
- **Generation**: Script replaces `{{VERSION}}` with actual version

### Task 2.2.2: GitHub Actions Configuration

**What to Build**
- GitHub Actions workflow files
- Reusable workflow components
- Matrix build configurations
- Secret management setup
- Artifact handling

**Implementation Details**

**2.2.2.1 Main CI Workflow**
- **File to Create**: `.github/workflows/ci.yml`
- **Purpose**: Main CI workflow for tests and validation
- **Implementation**:
  ```yaml
  name: CI
  
  on:
    push:
      branches: [main, 'phase_*']
    pull_request:
      branches: [main]
  
  jobs:
    test:
      strategy:
        matrix:
          os: [macos-latest, windows-latest]
          python-version: ['3.11']
      runs-on: ${{ matrix.os }}
      
      steps:
        - name: Checkout code
          uses: actions/checkout@v4
          
        - name: Set up Python
          uses: actions/setup-python@v5
          with:
            python-version: ${{ matrix.python-version }}
            cache: 'pip'
          
        - name: Install dependencies
          run: |
            python -m pip install --upgrade pip
            pip install -r requirements.txt
            pip install -r requirements-dev.txt
          
        - name: Run linter
          run: |
            pylint SRC/ --disable=all --enable=errors
            mypy SRC/ --ignore-missing-imports
          
        - name: Run tests
          run: |
            pytest SRC/tests/ -v --cov=SRC --cov-report=xml --cov-report=term
          
        - name: Upload coverage
          uses: codecov/codecov-action@v3
          with:
            files: ./coverage.xml
            fail_ci_if_error: false
          
        - name: Check for large files
          run: |
            python scripts/check_large_files.py
  ```
- **Integration**: Runs on all pushes and PRs
- **Dependencies**: Python, dependencies installed

**2.2.2.2 Build Workflow (macOS)**
- **File to Create**: `.github/workflows/build-macos.yml`
- **Purpose**: Build and package macOS application
- **Implementation**: See Step 2.5 for full implementation
- **Key Components**:
  - Python setup
  - Dependency installation
  - PyInstaller build
  - Code signing
  - Notarization
  - DMG creation
  - Artifact upload

**2.2.2.3 Build Workflow (Windows)**
- **File to Create**: `.github/workflows/build-windows.yml`
- **Purpose**: Build and package Windows application
- **Implementation**: See Step 2.5 for full implementation
- **Key Components**:
  - Python setup
  - Dependency installation
  - PyInstaller build
  - Code signing
  - NSIS installer
  - Artifact upload

**2.2.2.4 Release Workflow**
- **File to Create**: `.github/workflows/release.yml`
- **Purpose**: Publish releases
- **Implementation**: See Step 2.5 for full implementation
- **Key Components**:
  - Download artifacts
  - Generate appcast
  - Create GitHub Release
  - Publish update feeds

**2.2.2.5 Reusable Workflow Components**
- **File to Create**: `.github/workflows/reusable/setup-python.yml`
- **Purpose**: Reusable Python setup
- **Implementation**:
  ```yaml
  name: Setup Python
  
  on:
    workflow_call:
      inputs:
        python-version:
          required: true
          type: string
  
  jobs:
    setup:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/setup-python@v5
          with:
            python-version: ${{ inputs.python-version }}
  ```

### Task 2.2.3: macOS Signing Tools Setup

**What to Build**
- Code signing scripts
- Notarization scripts
- Certificate import scripts
- Signing validation scripts

**Implementation Details**

**2.2.3.1 Code Signing Script**
- **File to Create**: `scripts/sign_macos.sh`
- **Purpose**: Sign macOS application
- **Implementation**:
  ```bash
  #!/bin/bash
  # Sign macOS application
  
  set -e
  
  APP_PATH="$1"
  IDENTITY="${APPLE_DEVELOPER_ID:-Developer ID Application: Your Name (TEAM_ID)}"
  
  if [ -z "$APP_PATH" ]; then
      echo "Usage: $0 <path-to-app>"
      exit 1
  fi
  
  echo "Signing application: $APP_PATH"
  
  # Sign all nested binaries
  find "$APP_PATH" -type f -perm +111 -exec codesign --force --sign "$IDENTITY" --options runtime {} \;
  
  # Sign frameworks
  find "$APP_PATH" -name "*.framework" -exec codesign --force --sign "$IDENTITY" --options runtime {} \;
  
  # Sign the app bundle
  codesign --force --deep --sign "$IDENTITY" --options runtime --timestamp "$APP_PATH"
  
  # Verify signing
  codesign --verify --verbose "$APP_PATH"
  spctl --assess --verbose "$APP_PATH"
  
  echo "Signing complete"
  ```
- **Usage**: `bash scripts/sign_macos.sh dist/CuePoint.app`
- **Requirements**: Apple Developer certificate in keychain

**2.2.3.2 Notarization Script**
- **File to Create**: `scripts/notarize_macos.sh`
- **Purpose**: Notarize macOS application/DMG
- **Implementation**:
  ```bash
  #!/bin/bash
  # Notarize macOS application or DMG
  
  set -e
  
  FILE_PATH="$1"
  APPLE_ID="${APPLE_NOTARYTOOL_ISSUER_ID}"
  TEAM_ID="${APPLE_TEAM_ID}"
  KEY_ID="${APPLE_NOTARYTOOL_KEY_ID}"
  KEY="${APPLE_NOTARYTOOL_KEY}"
  PROFILE="notarytool-profile"
  
  if [ -z "$FILE_PATH" ]; then
      echo "Usage: $0 <path-to-file>"
      exit 1
  fi
  
  echo "Notarizing: $FILE_PATH"
  
  # Configure notarytool
  xcrun notarytool store-credentials \
      --apple-id "$APPLE_ID" \
      --team-id "$TEAM_ID" \
      --key-id "$KEY_ID" \
      --key "$KEY" \
      "$PROFILE"
  
  # Submit for notarization
  xcrun notarytool submit "$FILE_PATH" \
      --keychain-profile "$PROFILE" \
      --wait
  
  # Staple (for DMG)
  if [[ "$FILE_PATH" == *.dmg ]]; then
      xcrun stapler staple "$FILE_PATH"
      xcrun stapler validate "$FILE_PATH"
  fi
  
  echo "Notarization complete"
  ```
- **Usage**: `bash scripts/notarize_macos.sh dist/CuePoint.dmg`
- **Requirements**: App Store Connect API key

**2.2.3.3 Certificate Import Script**
- **File to Create**: `scripts/import_macos_cert.sh`
- **Purpose**: Import signing certificate in CI
- **Implementation**:
  ```bash
  #!/bin/bash
  # Import macOS signing certificate
  
  set -e
  
  CERT_P12="${MACOS_SIGNING_CERT_P12}"
  CERT_PASSWORD="${MACOS_SIGNING_CERT_PASSWORD}"
  KEYCHAIN="build.keychain"
  KEYCHAIN_PASSWORD=""
  
  if [ -z "$CERT_P12" ] || [ -z "$CERT_PASSWORD" ]; then
      echo "Error: Certificate or password not set"
      exit 1
  fi
  
  # Create keychain
  security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN"
  security default-keychain -s "$KEYCHAIN"
  security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN"
  security set-keychain-settings -t 3600 -u "$KEYCHAIN"
  
  # Import certificate
  echo "$CERT_P12" | base64 --decode > cert.p12
  security import cert.p12 -k "$KEYCHAIN" -P "$CERT_PASSWORD" -T /usr/bin/codesign
  security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN"
  
  # Clean up
  rm -f cert.p12
  
  echo "Certificate imported"
  ```
- **Usage**: Called automatically in CI workflow
- **Requirements**: Base64-encoded certificate in secret

### Task 2.2.4: Windows Signing Tools Setup

**What to Build**
- Code signing scripts (PowerShell)
- Certificate import scripts
- Signing validation scripts

**Implementation Details**

**2.2.4.1 Code Signing Script (PowerShell)**
- **File to Create**: `scripts/sign_windows.ps1`
- **Purpose**: Sign Windows executable/installer
- **Implementation**:
  ```powershell
  # Sign Windows executable or installer
  
  param(
      [Parameter(Mandatory=$true)]
      [string]$FilePath,
      
      [Parameter(Mandatory=$true)]
      [string]$CertPath,
      
      [Parameter(Mandatory=$true)]
      [string]$CertPassword
  )
  
  if (-not (Test-Path $FilePath)) {
      Write-Error "File not found: $FilePath"
      exit 1
  }
  
  Write-Host "Signing: $FilePath"
  
  # Sign with signtool
  signtool sign /f $CertPath /p $CertPassword /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 "$FilePath"
  
  if ($LASTEXITCODE -ne 0) {
      Write-Error "Signing failed"
      exit 1
  }
  
  # Verify signing
  signtool verify /pa /v "$FilePath"
  
  if ($LASTEXITCODE -ne 0) {
      Write-Error "Verification failed"
      exit 1
  }
  
  Write-Host "Signing complete"
  ```
- **Usage**: `powershell -File scripts/sign_windows.ps1 -FilePath dist/CuePoint.exe -CertPath cert.pfx -CertPassword $password`
- **Requirements**: Code signing certificate

**2.2.4.2 Certificate Import Script**
- **File to Create**: `scripts/import_windows_cert.ps1`
- **Purpose**: Import signing certificate in CI
- **Implementation**:
  ```powershell
  # Import Windows signing certificate
  
  param(
      [Parameter(Mandatory=$true)]
      [string]$CertBase64,
      
      [Parameter(Mandatory=$true)]
      [string]$CertPassword,
      
      [Parameter(Mandatory=$false)]
      [string]$CertPath = "cert.pfx"
  )
  
  # Decode and save certificate
  [System.Convert]::FromBase64String($CertBase64) | Set-Content -Path $CertPath -Encoding Byte
  
  Write-Host "Certificate imported to: $CertPath"
  ```
- **Usage**: Called automatically in CI workflow

### Task 2.2.5: Installer Tools Setup

**What to Build**
- DMG creation script (macOS)
- NSIS installer script (Windows)
- Installer configuration files

**Implementation Details**

**2.2.5.1 DMG Creation Script**
- **File to Create**: `scripts/create_dmg.sh`
- **Purpose**: Create macOS DMG installer
- **Implementation**:
  ```bash
  #!/bin/bash
  # Create macOS DMG
  
  set -e
  
  APP_PATH="dist/CuePoint.app"
  DMG_NAME="CuePoint-v${VERSION:-1.0.0}-macos-universal.dmg"
  DMG_PATH="dist/$DMG_NAME"
  VOLUME_NAME="CuePoint"
  
  if [ ! -d "$APP_PATH" ]; then
      echo "Error: App not found: $APP_PATH"
      exit 1
  fi
  
  echo "Creating DMG: $DMG_PATH"
  
  # Create temporary directory
  TEMP_DIR=$(mktemp -d)
  cp -R "$APP_PATH" "$TEMP_DIR/"
  
  # Create DMG
  hdiutil create -volname "$VOLUME_NAME" -srcfolder "$TEMP_DIR" -ov -format UDZO "$DMG_PATH"
  
  # Clean up
  rm -rf "$TEMP_DIR"
  
  echo "DMG created: $DMG_PATH"
  ```
- **Usage**: `bash scripts/create_dmg.sh`
- **Requirements**: hdiutil (macOS), app must be signed

**2.2.5.2 NSIS Installer Script**
- **File to Create**: `scripts/installer.nsi`
- **Purpose**: NSIS installer configuration
- **Implementation**: See existing `scripts/installer.nsi` or create comprehensive version
- **Key Components**:
  - Installer metadata
  - File installation
  - Start menu shortcuts
  - Uninstaller
  - Version information

### Task 2.2.6: Supporting Scripts and Utilities

**What to Build**
- Build info injection script
- Version validation script
- Artifact validation script
- Large file check script

**Implementation Details**

**2.2.6.1 Build Info Injection Script**
- **File to Create**: `scripts/set_build_info.py` (may already exist)
- **Purpose**: Inject build information into version.py
- **Implementation**: See Step 2.4 for details
- **Key Features**:
  - Read git commit SHA
  - Read CI build number
  - Update version.py with build info
  - Generate build date

**2.2.6.2 Version Validation Script**
- **File to Create**: `scripts/validate_version.py` (may already exist)
- **Purpose**: Validate version consistency
- **Implementation**: See Step 2.4 for details
- **Key Features**:
  - Check version format
  - Validate version in all artifacts
  - Report inconsistencies

**2.2.6.3 Artifact Validation Script**
- **File to Create**: `scripts/validate_artifacts.py` (may already exist)
- **Purpose**: Validate build artifacts
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Validate build artifacts"""
  import sys
  from pathlib import Path
  
  def validate_artifacts():
      """Validate all build artifacts"""
      errors = []
      
      # Check macOS DMG
      dmg = Path('dist/CuePoint-v*.dmg')
      if dmg.exists():
          # Validate DMG
          # Check signing
          # Check notarization
          pass
      
      # Check Windows installer
      exe = Path('dist/CuePoint-v*-setup.exe')
      if exe.exists():
          # Validate installer
          # Check signing
          pass
      
      if errors:
          print("Validation errors:")
          for error in errors:
              print(f"  - {error}")
          sys.exit(1)
      
      print("All artifacts validated successfully")
  
  if __name__ == '__main__':
      validate_artifacts()
  ```

**2.2.6.4 Large File Check Script**
- **File to Create**: `scripts/check_large_files.py`
- **Purpose**: Check for large files in repository
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Check for large files in repository"""
  import os
  import sys
  from pathlib import Path
  
  MAX_SIZE = 50 * 1024 * 1024  # 50MB
  
  def check_large_files():
      """Check for files exceeding size limit"""
      large_files = []
      
      for root, dirs, files in os.walk('.'):
          # Skip .git and .venv
          if '.git' in root or '.venv' in root or 'node_modules' in root:
              continue
          
          for file in files:
              file_path = Path(root) / file
              try:
                  size = file_path.stat().st_size
                  if size > MAX_SIZE:
                      large_files.append((file_path, size))
              except (OSError, PermissionError):
                  continue
      
      if large_files:
          print("Large files detected:")
          for file_path, size in large_files:
              print(f"  {file_path}: {size / (1024*1024):.2f} MB")
          sys.exit(1)
      
      print("No large files detected")
  
  if __name__ == '__main__':
      check_large_files()
  ```

## Implementation Checklist

### PyInstaller Setup
- [ ] Create pyinstaller.spec file
- [ ] Configure macOS app bundle
- [ ] Configure Windows executable
- [ ] Set up hidden imports
- [ ] Configure data files
- [ ] Create build script
- [ ] Test build locally

### GitHub Actions Setup
- [ ] Create CI workflow
- [ ] Create macOS build workflow
- [ ] Create Windows build workflow
- [ ] Create release workflow
- [ ] Configure secrets
- [ ] Test workflows

### macOS Signing
- [ ] Create signing script
- [ ] Create notarization script
- [ ] Create certificate import script
- [ ] Test signing locally
- [ ] Test notarization

### Windows Signing
- [ ] Create signing script (PowerShell)
- [ ] Create certificate import script
- [ ] Test signing locally

### Installer Tools
- [ ] Create DMG creation script
- [ ] Create/update NSIS installer script
- [ ] Test DMG creation
- [ ] Test NSIS installer

### Supporting Scripts
- [ ] Create/update build info script
- [ ] Create/update version validation script
- [ ] Create artifact validation script
- [ ] Create large file check script
- [ ] Test all scripts

## Files to Create/Modify

### New Files
1. `build/pyinstaller.spec` - PyInstaller configuration
2. `scripts/build_pyinstaller.py` - Build wrapper script
3. `scripts/sign_macos.sh` - macOS signing script
4. `scripts/notarize_macos.sh` - macOS notarization script
5. `scripts/import_macos_cert.sh` - Certificate import (macOS)
6. `scripts/sign_windows.ps1` - Windows signing script
7. `scripts/import_windows_cert.ps1` - Certificate import (Windows)
8. `scripts/create_dmg.sh` - DMG creation script
9. `scripts/check_large_files.py` - Large file check script
10. `.github/workflows/ci.yml` - Main CI workflow
11. `.github/workflows/build-macos.yml` - macOS build workflow
12. `.github/workflows/build-windows.yml` - Windows build workflow
13. `.github/workflows/release.yml` - Release workflow

### Files to Modify
1. `scripts/set_build_info.py` - May need updates
2. `scripts/validate_version.py` - May need updates
3. `scripts/validate_artifacts.py` - May need updates
4. `scripts/installer.nsi` - May need updates
5. `scripts/create_dmg.sh` - May need updates

### Resource Files Needed
1. `build/icon.icns` - macOS icon
2. `build/icon.ico` - Windows icon
3. `build/icon.png` - Source icon
4. `build/version_info.txt` - Windows version info template

## Implementation Dependencies

### Prerequisites
- Step 2.1: Goals and Principles (defines requirements)
- Step 1.7: Versioning (defines version system)
- Python 3.11 installed
- PyInstaller installed
- Apple Developer account (for macOS signing)
- Code signing certificate (for Windows signing)

### Enables
- Step 2.3: Repository Hygiene (uses build scripts)
- Step 2.4: Version Management (uses build scripts)
- Step 2.5: CI Structure (uses all tooling)
- Step 3: macOS Packaging (uses signing tools)
- Step 4: Windows Packaging (uses signing tools)

## Success Criteria

### PyInstaller
- ✅ Builds successfully on both platforms
- ✅ All dependencies included
- ✅ Application runs correctly
- ✅ Icons displayed correctly
- ✅ Version information embedded

### GitHub Actions
- ✅ Workflows run successfully
- ✅ Tests pass on both platforms
- ✅ Builds produce artifacts
- ✅ Secrets configured correctly

### Signing
- ✅ macOS app signed and notarized
- ✅ Windows executable signed
- ✅ Signatures verified
- ✅ Notarization successful

### Installers
- ✅ DMG created successfully
- ✅ NSIS installer created successfully
- ✅ Installers work correctly
- ✅ Uninstallers work correctly

## Next Implementation Steps

After completing Step 2.2:
1. **Step 2.3**: Repository Hygiene (uses build scripts)
2. **Step 2.4**: Version Management (uses build scripts)
3. **Step 2.5**: CI Structure (uses all tooling)
4. **Step 3**: macOS Packaging (uses signing tools)
5. **Step 4**: Windows Packaging (uses signing tools)

## Detailed Implementation Guidance

### PyInstaller Configuration Details

#### Hidden Imports
Some Python modules are not automatically detected by PyInstaller. These must be explicitly listed:

```python
hiddenimports = [
    # Qt modules
    'PySide6.QtCore',
    'PySide6.QtGui',
    'PySide6.QtWidgets',
    'PySide6.QtNetwork',
    
    # HTTP and web
    'requests',
    'requests_cache',
    'aiohttp',
    'beautifulsoup4',
    
    # Text processing
    'rapidfuzz',
    'rapidfuzz.fuzz',
    'rapidfuzz.process',
    
    # Date/time
    'dateutil',
    'dateutil.parser',
    
    # Configuration
    'yaml',
    
    # Excel
    'openpyxl',
    
    # Browser automation
    'playwright',
    'selenium',
    
    # Search
    'ddgs',
]
```

#### Data Files
Files that need to be included in the bundle:

```python
datas = [
    # Configuration files
    ('config/logging.yaml', 'config'),
    
    # Source code (for dynamic imports)
    ('SRC/cuepoint', 'cuepoint'),
    
    # Any other data files
]
```

#### Binary Exclusions
Large libraries that aren't needed can be excluded:

```python
excludes = [
    'matplotlib',  # Plotting (not needed)
    'numpy',       # Scientific computing (not needed)
    'pandas',      # Data analysis (not needed)
    'scipy',       # Scientific computing (not needed)
    'PIL',         # Image processing (not needed if not used)
    'tkinter',     # GUI toolkit (using PySide6 instead)
]
```

### GitHub Actions Workflow Details

#### Matrix Builds
Use matrix strategy for testing multiple configurations:

```yaml
strategy:
  matrix:
    os: [macos-latest, windows-latest]
    python-version: ['3.11']
```

#### Caching
Cache dependencies to speed up builds:

```yaml
- uses: actions/setup-python@v5
  with:
    cache: 'pip'
```

#### Artifact Upload
Upload build artifacts:

```yaml
- uses: actions/upload-artifact@v4
  with:
    name: macos-dmg
    path: dist/*.dmg
    retention-days: 30
```

### macOS Signing Details

#### Hardened Runtime
Required for notarization:

```bash
codesign --options runtime
```

#### Entitlements
May need entitlements file:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>com.apple.security.cs.allow-jit</key>
    <true/>
    <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
    <true/>
    <key>com.apple.security.cs.allow-dyld-environment-variables</key>
    <true/>
    <key>com.apple.security.cs.disable-library-validation</key>
    <true/>
</dict>
</plist>
```

Sign with entitlements:
```bash
codesign --entitlements entitlements.plist --options runtime
```

### Windows Signing Details

#### Timestamping
Always use timestamping:

```powershell
signtool sign /tr http://timestamp.digicert.com /td SHA256
```

#### Dual Signing
For maximum compatibility, sign with both SHA1 and SHA256:

```powershell
# SHA1 (legacy)
signtool sign /f cert.pfx /p password /t http://timestamp.digicert.com file.exe

# SHA256 (modern)
signtool sign /f cert.pfx /p password /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 file.exe
```

### Installer Details

#### DMG Best Practices
- Use UDZO format (compressed)
- Set appropriate volume name
- Include Applications folder link
- Set background image (optional)
- Set window size and position

#### NSIS Best Practices
- Include uninstaller
- Set proper registry keys
- Create start menu shortcuts
- Set file associations (if needed)
- Include version information
- Sign the installer

## References

- Main document: `../02_Build_System_and_Release_Pipeline.md`
- PyInstaller documentation: https://pyinstaller.org/
- GitHub Actions documentation: https://docs.github.com/en/actions
- Apple Code Signing: https://developer.apple.com/documentation/security
- Windows Code Signing: https://docs.microsoft.com/en-us/windows/win32/seccrypto/cryptography
