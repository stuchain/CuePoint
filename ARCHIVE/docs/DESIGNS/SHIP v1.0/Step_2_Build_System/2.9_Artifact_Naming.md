# Implementation Step 2.9: Artifact Naming Conventions

## Implementation Overview
**What We're Building**: Comprehensive artifact naming convention system that ensures consistent, descriptive, and parseable artifact names across all releases. This includes detailed naming rules, validation scripts, name generation utilities, and documentation for all artifact types.

## Implementation Tasks

### Task 2.9.1: Define Core Naming Convention

**What to Build**
- Base naming pattern
- Component definitions
- Format specifications
- Examples and edge cases

**Implementation Details**

**2.9.1.1 Base Naming Pattern**
- **Pattern**: `{ProductName}-v{Version}-{Platform}-{Architecture}[-{Variant}].{Extension}`
- **Components**:
  1. **ProductName**: `CuePoint` (fixed, case-sensitive)
  2. **Version**: `X.Y.Z` (SemVer, no 'v' prefix in filename)
  3. **Platform**: `macos` or `windows` (lowercase)
  4. **Architecture**: `universal`, `arm64`, `x64`, `x86` (lowercase)
  5. **Variant**: Optional (e.g., `setup`, `portable`, `debug`)
  6. **Extension**: `.dmg`, `.exe`, `.zip`, `.msi` (lowercase)
- **Separators**: Hyphens (`-`) between components, dot (`.`) before extension
- **Case**: All lowercase except ProductName (PascalCase)

**2.9.1.2 Product Name Component**
- **Value**: `CuePoint`
- **Format**: PascalCase (first letter uppercase, rest camelCase)
- **Fixed**: Never changes
- **Validation**: Must match exactly
- **Rationale**: Brand consistency, easy identification

**2.9.1.3 Version Component**
- **Format**: `X.Y.Z` (SemVer)
- **Source**: From `SRC/cuepoint/version.py`
- **Rules**:
  - No 'v' prefix in filename (unlike git tags)
  - Three components: MAJOR.MINOR.PATCH
  - Each component: 1-3 digits
  - No leading zeros
- **Examples**: `1.0.0`, `1.1.0`, `2.0.0`, `1.0.1`
- **Validation**: Must match SemVer pattern

**2.9.1.4 Platform Component**
- **macOS**: `macos` (lowercase, no hyphen)
- **Windows**: `windows` (lowercase, no hyphen)
- **Future**: `linux` (if needed)
- **Rules**:
  - Always lowercase
  - No spaces or special characters
  - Single word (no hyphens)
- **Validation**: Must be one of allowed values

**2.9.1.5 Architecture Component**
- **macOS Options**:
  - `universal`: Universal binary (Intel + Apple Silicon)
  - `arm64`: Apple Silicon only
  - `x64`: Intel 64-bit only
- **Windows Options**:
  - `x64`: 64-bit (default)
  - `x86`: 32-bit (if needed)
- **Default**: `universal` for macOS, `x64` for Windows
- **Validation**: Must be one of allowed values

**2.9.1.6 Variant Component (Optional)**
- **Purpose**: Distinguish artifact types
- **macOS Variants**:
  - None (default): DMG installer
  - `debug`: Debug build
  - `beta`: Beta release
- **Windows Variants**:
  - `setup`: Installer (default for .exe)
  - `portable`: Portable archive
  - `debug`: Debug build
  - `beta`: Beta release
- **Format**: Lowercase, single word
- **Position**: Before extension, after architecture

**2.9.1.7 Extension Component**
- **macOS Extensions**:
  - `.dmg`: Disk image (installer, default)
  - `.zip`: Archive (alternative)
  - `.pkg`: Package installer (if needed)
- **Windows Extensions**:
  - `.exe`: Executable installer (default)
  - `.msi`: MSI installer (if needed)
  - `.zip`: Portable archive
- **Rules**: Lowercase, standard extensions
- **Validation**: Must match artifact type

### Task 2.9.2: Define Specific Naming Rules

**What to Build**
- macOS naming rules
- Windows naming rules
- Update feed naming
- Checksum file naming
- Release notes naming

**Implementation Details**

**2.9.2.1 macOS Naming Rules**
- **DMG Installer**:
  - Pattern: `CuePoint-vX.Y.Z-macos-universal.dmg`
  - Example: `CuePoint-v1.0.0-macos-universal.dmg`
  - Architecture: `universal` (default) or `arm64`/`x64`
- **ZIP Archive** (alternative):
  - Pattern: `CuePoint-vX.Y.Z-macos-universal.zip`
  - Example: `CuePoint-v1.0.0-macos-universal.zip`
- **PKG Installer** (if needed):
  - Pattern: `CuePoint-vX.Y.Z-macos-universal.pkg`
  - Example: `CuePoint-v1.0.0-macos-universal.pkg`

**2.9.2.2 Windows Naming Rules**
- **EXE Installer**:
  - Pattern: `CuePoint-vX.Y.Z-windows-x64-setup.exe`
  - Example: `CuePoint-v1.0.0-windows-x64-setup.exe`
  - Variant: `setup` (indicates installer)
- **MSI Installer** (if needed):
  - Pattern: `CuePoint-vX.Y.Z-windows-x64.msi`
  - Example: `CuePoint-v1.0.0-windows-x64.msi`
- **Portable ZIP**:
  - Pattern: `CuePoint-vX.Y.Z-windows-x64-portable.zip`
  - Example: `CuePoint-v1.0.0-windows-x64-portable.zip`
  - Variant: `portable` (indicates portable)

**2.9.2.3 Update Feed Naming**
- **macOS Appcast**:
  - Name: `appcast.xml` (fixed)
  - Location: `updates/macos/appcast.xml`
  - Format: Fixed name, not versioned
- **Windows Update Feed**:
  - Name: `appcast.json` (fixed)
  - Location: `updates/windows/appcast.json`
  - Format: Fixed name, not versioned
- **Rationale**: Fixed names allow apps to always check same URL

**2.9.2.4 Checksum File Naming**
- **Pattern**: `CuePoint-vX.Y.Z-checksums.txt`
- **Example**: `CuePoint-v1.0.0-checksums.txt`
- **Location**: GitHub Release assets
- **Content**: SHA256 and MD5 checksums for all artifacts
- **Format**: Standard checksum format

**2.9.2.5 Release Notes Naming**
- **GitHub Release**: Uses release tag as identifier
- **File** (if stored): `RELEASE_NOTES.md` or `docs/releases/vX.Y.Z.md`
- **Format**: Markdown
- **Naming**: Version in content, not filename (for GitHub)

### Task 2.9.3: Implement Name Generation

**What to Build**
- Name generation script
- Name validation script
- Name parsing utilities
- Name documentation

**Implementation Details**

**2.9.3.1 Name Generation Script**
- **File to Create**: `scripts/generate_artifact_name.py`
- **Purpose**: Generate artifact names following convention
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Generate artifact names following naming convention"""
  import sys
  from pathlib import Path
  
  sys.path.insert(0, str(Path('SRC').resolve()))
  from cuepoint.version import __version__
  
  def generate_artifact_name(platform, architecture='universal', variant=None, extension=None):
      """Generate artifact name"""
      product = "CuePoint"
      version = __version__.replace('v', '')  # Remove 'v' prefix
      
      # Determine extension if not provided
      if not extension:
          if platform == 'macos':
              extension = '.dmg'
          elif platform == 'windows':
              if variant == 'portable':
                  extension = '.zip'
              else:
                  extension = '-setup.exe' if variant == 'setup' else '.exe'
      
      # Build name
      name_parts = [product, f"v{version}", platform, architecture]
      
      if variant and variant != 'setup':  # 'setup' is part of extension
          name_parts.append(variant)
      
      name = '-'.join(name_parts) + extension
      return name
  
  if __name__ == '__main__':
      import argparse
      parser = argparse.ArgumentParser()
      parser.add_argument('platform', choices=['macos', 'windows'])
      parser.add_argument('--architecture', default='universal')
      parser.add_argument('--variant')
      parser.add_argument('--extension')
      args = parser.parse_args()
      
      name = generate_artifact_name(
          args.platform,
          args.architecture,
          args.variant,
          args.extension
      )
      print(name)
  ```

**2.9.3.2 Name Validation Script**
- **File to Create**: `scripts/validate_artifact_names.py`
- **Purpose**: Validate artifact names match convention
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Validate artifact names match naming convention"""
  import re
  import sys
  from pathlib import Path
  
  # Naming pattern
  PATTERN = r'^CuePoint-v(\d+\.\d+\.\d+)-(macos|windows)-(universal|arm64|x64|x86)(-(setup|portable|debug|beta))?\.(dmg|exe|zip|msi|pkg)$'
  
  def validate_name(name):
      """Validate artifact name"""
      match = re.match(PATTERN, name)
      if not match:
          return False, "Name does not match pattern"
      
      version = match.group(1)
      platform = match.group(2)
      architecture = match.group(3)
      variant = match.group(5)
      extension = match.group(6)
      
      # Validate platform-architecture combinations
      if platform == 'macos' and architecture == 'x86':
          return False, "macOS does not support x86"
      if platform == 'windows' and architecture == 'arm64':
          return False, "Windows arm64 not supported yet"
      
      # Validate extension-platform combinations
      if platform == 'macos' and extension not in ['dmg', 'zip', 'pkg']:
          return False, f"Invalid extension for macOS: {extension}"
      if platform == 'windows' and extension not in ['exe', 'msi', 'zip']:
          return False, f"Invalid extension for Windows: {extension}"
      
      return True, "Name is valid"
  
  if __name__ == '__main__':
      if len(sys.argv) < 2:
          print("Usage: validate_artifact_names.py <name>")
          sys.exit(1)
      
      name = sys.argv[1]
      valid, message = validate_name(name)
      
      if valid:
          print(f"✓ {name} is valid")
          sys.exit(0)
      else:
          print(f"✗ {name} is invalid: {message}")
          sys.exit(1)
  ```

**2.9.3.3 Name Parsing Utilities**
- **File to Create**: `scripts/parse_artifact_name.py`
- **Purpose**: Parse artifact names to extract components
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Parse artifact names to extract components"""
  import re
  import sys
  
  def parse_artifact_name(name):
      """Parse artifact name into components"""
      pattern = r'^CuePoint-v(\d+\.\d+\.\d+)-(macos|windows)-(universal|arm64|x64|x86)(-(setup|portable|debug|beta))?\.(dmg|exe|zip|msi|pkg)$'
      match = re.match(pattern, name)
      
      if not match:
          return None
      
      return {
          'product': 'CuePoint',
          'version': match.group(1),
          'platform': match.group(2),
          'architecture': match.group(3),
          'variant': match.group(5),
          'extension': match.group(6),
          'full_name': name
      }
  
  if __name__ == '__main__':
      if len(sys.argv) < 2:
          print("Usage: parse_artifact_name.py <name>")
          sys.exit(1)
      
      name = sys.argv[1]
      components = parse_artifact_name(name)
      
      if components:
          print("Artifact components:")
          for key, value in components.items():
              print(f"  {key}: {value}")
      else:
          print(f"Invalid artifact name: {name}")
          sys.exit(1)
  ```

### Task 2.9.4: Implement Naming in Build Scripts

**What to Build**
- Update build scripts to use naming convention
- Update DMG creation script
- Update NSIS installer script
- Update artifact upload scripts

**Implementation Details**

**2.9.4.1 DMG Creation Script Update**
- **File to Modify**: `scripts/create_dmg.sh`
- **Changes**: Use name generation script
- **Implementation**:
  ```bash
  #!/bin/bash
  # Create DMG with proper naming
  
  # Get version
  VERSION=$(python -c "import sys; sys.path.insert(0, 'SRC'); from cuepoint.version import __version__; print(__version__.replace('v', ''))")
  
  # Generate name
  DMG_NAME=$(python scripts/generate_artifact_name.py macos --architecture universal)
  DMG_PATH="dist/$DMG_NAME"
  
  # Create DMG
  hdiutil create -volname "CuePoint" \
    -srcfolder "dist/CuePoint.app" \
    -ov -format UDZO \
    "$DMG_PATH"
  
  echo "Created: $DMG_PATH"
  ```

**2.9.4.2 NSIS Installer Script Update**
- **File to Modify**: `scripts/installer.nsi`
- **Changes**: Use name generation in installer
- **Implementation**: Use version variable in installer script

**2.9.4.3 Artifact Upload Update**
- **File to Modify**: `.github/workflows/release.yml`
- **Changes**: Use generated names for uploads
- **Implementation**: Reference generated artifact names

### Task 2.9.5: Document Naming Conventions

**What to Build**
- Naming convention documentation
- Examples and use cases
- Edge cases and exceptions
- Migration guide (if needed)

**Implementation Details**

**2.9.5.1 Naming Convention Document**
- **File to Create**: `DOCS/POLICY/Artifact_Naming.md`
- **Content**:
  - Base pattern
  - Component definitions
  - Platform-specific rules
  - Examples
  - Validation rules
  - Edge cases

**2.9.5.2 Examples Document**
- **File to Create**: `DOCS/EXAMPLES/Artifact_Names.md`
- **Content**: Comprehensive examples for all artifact types

## Implementation Checklist

### Naming Convention
- [ ] Define base naming pattern
- [ ] Define component rules
- [ ] Document all rules
- [ ] Create examples

### Name Generation
- [ ] Create name generation script
- [ ] Create name validation script
- [ ] Create name parsing utilities
- [ ] Test all scripts

### Build Integration
- [ ] Update DMG creation script
- [ ] Update NSIS installer script
- [ ] Update artifact upload
- [ ] Test naming in builds

### Documentation
- [ ] Create naming convention document
- [ ] Create examples document
- [ ] Document edge cases
- [ ] Create migration guide (if needed)

## Files to Create/Modify

### New Files
1. `scripts/generate_artifact_name.py` - Name generation
2. `scripts/validate_artifact_names.py` - Name validation
3. `scripts/parse_artifact_name.py` - Name parsing
4. `DOCS/POLICY/Artifact_Naming.md` - Naming policy
5. `DOCS/EXAMPLES/Artifact_Names.md` - Examples

### Files to Modify
1. `scripts/create_dmg.sh` - Use naming convention
2. `scripts/installer.nsi` - Use naming convention
3. `.github/workflows/release.yml` - Use generated names

## Implementation Dependencies

### Prerequisites
- Step 2.1: Goals and Principles (defines requirements)
- Step 2.4: Version Management (uses version)
- Step 2.6: Artifact Structure (uses naming)

### Enables
- Step 2.8: Release Gating (validates names)
- Step 3: macOS Packaging (uses names)
- Step 4: Windows Packaging (uses names)

## Success Criteria

### Naming
- ✅ All artifacts follow naming convention
- ✅ Names are consistent across releases
- ✅ Names are descriptive and clear
- ✅ Names are parseable

### Validation
- ✅ Name validation works
- ✅ Invalid names are rejected
- ✅ Validation integrated in CI

### Documentation
- ✅ Naming rules documented
- ✅ Examples provided
- ✅ Edge cases covered

## Next Implementation Steps

After completing Step 2.9:
1. **Step 2.8**: Release Gating (validates names)
2. **Step 3**: macOS Packaging (uses names)
3. **Step 4**: Windows Packaging (uses names)

## References

- Main document: `../02_Build_System_and_Release_Pipeline.md`
- Related: Step 2.6 (Artifact Structure), Step 2.4 (Version Management)
