# Implementation Step 1.5: Supported Platforms

## Implementation Overview
**What We're Building**: Platform detection, OS-specific code paths, and platform-specific configurations for macOS and Windows.

## Implementation Tasks

### Task 1.5.1: Implement Platform Detection

**What to Build**
- Platform detection utility
- Architecture detection
- OS version detection
- Platform-specific code paths

**Implementation Details**

**1.5.1.1 Platform Detection Utility**
- **File to Create**: `SRC/cuepoint/utils/platform.py`
- **Implementation**:
  ```python
  """Platform detection and utilities"""
  import platform
  import sys
  from typing import Literal
    
  Platform = Literal["macos", "windows", "linux"]
  Architecture = Literal["x64", "arm64", "x86"]
    
  def get_platform() -> Platform:
      """Get current platform"""
      system = platform.system().lower()
      if system == "darwin":
          return "macos"
      elif system == "windows":
          return "windows"
      elif system == "linux":
          return "linux"
      else:
          raise RuntimeError(f"Unsupported platform: {system}")
    
  def get_architecture() -> Architecture:
      """Get current architecture"""
      machine = platform.machine().lower()
      if machine in ("x86_64", "amd64"):
          return "x64"
      elif machine in ("arm64", "aarch64"):
          return "arm64"
      elif machine in ("i386", "i686"):
          return "x86"
      else:
          raise RuntimeError(f"Unsupported architecture: {machine}")
    
  def get_os_version() -> str:
      """Get OS version string"""
      return platform.version()
    
  def is_macos() -> bool:
      """Check if running on macOS"""
      return get_platform() == "macos"
    
  def is_windows() -> bool:
      """Check if running on Windows"""
      return get_platform() == "windows"
    
  def is_apple_silicon() -> bool:
      """Check if running on Apple Silicon"""
      return is_macos() and get_architecture() == "arm64"
  ```
- **Purpose**: Centralized platform detection
- **Usage**: Import throughout app for platform-specific code

**1.5.1.2 Platform-Specific Code Paths**
- **File to Modify**: `SRC/cuepoint/utils/paths.py` (Step 1.4)
- **Implementation**:
  ```python
  from cuepoint.utils.platform import is_macos, is_windows
  from PySide6.QtCore import QStandardPaths
    
  class AppPaths:
      @staticmethod
      def config_dir() -> Path:
          if is_macos():
              return Path.home() / "Library" / "Application Support" / "CuePoint" / "config"
          elif is_windows():
              return Path(os.getenv("APPDATA")) / "CuePoint" / "config"
      
      @staticmethod
      def logs_dir() -> Path:
          if is_macos():
              return Path.home() / "Library" / "Logs" / "CuePoint"
          elif is_windows():
              return Path(os.getenv("LOCALAPPDATA")) / "CuePoint" / "Logs"
  ```
- **Purpose**: OS-specific path handling
- **Integration**: Used by all storage operations

### Task 1.5.2: Implement macOS-Specific Features

**What to Build**
- macOS bundle configuration
- Universal2 build support
- macOS-specific UI adjustments

**Implementation Details**

**1.5.2.1 macOS Bundle Configuration**
- **File to Create**: `build/Info.plist.template` (Step 1.7)
- **Implementation**: See Step 1.7 for Info.plist
- **Purpose**: macOS app bundle metadata
- **Dependencies**: Step 1.7 (Versioning)

**1.5.2.2 Universal2 Build Support**
- **File to Modify**: `build/pyinstaller.spec` (Step 2)
- **Implementation**:
  ```python
  # In pyinstaller.spec
  # Build universal2 binary
  # Requires: PyInstaller with universal2 support
  # Or: Build separate arm64 and x64, then merge
  ```
- **Purpose**: Support both Apple Silicon and Intel
- **Dependencies**: Step 2 (Build System)

**1.5.2.3 macOS-Specific UI Adjustments**
- **File to Modify**: `SRC/cuepoint/ui/widgets/styles.py`
- **Implementation**:
  ```python
  def is_macos() -> bool:
      """Check if running on macOS"""
      return platform.system() == "Darwin"
  
  # macOS-specific styling
  if is_macos():
      button_height = 30
      font_size = 13
  else:
      button_height = 32
      font_size = 12
  ```
- **Purpose**: Platform-appropriate UI
- **Usage**: Style system

### Task 1.5.3: Implement Windows-Specific Features

**What to Build**
- Windows installer configuration
- Windows-specific UI adjustments
- Windows path handling

**Implementation Details**

**1.5.3.1 Windows Installer Configuration**
- **File to Create**: `scripts/installer.nsi` (Step 1.4)
- **Implementation**: See Step 1.4 for NSIS script
- **Purpose**: Windows installation
- **Dependencies**: Step 1.4 (Distribution)

**1.5.3.2 Windows-Specific UI Adjustments**
- **File to Modify**: `SRC/cuepoint/ui/widgets/styles.py`
- **Implementation**:
  ```python
  # Windows-specific styling
  if platform.system() == "Windows":
      button_height = 32
      font_size = 12
      # Windows-specific styles
  ```
- **Purpose**: Windows-appropriate UI
- **Usage**: Style system

**1.5.3.3 Windows Path Handling**
- **File to Modify**: `SRC/cuepoint/utils/paths.py`
- **Implementation**:
  ```python
  def windows_path(path: str) -> str:
      """Convert path to Windows format"""
      return path.replace("/", "\\")
  
  def safe_filename(filename: str) -> str:
      """Make filename safe for Windows"""
      # Remove invalid characters: < > : " | ? * \
      invalid_chars = '<>:"|?*\\'
      for char in invalid_chars:
          filename = filename.replace(char, '_')
      return filename
  ```
- **Purpose**: Handle Windows path limitations
- **Usage**: File operations

### Task 1.5.4: Implement System Requirements Validation

**What to Build**
- System requirements checker
- Minimum version validation
- Resource availability checks

**Implementation Details**

**1.5.4.1 System Requirements Checker**
- **File to Create**: `SRC/cuepoint/utils/system_check.py`
- **Implementation**:
  ```python
  """System requirements validation"""
  import platform
  import psutil
  from typing import Tuple, Optional
    
  def check_system_requirements() -> Tuple[bool, Optional[str]]:
      """Check if system meets requirements"""
      # Check OS version
      if platform.system() == "Darwin":
          version = platform.mac_ver()[0]
          major = int(version.split('.')[0])
          if major < 12:
              return False, f"macOS 12+ required, found {version}"
      
      elif platform.system() == "Windows":
          version = platform.version()
          # Check Windows 10/11
          # Implementation details
      
      # Check RAM
      ram_gb = psutil.virtual_memory().total / (1024**3)
      if ram_gb < 4:
          return False, f"4GB RAM required, found {ram_gb:.1f}GB"
      
      # Check disk space
      disk = psutil.disk_usage('/')
      free_gb = disk.free / (1024**3)
      if free_gb < 1:
          return False, f"1GB free disk space required, found {free_gb:.1f}GB"
      
      return True, None
  ```
- **Purpose**: Validate system before running
- **Usage**: Startup check

**1.5.4.2 Minimum Version Validation**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  from cuepoint.utils.system_check import check_system_requirements
    
  def __init__(self):
      # Check system requirements
      meets_requirements, error_msg = check_system_requirements()
      if not meets_requirements:
          QMessageBox.critical(
              None,
              "System Requirements Not Met",
              f"Your system does not meet the minimum requirements:\n\n{error_msg}\n\n"
              "Please upgrade your system and try again."
          )
          sys.exit(1)
  ```
- **Purpose**: Fail early if requirements not met
- **Integration**: Main window initialization

## Implementation Checklist

### Platform Detection
- [ ] Create platform detection utility
- [ ] Implement architecture detection
- [ ] Implement OS version detection
- [ ] Add platform-specific code paths

### macOS Features
- [ ] Configure macOS bundle (Step 1.7)
- [ ] Support Universal2 builds (Step 2)
- [ ] Add macOS-specific UI adjustments

### Windows Features
- [ ] Configure Windows installer (Step 1.4)
- [ ] Add Windows-specific UI adjustments
- [ ] Implement Windows path handling

### System Requirements
- [ ] Create requirements checker
- [ ] Add minimum version validation
- [ ] Add resource availability checks

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/utils/platform.py` - Platform detection
2. `SRC/cuepoint/utils/system_check.py` - Requirements validation

### Files to Modify
1. `SRC/cuepoint/utils/paths.py` - Platform-specific paths
2. `SRC/cuepoint/ui/widgets/styles.py` - Platform-specific styles
3. `SRC/cuepoint/ui/main_window.py` - System check on startup

## Implementation Dependencies

### Prerequisites
- Step 1.4: Distribution formats (defines platform requirements)

### Enables
- Step 2: Build system (uses platform detection)
- Step 3: macOS packaging (uses macOS features)
- Step 4: Windows packaging (uses Windows features)

## Success Criteria

### Platform Detection
- ✅ Correct platform identified
- ✅ Correct architecture identified
- ✅ Platform-specific code paths work

### System Requirements
- ✅ Requirements validated on startup
- ✅ Clear error messages for unmet requirements
- ✅ Graceful handling of unsupported platforms

## Next Implementation Steps

After completing Step 1.5:
1. **Step 2**: Build system (uses platform detection)
2. **Step 3**: macOS packaging (implements macOS features)
3. **Step 4**: Windows packaging (implements Windows features)

## Detailed Platform Implementation

### Platform Detection - Complete Implementation

**1.5.1.3 Enhanced Platform Detection Module**
- **Complete Implementation**:
  ```python
  # SRC/cuepoint/utils/platform.py
  """Platform detection and utilities"""
  import platform
  import sys
  from typing import Literal, Optional, Dict, Any
  
  Platform = Literal["macos", "windows", "linux"]
  Architecture = Literal["x64", "arm64", "x86"]
  
  class PlatformInfo:
      """Platform information container"""
      def __init__(self):
          self.platform = self._detect_platform()
          self.architecture = self._detect_architecture()
          self.os_version = self._detect_os_version()
          self.is_64bit = sys.maxsize > 2**32
          self.is_apple_silicon = self._is_apple_silicon()
      
      def _detect_platform(self) -> Platform:
          """Detect current platform"""
          system = platform.system().lower()
          if system == "darwin":
              return "macos"
          elif system == "windows":
              return "windows"
          elif system == "linux":
              return "linux"
          else:
              raise RuntimeError(f"Unsupported platform: {system}")
      
      def _detect_architecture(self) -> Architecture:
          """Detect CPU architecture"""
          machine = platform.machine().lower()
          if machine in ("x86_64", "amd64"):
              return "x64"
          elif machine in ("arm64", "aarch64"):
              return "arm64"
          elif machine in ("i386", "i686"):
              return "x86"
          else:
              # Default to x64 for unknown
              return "x64"
      
      def _detect_os_version(self) -> str:
          """Get OS version string"""
          if self.platform == "macos":
              return platform.mac_ver()[0]
          elif self.platform == "windows":
              return platform.version()
          elif self.platform == "linux":
              return platform.release()
          return "unknown"
      
      def _is_apple_silicon(self) -> bool:
          """Check if running on Apple Silicon"""
          return self.platform == "macos" and self.architecture == "arm64"
      
      def to_dict(self) -> Dict[str, Any]:
          """Convert to dictionary for diagnostics"""
          return {
              "platform": self.platform,
              "architecture": self.architecture,
              "os_version": self.os_version,
              "is_64bit": self.is_64bit,
              "is_apple_silicon": self.is_apple_silicon,
              "python_version": sys.version,
              "python_executable": sys.executable
          }
  
  # Global platform info instance
  _platform_info: Optional[PlatformInfo] = None
  
  def get_platform_info() -> PlatformInfo:
      """Get platform information (singleton)"""
      global _platform_info
      if _platform_info is None:
          _platform_info = PlatformInfo()
      return _platform_info
  
  def get_platform() -> Platform:
      """Get current platform"""
      return get_platform_info().platform
  
  def get_architecture() -> Architecture:
      """Get current architecture"""
      return get_platform_info().architecture
  
  def get_os_version() -> str:
      """Get OS version string"""
      return get_platform_info().os_version
  
  def is_macos() -> bool:
      """Check if running on macOS"""
      return get_platform() == "macos"
  
  def is_windows() -> bool:
      """Check if running on Windows"""
      return get_platform() == "windows"
  
  def is_linux() -> bool:
      """Check if running on Linux"""
      return get_platform() == "linux"
  
  def is_apple_silicon() -> bool:
      """Check if running on Apple Silicon"""
      return get_platform_info().is_apple_silicon
  
  def is_64bit() -> bool:
      """Check if running 64-bit"""
      return get_platform_info().is_64bit
  
  def get_platform_string() -> str:
      """Get platform string for display"""
      info = get_platform_info()
      if info.is_apple_silicon:
          return f"macOS {info.os_version} (Apple Silicon)"
      return f"{info.platform.title()} {info.os_version} ({info.architecture})"
  ```

**1.5.1.4 Platform-Specific Path Handling - Complete**
- **Enhanced Paths Module with Platform Support**:
  ```python
  # SRC/cuepoint/utils/paths.py (enhanced)
  from pathlib import Path
  from PySide6.QtCore import QStandardPaths
  from cuepoint.utils.platform import is_macos, is_windows, get_platform
  import os
  
  class AppPaths:
      """Standard application paths with platform-specific handling"""
      
      @staticmethod
      def _ensure_dir(path: Path) -> Path:
          """Ensure directory exists"""
          path.mkdir(parents=True, exist_ok=True)
          return path
      
      @staticmethod
      def config_dir() -> Path:
          """Configuration directory (platform-specific)"""
          if is_macos():
              # macOS: ~/Library/Application Support/CuePoint
              path = Path.home() / "Library" / "Application Support" / "CuePoint"
          elif is_windows():
              # Windows: %APPDATA%\CuePoint
              appdata = os.getenv("APPDATA")
              if not appdata:
                  raise RuntimeError("APPDATA environment variable not set")
              path = Path(appdata) / "CuePoint"
          else:
              # Linux/Other: Use QStandardPaths
              path = Path(QStandardPaths.writableLocation(
                  QStandardPaths.AppConfigLocation
              )) / "CuePoint"
          
          return AppPaths._ensure_dir(path)
      
      @staticmethod
      def data_dir() -> Path:
          """Application data directory"""
          if is_macos():
              path = Path.home() / "Library" / "Application Support" / "CuePoint"
          elif is_windows():
              localappdata = os.getenv("LOCALAPPDATA")
              if not localappdata:
                  raise RuntimeError("LOCALAPPDATA environment variable not set")
              path = Path(localappdata) / "CuePoint"
          else:
              path = Path(QStandardPaths.writableLocation(
                  QStandardPaths.AppLocalDataLocation
              )) / "CuePoint"
          
          return AppPaths._ensure_dir(path)
      
      @staticmethod
      def cache_dir() -> Path:
          """Cache directory"""
          if is_macos():
              path = Path.home() / "Library" / "Caches" / "CuePoint"
          elif is_windows():
              localappdata = os.getenv("LOCALAPPDATA")
              if not localappdata:
                  raise RuntimeError("LOCALAPPDATA environment variable not set")
              path = Path(localappdata) / "CuePoint" / "Cache"
          else:
              path = Path(QStandardPaths.writableLocation(
                  QStandardPaths.CacheLocation
              )) / "CuePoint"
          
          return AppPaths._ensure_dir(path)
      
      @staticmethod
      def logs_dir() -> Path:
          """Logs directory"""
          if is_macos():
              path = Path.home() / "Library" / "Logs" / "CuePoint"
          elif is_windows():
              localappdata = os.getenv("LOCALAPPDATA")
              if not localappdata:
                  raise RuntimeError("LOCALAPPDATA environment variable not set")
              path = Path(localappdata) / "CuePoint" / "Logs"
          else:
              path = AppPaths.data_dir() / "Logs"
          
          return AppPaths._ensure_dir(path)
      
      @staticmethod
      def exports_dir() -> Path:
          """Default exports directory"""
          if is_macos():
              downloads = Path.home() / "Downloads"
          elif is_windows():
              downloads = Path.home() / "Downloads"
          else:
              downloads = Path(QStandardPaths.writableLocation(
                  QStandardPaths.DownloadLocation
              ))
          
          exports = downloads / "CuePoint Exports"
          return AppPaths._ensure_dir(exports)
      
      @staticmethod
      def safe_filename(filename: str) -> str:
          """Make filename safe for current platform"""
          if is_windows():
              # Windows: Remove invalid characters
              invalid_chars = '<>:"|?*\\'
              for char in invalid_chars:
                  filename = filename.replace(char, '_')
              # Remove reserved names
              reserved = ['CON', 'PRN', 'AUX', 'NUL'] + \
                        [f'COM{i}' for i in range(1, 10)] + \
                        [f'LPT{i}' for i in range(1, 10)]
              if filename.upper() in reserved:
                  filename = f"_{filename}"
          else:
              # macOS/Linux: Remove / and null
              filename = filename.replace('/', '_').replace('\0', '_')
          
          # Limit length (Windows: 255, others: 255)
          if len(filename) > 255:
              name, ext = os.path.splitext(filename)
              filename = name[:255-len(ext)] + ext
          
          return filename
  ```

### macOS-Specific Features - Deep Dive

**1.5.2.4 macOS Bundle Structure - Complete**
- **Info.plist Template**:
  ```xml
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
  <plist version="1.0">
  <dict>
      <!-- Version Information -->
      <key>CFBundleShortVersionString</key>
      <string>{{VERSION}}</string>
      <key>CFBundleVersion</key>
      <string>{{BUILD_NUMBER}}</string>
      <key>CFBundleIdentifier</key>
      <string>com.stuchain.cuepoint</string>
      
      <!-- Application Information -->
      <key>CFBundleName</key>
      <string>CuePoint</string>
      <key>CFBundleDisplayName</key>
      <string>CuePoint</string>
      <key>CFBundlePackageType</key>
      <string>APPL</string>
      <key>CFBundleSignature</key>
      <string>????</string>
      
      <!-- System Requirements -->
      <key>LSMinimumSystemVersion</key>
      <string>10.15</string>
      <key>LSRequiresNativeExecution</key>
      <false/>
      
      <!-- Architecture Support -->
      <key>LSArchitecturePriority</key>
      <array>
          <string>arm64</string>
          <string>x86_64</string>
      </array>
      
      <!-- UI Configuration -->
      <key>NSHighResolutionCapable</key>
      <true/>
      <key>NSPrincipalClass</key>
      <string>NSApplication</string>
      <key>NSHumanReadableCopyright</key>
      <string>Copyright © 2024 StuChain. All rights reserved.</string>
      
      <!-- Document Types -->
      <key>CFBundleDocumentTypes</key>
      <array>
          <dict>
              <key>CFBundleTypeExtensions</key>
              <array>
                  <string>xml</string>
              </array>
              <key>CFBundleTypeName</key>
              <string>Rekordbox Collection XML</string>
              <key>CFBundleTypeRole</key>
              <string>Viewer</string>
          </dict>
      </array>
      
      <!-- URL Schemes -->
      <key>CFBundleURLTypes</key>
      <array>
          <dict>
              <key>CFBundleURLSchemes</key>
              <array>
                  <string>cuepoint</string>
              </array>
          </dict>
      </array>
      
      <!-- Security -->
      <key>NSAppTransportSecurity</key>
      <dict>
          <key>NSAllowsArbitraryLoads</key>
          <false/>
      </dict>
  </dict>
  </plist>
  ```

**1.5.2.5 Universal2 Build Support - Complete**
- **Universal2 Build Strategy**:
  ```python
  # build/universal2_build.py
  """Build Universal2 binary for macOS"""
  import subprocess
  import shutil
  from pathlib import Path
  
  def build_universal2():
      """Build Universal2 app bundle"""
      # Option 1: Use PyInstaller with universal2 support (if available)
      # Option 2: Build separate arm64 and x64, then merge
      
      # Build arm64
      print("Building arm64...")
      subprocess.run([
          "pyinstaller",
          "--target-arch", "arm64",
          "build/pyinstaller.spec"
      ], check=True)
      
      # Build x64
      print("Building x64...")
      subprocess.run([
          "pyinstaller",
          "--target-arch", "x86_64",
          "build/pyinstaller.spec"
      ], check=True)
      
      # Merge using lipo
      print("Merging architectures...")
      arm64_binary = Path("dist/arm64/CuePoint.app/Contents/MacOS/CuePoint")
      x64_binary = Path("dist/x64/CuePoint.app/Contents/MacOS/CuePoint")
      universal_binary = Path("dist/CuePoint.app/Contents/MacOS/CuePoint")
      
      subprocess.run([
          "lipo",
          "-create",
          str(arm64_binary),
          str(x64_binary),
          "-output",
          str(universal_binary)
      ], check=True)
      
      print("Universal2 build complete!")
  ```

**1.5.2.6 macOS-Specific UI Adjustments - Complete**
- **Platform-Specific Styling**:
  ```python
  # SRC/cuepoint/ui/widgets/styles.py
  """Platform-specific UI styling"""
  from cuepoint.utils.platform import is_macos, is_windows
  from PySide6.QtWidgets import QApplication
  from PySide6.QtCore import Qt
  
  class PlatformStyles:
      """Platform-specific style constants"""
      
      @staticmethod
      def button_height() -> int:
          """Button height for current platform"""
          if is_macos():
              return 30
          elif is_windows():
              return 32
          else:
              return 30
      
      @staticmethod
      def font_size() -> int:
          """Default font size"""
          if is_macos():
              return 13
          elif is_windows():
              return 12
          else:
              return 12
      
      @staticmethod
      def spacing() -> int:
          """Default spacing"""
          if is_macos():
              return 8
          elif is_windows():
              return 6
          else:
              return 8
      
      @staticmethod
      def apply_platform_style(app: QApplication):
          """Apply platform-specific application style"""
          if is_macos():
              # macOS: Use native style
              app.setStyle("macintosh")
              # Set macOS-specific settings
              app.setAttribute(Qt.AA_DontShowIconsInMenus, False)
          elif is_windows():
              # Windows: Use native style
              app.setStyle("windowsvista")
          else:
              # Linux: Use Fusion style
              app.setStyle("Fusion")
      
      @staticmethod
      def get_window_flags():
          """Get platform-specific window flags"""
          flags = Qt.Window
          if is_macos():
              # macOS: Add native window features
              flags |= Qt.WindowTitleHint | Qt.WindowSystemMenuHint
          return flags
  ```

### Windows-Specific Features - Deep Dive

**1.5.3.4 Windows Installer Configuration - Complete**
- **Enhanced NSIS Script** (see Step 1.4 for full script)
- **Windows-Specific Considerations**:
  - User vs. Admin installation
  - Start Menu shortcuts
  - Desktop shortcut (optional)
  - Registry entries
  - Uninstaller

**1.5.3.5 Windows Path Handling - Complete**
- **Windows-Specific Path Utilities**:
  ```python
  # SRC/cuepoint/utils/windows_paths.py
  """Windows-specific path handling"""
  import os
  from pathlib import Path
  
  def get_windows_path(path: str) -> str:
      """Convert path to Windows format"""
      return path.replace("/", "\\")
  
  def get_long_path(path: Path) -> Path:
      """Get Windows long path (handle 260 char limit)"""
      if not isinstance(path, Path):
          path = Path(path)
      
      # Convert to absolute path
      abs_path = path.resolve()
      
      # If path is too long, use UNC path
      if len(str(abs_path)) > 260:
          # Use \\?\ prefix for long paths
          return Path(f"\\\\?\\{abs_path}")
      
      return abs_path
  
  def safe_windows_filename(filename: str) -> str:
      """Make filename safe for Windows"""
      # Remove invalid characters
      invalid_chars = '<>:"|?*\\'
      for char in invalid_chars:
          filename = filename.replace(char, '_')
      
      # Remove reserved names
      reserved = ['CON', 'PRN', 'AUX', 'NUL'] + \
                [f'COM{i}' for i in range(1, 10)] + \
                [f'LPT{i}' for i in range(1, 10)]
      
      name, ext = os.path.splitext(filename)
      if name.upper() in reserved:
          filename = f"_{name}{ext}"
      
      # Limit length (255 chars total)
      if len(filename) > 255:
          name, ext = os.path.splitext(filename)
          max_name_len = 255 - len(ext)
          filename = name[:max_name_len] + ext
      
      return filename
  ```

**1.5.3.6 Windows-Specific UI Adjustments - Complete**
- **Windows UI Styling**:
  ```python
  # Windows-specific UI adjustments
  if is_windows():
      # Windows: Use Windows-style buttons
      button_style = """
          QPushButton {
              min-height: 32px;
              padding: 4px 12px;
              font-size: 12px;
          }
          QPushButton:hover {
              background-color: #e0e0e0;
          }
      """
      
      # Windows: Adjust menu bar
      menu_bar_style = """
          QMenuBar {
              background-color: #f0f0f0;
              border-bottom: 1px solid #d0d0d0;
          }
      """
  ```

### System Requirements Validation - Deep Dive

**1.5.4.3 Complete System Requirements Checker**
- **Enhanced System Check Module**:
  ```python
  # SRC/cuepoint/utils/system_check.py
  """System requirements validation"""
  import platform
  import psutil
  import sys
  from typing import Tuple, Optional, List, Dict, Any
  from cuepoint.utils.platform import get_platform, is_macos, is_windows
  
  class SystemRequirements:
      """System requirements configuration"""
      MIN_MACOS_VERSION = (10, 15)  # macOS 10.15 (Catalina)
      MIN_WINDOWS_VERSION = (10, 0)  # Windows 10
      MIN_RAM_GB = 4
      MIN_DISK_SPACE_GB = 1
      MIN_PYTHON_VERSION = (3, 9)
      
      @staticmethod
      def check_all() -> Tuple[bool, List[str]]:
          """Check all system requirements"""
          errors = []
          
          # Check platform
          platform_ok, platform_error = SystemRequirements.check_platform()
          if not platform_ok:
              errors.append(platform_error)
          
          # Check OS version
          os_ok, os_error = SystemRequirements.check_os_version()
          if not os_ok:
              errors.append(os_error)
          
          # Check RAM
          ram_ok, ram_error = SystemRequirements.check_ram()
          if not ram_ok:
              errors.append(ram_error)
          
          # Check disk space
          disk_ok, disk_error = SystemRequirements.check_disk_space()
          if not disk_ok:
              errors.append(disk_error)
          
          # Check Python version (if running from source)
          if not getattr(sys, 'frozen', False):
              python_ok, python_error = SystemRequirements.check_python_version()
              if not python_ok:
                  errors.append(python_error)
          
          return len(errors) == 0, errors
      
      @staticmethod
      def check_platform() -> Tuple[bool, Optional[str]]:
          """Check if platform is supported"""
          platform_name = get_platform()
          if platform_name not in ("macos", "windows"):
              return False, f"Unsupported platform: {platform_name}"
          return True, None
      
      @staticmethod
      def check_os_version() -> Tuple[bool, Optional[str]]:
          """Check OS version meets minimum"""
          if is_macos():
              version_str = platform.mac_ver()[0]
              version_parts = [int(x) for x in version_str.split('.')[:2]]
              if tuple(version_parts) < SystemRequirements.MIN_MACOS_VERSION:
                  return False, (
                      f"macOS {'.'.join(map(str, SystemRequirements.MIN_MACOS_VERSION))}+ required, "
                      f"found {version_str}"
                  )
          elif is_windows():
              version = platform.version()
              # Windows 10/11 check
              # Implementation details
              pass
          
          return True, None
      
      @staticmethod
      def check_ram() -> Tuple[bool, Optional[str]]:
          """Check RAM meets minimum"""
          try:
              ram_gb = psutil.virtual_memory().total / (1024**3)
              if ram_gb < SystemRequirements.MIN_RAM_GB:
                  return False, (
                      f"{SystemRequirements.MIN_RAM_GB}GB RAM required, "
                      f"found {ram_gb:.1f}GB"
                  )
              return True, None
          except Exception as e:
              return False, f"Could not check RAM: {e}"
      
      @staticmethod
      def check_disk_space() -> Tuple[bool, Optional[str]]:
          """Check disk space meets minimum"""
          try:
              disk = psutil.disk_usage('/')
              free_gb = disk.free / (1024**3)
              if free_gb < SystemRequirements.MIN_DISK_SPACE_GB:
                  return False, (
                      f"{SystemRequirements.MIN_DISK_SPACE_GB}GB free disk space required, "
                      f"found {free_gb:.1f}GB"
                  )
              return True, None
          except Exception as e:
              return False, f"Could not check disk space: {e}"
      
      @staticmethod
      def check_python_version() -> Tuple[bool, Optional[str]]:
          """Check Python version meets minimum"""
          version = sys.version_info[:2]
          if version < SystemRequirements.MIN_PYTHON_VERSION:
              return False, (
                  f"Python {'.'.join(map(str, SystemRequirements.MIN_PYTHON_VERSION))}+ required, "
                  f"found {'.'.join(map(str, version))}"
              )
          return True, None
      
      @staticmethod
      def get_system_info() -> Dict[str, Any]:
          """Get system information for diagnostics"""
          return {
              "platform": get_platform(),
              "os_version": platform.version() if is_windows() else platform.mac_ver()[0],
              "architecture": platform.machine(),
              "ram_gb": psutil.virtual_memory().total / (1024**3),
              "disk_free_gb": psutil.disk_usage('/').free / (1024**3),
              "python_version": sys.version,
          }
  ```

**1.5.4.4 Startup System Check Integration**
- **Main Window Integration**:
  ```python
  # In SRC/cuepoint/ui/main_window.py
  from cuepoint.utils.system_check import SystemRequirements
  from PySide6.QtWidgets import QMessageBox
  
  class MainWindow:
      def __init__(self):
          # Check system requirements
          meets_requirements, errors = SystemRequirements.check_all()
          
          if not meets_requirements:
              error_message = (
                  "Your system does not meet the minimum requirements:\n\n" +
                  "\n".join(f"• {error}" for error in errors) +
                  "\n\nPlease upgrade your system and try again."
              )
              
              msg = QMessageBox()
              msg.setIcon(QMessageBox.Critical)
              msg.setWindowTitle("System Requirements Not Met")
              msg.setText(error_message)
              msg.exec()
              
              sys.exit(1)
          
          # Continue with initialization
          super().__init__()
  ```

## Testing Scenarios

### Platform Detection Tests
- **Test 1**: Detect macOS correctly
- **Test 2**: Detect Windows correctly
- **Test 3**: Detect architecture (x64, arm64)
- **Test 4**: Detect Apple Silicon
- **Test 5**: Get OS version

### System Requirements Tests
- **Test 1**: Valid system passes checks
- **Test 2**: Old macOS version fails
- **Test 3**: Insufficient RAM fails
- **Test 4**: Insufficient disk space fails
- **Test 5**: Error messages are clear

### Platform-Specific Feature Tests
- **Test 1**: macOS paths work correctly
- **Test 2**: Windows paths work correctly
- **Test 3**: Platform-specific UI styles apply
- **Test 4**: Safe filename generation works

## Edge Cases

### Platform Detection Edge Cases
- **Case 1**: Unknown platform
  - **Handling**: Raise error, show message
- **Case 2**: Unknown architecture
  - **Handling**: Default to x64, log warning
- **Case 3**: Virtual machine detection
  - **Handling**: Detect but don't block

### System Requirements Edge Cases
- **Case 1**: psutil not available
  - **Handling**: Skip checks, log warning
- **Case 2**: Disk space check fails
  - **Handling**: Warn but don't block
- **Case 3**: OS version detection fails
  - **Handling**: Warn but don't block

## Performance Considerations

### Platform Detection Performance
- **Target**: < 10ms for all checks
- **Optimization**: Cache platform info
- **Measurement**: Profile startup time

## References

- Main document: `../01_Product_Requirements_and_Definition.md`
- Related: Step 1.4 (Distribution), Step 2 (Build System), Step 3-4 (Packaging)
- Platform Detection: Python `platform` module
- System Info: `psutil` library

