# Implementation Step 1.3: Primary Workflows (User Journeys)

## Implementation Overview
**What We're Building**: Implement five primary user workflows with step-by-step UI/UX and code requirements.

## Implementation Tasks

### Task 1.3.1: Implement First Run Workflow

**What to Build**
- Onboarding dialog system
- XML selection and validation
- Mode selection UI
- Playlist selection UI
- Processing workflow
- Results review UI
- Export workflow

**Implementation Details**

**1.3.1.1 Launch and Onboarding**
- **File to Create**: `SRC/cuepoint/ui/dialogs/onboarding_dialog.py`
- **Implementation**:
  ```python
  class OnboardingDialog(QDialog):
      """First-run onboarding dialog"""
      def __init__(self, parent=None):
          # Show welcome screen
          # Explain Collection XML
          # Show sample screenshot
          # "Don't show again" checkbox
  ```
- **Integration**: Call from `SRC/cuepoint/ui/main_window.py` on first launch
- **Storage**: Use QSettings to track if shown

**1.3.1.2 XML Selection and Validation**
- **File to Modify**: `SRC/cuepoint/ui/widgets/collection_selector.py` (if exists) or `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  def on_browse_xml(self):
      """Browse and validate XML file"""
      file_path, _ = QFileDialog.getOpenFileName(
          self, "Select Rekordbox Collection XML", "", "XML Files (*.xml)"
      )
      if file_path:
          # Validate XML
          if self.validate_xml(file_path):
              self.xml_path = file_path
              self.load_playlists()
          else:
              self.show_error("Invalid XML file")
  ```
- **Validation**: Use existing `SRC/cuepoint/data/xml_parser.py`

**1.3.1.3 Mode Selection UI**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  # Radio buttons for Single/Batch mode
  self.mode_single = QRadioButton("Single Playlist")
  self.mode_batch = QRadioButton("Batch (Multiple Playlists)")
  self.mode_group = QButtonGroup()
  self.mode_group.addButton(self.mode_single, 0)
  self.mode_group.addButton(self.mode_batch, 1)
  ```
- **State Management**: Store mode preference in QSettings

**1.3.1.4 Playlist Selection UI**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  self.playlist_combo = QComboBox()
  self.playlist_combo.currentTextChanged.connect(self.on_playlist_selected)
  
  def load_playlists(self):
      """Load playlists from XML"""
      playlists = self.xml_parser.get_playlists(self.xml_path)
      self.playlist_combo.clear()
      self.playlist_combo.addItems(playlists)
  ```

**1.3.1.5 Processing Workflow**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  def on_start_processing(self):
      """Start processing workflow"""
      # Validate inputs
      if not self.xml_path or not self.playlist_combo.currentText():
          self.show_error("Please select XML and playlist")
          return
      
      # Show progress dialog
      self.progress_dialog = ProcessingDialog(self)
      self.progress_dialog.show()
      
      # Start processing in background thread
      self.processor_thread = ProcessingThread(...)
      self.processor_thread.progress.connect(self.update_progress)
      self.processor_thread.finished.connect(self.on_processing_complete)
      self.processor_thread.start()
  ```
- **Progress Dialog**: Create `SRC/cuepoint/ui/dialogs/processing_dialog.py`

**1.3.1.6 Results Review UI**
- **File**: Already exists - `SRC/cuepoint/ui/widgets/results_view.py`
- **Enhancements Needed**:
  - Ensure summary statistics display
  - Verify filtering works
  - Add candidate review functionality

**1.3.1.7 Export Workflow**
- **File**: Already exists - `SRC/cuepoint/ui/dialogs/export_dialog.py`
- **Enhancements Needed**:
  - Verify all export formats work
  - Add "Open Output Folder" button
  - Improve error handling

### Task 1.3.2: Implement Repeat Run Workflow

**What to Build**
- Recent files management
- State persistence
- Quick start functionality

**Implementation Details**

**1.3.2.1 Recent Files Management**
- **File to Create**: `SRC/cuepoint/utils/recent_files.py`
- **Implementation**:
  ```python
  class RecentFilesManager:
      """Manage recent XML files"""
      def __init__(self):
          self.settings = QSettings()
      
      def add_recent_file(self, file_path: str):
          """Add file to recent list"""
          recent = self.get_recent_files()
          if file_path in recent:
              recent.remove(file_path)
          recent.insert(0, file_path)
          recent = recent[:10]  # Keep last 10
          self.settings.setValue("recent_files", recent)
      
      def get_recent_files(self) -> List[str]:
          """Get list of recent files"""
          return self.settings.value("recent_files", [], type=list)
  ```
- **Integration**: Use in `SRC/cuepoint/ui/main_window.py`

**1.3.2.2 State Persistence**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  def save_state(self):
      """Save window state and settings"""
      settings = QSettings()
      settings.setValue("geometry", self.saveGeometry())
      settings.setValue("windowState", self.saveState())
      settings.setValue("last_xml", self.xml_path)
      settings.setValue("last_playlist", self.playlist_combo.currentText())
      settings.setValue("last_mode", self.mode_group.checkedId())
  
  def restore_state(self):
      """Restore window state and settings"""
      settings = QSettings()
      self.restoreGeometry(settings.value("geometry"))
      self.restoreState(settings.value("windowState"))
      # Restore last XML and playlist
  ```

**1.3.2.3 Quick Start Functionality**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  def quick_start(self):
      """Quick start with last used settings"""
      if self.xml_path and self.playlist_combo.currentText():
          self.on_start_processing()
      else:
          self.show_onboarding_if_needed()
  ```

### Task 1.3.3: Implement Review/Refine Workflow

**What to Build**
- Advanced filtering UI
- Candidate review dialog
- Re-export functionality

**Implementation Details**

**1.3.3.1 Advanced Filtering UI**
- **File**: Already exists - `SRC/cuepoint/ui/widgets/results_view.py`
- **Enhancements Needed**:
  - Verify all filters work (year, BPM, key, confidence)
  - Ensure filter status display
  - Add "Clear Filters" functionality
  - Performance: Debounce filter application

**1.3.3.2 Candidate Review Dialog**
- **File**: Already exists - `SRC/cuepoint/ui/widgets/candidate_dialog.py`
- **Enhancements Needed**:
  - Verify candidate selection works
  - Ensure result updates correctly
  - Add candidate comparison view

**1.3.3.3 Re-export Functionality**
- **File**: Already exists - `SRC/cuepoint/ui/dialogs/export_dialog.py`
- **Enhancements Needed**:
  - Verify filtered results export correctly
  - Add export history
  - Prevent accidental overwrites

### Task 1.3.4: Implement Past Searches Workflow

**What to Build**
- Past searches tab
- CSV loading and parsing
- Filter application to past results
- Re-run processing functionality

**Implementation Details**

**1.3.4.1 Past Searches Tab**
- **File**: Already exists - `SRC/cuepoint/ui/widgets/history_view.py`
- **Enhancements Needed**:
  - Verify recent files list works
  - Ensure CSV loading works
  - Add file metadata display

**1.3.4.2 CSV Loading and Parsing**
- **File**: Already exists - `SRC/cuepoint/ui/widgets/history_view.py`
- **Implementation**: Already implemented
- **Enhancements Needed**:
  - Better error handling for invalid CSV
  - Support for different CSV formats
  - Large file handling (lazy loading)

**1.3.4.3 Filter Application**
- **File**: Already exists - `SRC/cuepoint/ui/widgets/history_view.py`
- **Implementation**: Already implemented
- **Enhancements Needed**:
  - Verify all filters work on past results
  - Performance optimization

**1.3.4.4 Re-run Processing**
- **File to Modify**: `SRC/cuepoint/ui/widgets/history_view.py`
- **Implementation**:
  ```python
  def on_rerun_processing(self):
      """Re-run processing with original XML"""
      # Get original XML path from CSV metadata
      xml_path = self.get_original_xml_path()
      if not xml_path or not os.path.exists(xml_path):
          self.show_error("Original XML file not found")
          return
      
      # Emit signal to main window
      self.rerun_requested.emit(xml_path, self.playlist_name)
  ```
- **Integration**: Connect to main window processing

### Task 1.3.5: Implement Update Workflow

**What to Build**
- Update checker service
- Update dialog
- Update download and installation
- App relaunch

**Implementation Details**

**1.3.5.1 Update Checker Service**
- **File to Create**: `SRC/cuepoint/services/update_checker.py`
- **Implementation**:
  ```python
  class UpdateChecker:
      """Check for app updates"""
      def __init__(self):
          self.feed_url = "https://.../updates/macos/appcast.xml"
          self.last_check = None
      
      def check_for_updates(self, force=False):
          """Check for updates"""
          if not force and self.recently_checked():
              return
          
          # Fetch appcast
          # Compare versions
          # Emit signal if update available
  ```
- **Integration**: Use Sparkle (macOS) or WinSparkle (Windows) - Step 5

**1.3.5.2 Update Dialog**
- **File to Create**: `SRC/cuepoint/ui/dialogs/update_dialog.py`
- **Implementation**:
  ```python
  class UpdateDialog(QDialog):
      """Update available dialog"""
      def __init__(self, version_info, parent=None):
          # Show current → new version
          # Show release notes
          # "Download & Install" button
          # "Remind me later" button
          # "Skip this version" button
  ```
- **Integration**: Called from update checker

**1.3.5.3 Update Download and Installation**
- **Implementation**: Handled by Sparkle/WinSparkle frameworks
- **File to Create**: Update configuration in Step 5
- **Requirements**:
  - Signed update packages
  - Signature verification
  - Data preservation during update

**1.3.5.4 App Relaunch**
- **Implementation**: Handled by update frameworks
- **Requirements**:
  - Auto-relaunch on macOS
  - Optional auto-relaunch on Windows
  - State restoration after relaunch

## Implementation Checklist

### First Run Workflow
- [ ] Create onboarding dialog
- [ ] Implement XML selection and validation
- [ ] Implement mode selection UI
- [ ] Implement playlist selection UI
- [ ] Create processing dialog
- [ ] Enhance results review UI
- [ ] Enhance export dialog

### Repeat Run Workflow
- [ ] Create recent files manager
- [ ] Implement state persistence
- [ ] Implement quick start

### Review/Refine Workflow
- [ ] Verify advanced filtering
- [ ] Enhance candidate dialog
- [ ] Enhance re-export functionality

### Past Searches Workflow
- [ ] Verify past searches tab
- [ ] Enhance CSV loading
- [ ] Implement re-run processing

### Update Workflow
- [ ] Create update checker (Step 5)
- [ ] Create update dialog (Step 5)
- [ ] Configure update frameworks (Step 5)

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/ui/dialogs/onboarding_dialog.py` - Onboarding flow
2. `SRC/cuepoint/ui/dialogs/processing_dialog.py` - Processing progress
3. `SRC/cuepoint/ui/dialogs/update_dialog.py` - Update prompt (Step 5)
4. `SRC/cuepoint/utils/recent_files.py` - Recent files management
5. `SRC/cuepoint/services/update_checker.py` - Update checking (Step 5)

### Files to Modify
1. `SRC/cuepoint/ui/main_window.py` - Main workflow orchestration
2. `SRC/cuepoint/ui/widgets/results_view.py` - Results and filtering
3. `SRC/cuepoint/ui/widgets/history_view.py` - Past searches
4. `SRC/cuepoint/ui/widgets/candidate_dialog.py` - Candidate review
5. `SRC/cuepoint/ui/dialogs/export_dialog.py` - Export functionality

## Implementation Dependencies

### Prerequisites
- Step 1.1: Product statement
- Step 1.2: User personas

### Enables
- Step 1.8: UX requirements (workflows inform UX)
- Step 9.4: Onboarding implementation
- Step 5: Update system implementation

## Success Criteria

### Workflow Completion
- ✅ First run: > 80% complete without help
- ✅ Repeat run: < 2 minutes to export
- ✅ Review/refine: > 70% use filters
- ✅ Past searches: > 50% use feature
- ✅ Update: > 80% install when prompted

### Code Quality
- ✅ All workflows have error handling
- ✅ All workflows have progress indication
- ✅ All workflows preserve user data
- ✅ All workflows are testable

## Next Implementation Steps

After completing Step 1.3:
1. **Step 1.8**: Define UX requirements (workflows inform requirements)
2. **Step 9.4**: Implement onboarding dialog
3. **Step 5**: Implement update system
4. **Step 6**: Implement operational requirements (logging, diagnostics)

## Detailed Workflow Step-by-Step Breakdowns

### Workflow 1: First Run - Complete Implementation

**1.3.1.8 Complete First Run Flow**
- **Step 1: Application Launch**
  - **Action**: User double-clicks app icon
  - **System Response**: 
    - Check if first run (QSettings)
    - If first run: Show onboarding dialog
    - If not first run: Load main window with saved state
  - **Implementation**:
    ```python
    # In main_window.py __init__
    def __init__(self):
        super().__init__()
        self.settings = QSettings()
        self.is_first_run = not self.settings.value("first_run_complete", False, type=bool)
        
        if self.is_first_run:
            self.show_onboarding()
        else:
            self.restore_state()
    ```
  - **Error Handling**: If onboarding fails, still show main window
  - **Testing**: Test first launch, subsequent launches

- **Step 2: Onboarding Dialog Display**
  - **Action**: Onboarding dialog appears
  - **UI Elements**:
    - Welcome message
    - Step indicator (1 of 5)
    - Content area with instructions
    - Navigation buttons (Previous, Next, Skip)
    - "Don't show again" checkbox
  - **Implementation**: See onboarding dialog code in Step 1.2
  - **User Actions**: 
    - Click "Next" to continue
    - Click "Skip" to skip onboarding
    - Click "Previous" to go back
    - Check "Don't show again" to prevent future shows
  - **Edge Cases**:
    - User closes dialog: Mark as shown, don't show again
    - User clicks skip: Mark as shown, show main window
    - User completes: Mark as complete, show main window

- **Step 3: XML File Selection**
  - **Action**: User clicks "Select XML" button
  - **System Response**:
    - Show file dialog
    - Filter for .xml files
    - Validate selected file
    - Load playlists if valid
  - **Implementation**:
    ```python
    def on_browse_xml(self):
        """Browse and validate XML file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            "Select Rekordbox Collection XML",
            self.get_last_xml_directory(),
            "XML Files (*.xml);;All Files (*)"
        )
        
        if file_path:
            # Validate XML structure
            validation_result = self.validate_xml_structure(file_path)
            if not validation_result.valid:
                self.show_error_dialog(
                    "Invalid XML File",
                    f"The selected file is not a valid Rekordbox collection XML.\n\n"
                    f"Error: {validation_result.error}\n\n"
                    f"Please select a valid XML file exported from Rekordbox."
                )
                return
            
            # Validate XML content
            try:
                playlists = self.xml_parser.get_playlists(file_path)
                if not playlists:
                    self.show_error_dialog(
                        "No Playlists Found",
                        "The XML file does not contain any playlists.\n\n"
                        "Please ensure you exported a collection with playlists from Rekordbox."
                    )
                    return
                
                # Success - load playlists
                self.xml_path = file_path
                self.recent_files_manager.add_recent_file(file_path)
                self.load_playlists(playlists)
                self.update_ui_state()
                
            except Exception as e:
                self.show_error_dialog(
                    "Error Loading XML",
                    f"An error occurred while loading the XML file:\n\n{str(e)}\n\n"
                    f"Please check that the file is a valid Rekordbox collection XML."
                )
                logging.error(f"Error loading XML: {e}", exc_info=True)
    ```
  - **Validation Details**:
    - Check file exists
    - Check file is readable
    - Check XML structure (root element, required elements)
    - Check XML content (playlists exist)
  - **Error Messages**: Clear, actionable error messages
  - **Edge Cases**:
    - File doesn't exist: Show error, allow retry
    - File is corrupted: Show error, suggest re-export
    - File has no playlists: Show error, explain requirement
    - File is very large (> 100MB): Show warning, allow continue

- **Step 4: Mode Selection**
  - **Action**: User selects Single or Batch mode
  - **UI Elements**:
    - Radio buttons for mode selection
    - Description text for each mode
    - Mode-specific UI elements appear/disappear
  - **Implementation**:
    ```python
    def init_mode_selection(self):
        """Initialize mode selection UI"""
        mode_group = QGroupBox("Processing Mode")
        mode_layout = QVBoxLayout()
        
        # Single mode
        self.mode_single = QRadioButton("Single Playlist")
        self.mode_single.setChecked(True)  # Default
        self.mode_single.toggled.connect(self.on_mode_changed)
        mode_layout.addWidget(self.mode_single)
        
        single_desc = QLabel(
            "Process one playlist at a time. Best for focused work on a specific playlist."
        )
        single_desc.setWordWrap(True)
        single_desc.setStyleSheet("color: gray; font-size: 11px;")
        mode_layout.addWidget(single_desc)
        
        # Batch mode
        self.mode_batch = QRadioButton("Batch (Multiple Playlists)")
        self.mode_batch.toggled.connect(self.on_mode_changed)
        mode_layout.addWidget(self.mode_batch)
        
        batch_desc = QLabel(
            "Process multiple playlists in one operation. Best for processing entire collections."
        )
        batch_desc.setWordWrap(True)
        batch_desc.setStyleSheet("color: gray; font-size: 11px;")
        mode_layout.addWidget(batch_desc)
        
        mode_group.setLayout(mode_layout)
        return mode_group
    
    def on_mode_changed(self):
        """Handle mode selection change"""
        if self.mode_single.isChecked():
            self.show_single_mode_ui()
        else:
            self.show_batch_mode_ui()
    ```
  - **State Persistence**: Save mode preference
  - **Edge Cases**:
    - User switches mode mid-selection: Clear playlist selection
    - User switches mode with results: Warn about losing results

- **Step 5: Playlist Selection**
  - **Action**: User selects playlist(s) from dropdown/list
  - **UI Elements**:
    - ComboBox for single mode
    - ListWidget with checkboxes for batch mode
    - Playlist count display
    - Search/filter for large lists
  - **Implementation**:
    ```python
    def load_playlists(self, playlists: List[str]):
        """Load playlists into UI"""
        if self.mode_single.isChecked():
            # Single mode: ComboBox
            self.playlist_combo.clear()
            self.playlist_combo.addItems(playlists)
            self.playlist_combo.setCurrentIndex(0)  # Select first
        else:
            # Batch mode: ListWidget with checkboxes
            self.playlist_list.clear()
            for playlist in playlists:
                item = QListWidgetItem(playlist)
                item.setCheckState(Qt.Checked)  # Default: all selected
                self.playlist_list.addItem(item)
            
            # Update count
            self.update_playlist_count()
    
    def get_selected_playlists(self) -> List[str]:
        """Get currently selected playlists"""
        if self.mode_single.isChecked():
            current = self.playlist_combo.currentText()
            return [current] if current else []
        else:
            selected = []
            for i in range(self.playlist_list.count()):
                item = self.playlist_list.item(i)
                if item.checkState() == Qt.Checked:
                    selected.append(item.text())
            return selected
    ```
  - **Edge Cases**:
    - No playlists: Disable start button, show message
    - Very large playlist list (> 100): Add search/filter
    - User deselects all: Disable start button

- **Step 6: Start Processing**
  - **Action**: User clicks "Start" button
  - **System Response**:
    - Validate inputs
    - Show progress dialog
    - Start background processing thread
    - Update UI state (disable controls)
  - **Implementation**:
    ```python
    def on_start_processing(self):
        """Start processing workflow"""
        # Validate inputs
        if not self.xml_path:
            self.show_error("Please select an XML file")
            return
        
        selected_playlists = self.get_selected_playlists()
        if not selected_playlists:
            self.show_error("Please select at least one playlist")
            return
        
        # Check network connectivity (optional)
        if not self.check_network_connectivity():
            response = self.show_network_warning()
            if response != QMessageBox.Yes:
                return
        
        # Show progress dialog
        self.progress_dialog = ProcessingDialog(self)
        self.progress_dialog.cancelled.connect(self.on_processing_cancelled)
        self.progress_dialog.show()
        
        # Disable UI controls
        self.set_processing_state(True)
        
        # Start processing thread
        if self.mode_single.isChecked():
            self.processor_thread = SingleProcessingThread(
                self.xml_path,
                selected_playlists[0],
                self
            )
        else:
            self.processor_thread = BatchProcessingThread(
                self.xml_path,
                selected_playlists,
                self
            )
        
        # Connect signals
        self.processor_thread.progress.connect(self.on_progress_update)
        self.processor_thread.completed.connect(self.on_processing_complete)
        self.processor_thread.error.connect(self.on_processing_error)
        self.processor_thread.finished.connect(self.on_processing_finished)
        
        # Start thread
        self.processor_thread.start()
    ```
  - **Progress Updates**: Update dialog with current track, percentage, ETA
  - **Cancellation**: Allow user to cancel, save partial results
  - **Error Handling**: Catch errors, show in dialog, allow retry
  - **Edge Cases**:
    - Network interruption: Use cache, show warning
    - Processing error: Show error, allow retry for failed tracks
    - User cancels: Save partial results, restore UI

- **Step 7: Results Display**
  - **Action**: Processing completes, results displayed
  - **UI Elements**:
    - Results table with all tracks
    - Summary statistics (total, matched, unmatched)
    - Filter controls
    - Export button
  - **Implementation**: Already exists in results_view.py
  - **Enhancements**:
    - Show processing summary
    - Highlight unmatched tracks
    - Show match confidence distribution
  - **Edge Cases**:
    - No matches found: Show helpful message, suggest alternatives
    - All matches: Show success message
    - Partial matches: Show summary with breakdown

- **Step 8: Export Results**
  - **Action**: User clicks "Export" button
  - **System Response**:
    - Show export dialog
    - User selects format and options
    - Export file created
    - Show success message
  - **Implementation**: Already exists in export_dialog.py
  - **Enhancements**:
    - Remember last export location
    - Show export preview
    - Validate export before writing
  - **Edge Cases**:
    - Export location not writable: Show error, suggest alternative
    - Disk full: Check space, show error
    - File exists: Ask for overwrite confirmation

### Workflow 2: Repeat Run - Complete Implementation

**1.3.2.4 Complete Repeat Run Flow**
- **Step 1: Application Launch (Returning User)**
  - **Action**: User launches app (not first run)
  - **System Response**:
    - Restore window geometry
    - Restore last XML file (if exists)
    - Restore last playlist selection
    - Restore mode preference
    - Show recent files menu
  - **Implementation**:
    ```python
    def restore_state(self):
        """Restore application state"""
        settings = QSettings()
        
        # Restore window geometry
        geometry = settings.value("geometry")
        if geometry:
            self.restoreGeometry(geometry)
        
        # Restore window state (maximized, etc.)
        window_state = settings.value("windowState")
        if window_state:
            self.restoreState(window_state)
        
        # Restore last XML file
        last_xml = settings.value("last_xml")
        if last_xml and Path(last_xml).exists():
            self.xml_path = last_xml
            try:
                playlists = self.xml_parser.get_playlists(last_xml)
                self.load_playlists(playlists)
                
                # Restore last playlist
                last_playlist = settings.value("last_playlist")
                if last_playlist and last_playlist in playlists:
                    if self.mode_single.isChecked():
                        index = self.playlist_combo.findText(last_playlist)
                        if index >= 0:
                            self.playlist_combo.setCurrentIndex(index)
                    else:
                        # Find and check in batch mode
                        for i in range(self.playlist_list.count()):
                            item = self.playlist_list.item(i)
                            if item.text() == last_playlist:
                                item.setCheckState(Qt.Checked)
                                break
            except Exception as e:
                logging.warning(f"Could not restore last XML: {e}")
        
        # Restore mode
        last_mode = settings.value("last_mode", 0, type=int)
        if last_mode == 0:
            self.mode_single.setChecked(True)
        else:
            self.mode_batch.setChecked(True)
        
        # Update UI
        self.update_ui_state()
    ```

- **Step 2: Quick Start with Recent File**
  - **Action**: User selects recent file from menu
  - **System Response**:
    - Load XML file
    - Load playlists
    - Restore last playlist selection
    - Ready to process
  - **Implementation**:
    ```python
    def create_recent_files_menu(self):
        """Create recent files menu"""
        recent_files = self.recent_files_manager.get_recent_files()
        
        self.recent_menu = QMenu("Recent Files", self)
        if not recent_files:
            action = self.recent_menu.addAction("No recent files")
            action.setEnabled(False)
        else:
            for file_path in recent_files[:10]:  # Last 10
                if Path(file_path).exists():
                    action = self.recent_menu.addAction(
                        Path(file_path).name,
                        lambda checked, path=file_path: self.load_recent_file(path)
                    )
                    action.setToolTip(file_path)
                else:
                    # File no longer exists - remove from list
                    self.recent_files_manager.remove_recent_file(file_path)
        
        return self.recent_menu
    
    def load_recent_file(self, file_path: str):
        """Load recent file"""
        if not Path(file_path).exists():
            self.show_error(f"File no longer exists: {file_path}")
            self.recent_files_manager.remove_recent_file(file_path)
            return
        
        # Validate and load
        try:
            playlists = self.xml_parser.get_playlists(file_path)
            self.xml_path = file_path
            self.load_playlists(playlists)
            self.update_ui_state()
        except Exception as e:
            self.show_error(f"Error loading file: {e}")
    ```

- **Step 3: Quick Process**
  - **Action**: User clicks "Start" with restored settings
  - **System Response**: Same as first run processing
  - **Optimization**: Skip validation if settings unchanged

### Workflow 3: Review/Refine - Complete Implementation

**1.3.3.4 Complete Review/Refine Flow**
- **Step 1: Review Initial Results**
  - **Action**: User reviews processing results
  - **UI Elements**:
    - Results table
    - Summary statistics
    - Match quality indicators
  - **Implementation**: Already exists
  - **Enhancements**:
    - Color-code match confidence
    - Show match quality distribution chart
    - Highlight potential issues

- **Step 2: Apply Filters**
  - **Action**: User applies filters to refine results
  - **Filters Available**:
    - Search (title, artist)
    - Confidence threshold
    - Year range
    - BPM range
    - Key filter
    - Match status (matched/unmatched)
  - **Implementation**:
    ```python
    def apply_filters(self, filters: Dict[str, Any]) -> List[TrackResult]:
        """Apply filters to results"""
        filtered = self.all_results
        
        # Search filter
        if filters.get("search"):
            search_term = filters["search"].lower()
            filtered = [
                r for r in filtered
                if search_term in r.title.lower() or search_term in r.artist.lower()
            ]
        
        # Confidence filter
        if filters.get("min_confidence") is not None:
            min_conf = filters["min_confidence"]
            filtered = [r for r in filtered if r.match_score >= min_conf]
        
        # Year filter
        if filters.get("year_min") is not None:
            year_min = filters["year_min"]
            filtered = [r for r in filtered if r.beatport_year and r.beatport_year >= year_min]
        if filters.get("year_max") is not None:
            year_max = filters["year_max"]
            filtered = [r for r in filtered if r.beatport_year and r.beatport_year <= year_max]
        
        # BPM filter
        if filters.get("bpm_min") is not None:
            bpm_min = filters["bpm_min"]
            filtered = [r for r in filtered if r.beatport_bpm and r.beatport_bpm >= bpm_min]
        if filters.get("bpm_max") is not None:
            bpm_max = filters["bpm_max"]
            filtered = [r for r in filtered if r.beatport_bpm and r.beatport_bpm <= bpm_max]
        
        # Key filter
        if filters.get("key"):
            key_filter = filters["key"]
            filtered = [r for r in filtered if r.beatport_key == key_filter]
        
        # Match status filter
        if filters.get("match_status") == "matched":
            filtered = [r for r in filtered if r.matched]
        elif filters.get("match_status") == "unmatched":
            filtered = [r for r in filtered if not r.matched]
        
        return filtered
    ```
  - **Performance**: Debounce filter application for large result sets
  - **Edge Cases**:
    - No results match filter: Show message, suggest clearing filters
    - Filter too restrictive: Show warning

- **Step 3: Review Candidates**
  - **Action**: User clicks on track to review candidates
  - **System Response**: Show candidate dialog with alternatives
  - **Implementation**: Already exists in candidate_dialog.py
  - **Enhancements**:
    - Show match scores for all candidates
    - Allow manual selection
    - Update result when candidate selected

- **Step 4: Re-export Filtered Results**
  - **Action**: User exports filtered results
  - **System Response**: Export only filtered results
  - **Implementation**: Already exists
  - **Enhancements**:
    - Show count of filtered vs total
    - Warn if exporting filtered subset
    - Option to export all or filtered

### Workflow 4: Past Searches - Complete Implementation

**1.3.4.5 Complete Past Searches Flow**
- **Step 1: Load Past Search**
  - **Action**: User clicks on past search in history tab
  - **System Response**:
    - Load CSV file
    - Parse results
    - Display in table
    - Show metadata (date, playlist, XML path)
  - **Implementation**: Already exists in history_view.py
  - **Enhancements**:
    - Validate CSV structure
    - Handle missing columns gracefully
    - Show loading progress for large files

- **Step 2: Apply Filters to Past Results**
  - **Action**: User applies filters to past search results
  - **System Response**: Same as current results filtering
  - **Implementation**: Reuse filter logic from results_view

- **Step 3: Re-run Processing**
  - **Action**: User clicks "Re-run" button
  - **System Response**:
    - Check if original XML exists
    - Load original XML
    - Start processing with original settings
  - **Implementation**: See code example in document
  - **Edge Cases**:
    - Original XML not found: Show error, allow manual selection
    - Original XML changed: Warn user, allow continue

### Workflow 5: Update - Complete Implementation

**1.3.5.5 Complete Update Flow**
- **Step 1: Check for Updates**
  - **Action**: App checks for updates (automatic or manual)
  - **System Response**:
    - Fetch appcast from server
    - Compare versions
    - Show update dialog if newer version available
  - **Implementation**: See Step 5 for full implementation
  - **Timing**:
    - Automatic: On app launch (if enabled, not too recent)
    - Manual: User clicks "Check for Updates"

- **Step 2: Update Dialog**
  - **Action**: Update available, dialog shown
  - **UI Elements**:
    - Current version → New version
    - Release notes
    - "Download & Install" button
    - "Remind me later" button
    - "Skip this version" button
  - **Implementation**: See Step 5

- **Step 3: Download and Install**
  - **Action**: User clicks "Download & Install"
  - **System Response**:
    - Download update package
    - Verify signature
    - Install update
    - Relaunch app
  - **Implementation**: Handled by Sparkle/WinSparkle

- **Step 4: Post-Update**
  - **Action**: App relaunches after update
  - **System Response**:
    - Show update success message
    - Restore previous state
    - Check for data migration needs

## Error Scenarios and Recovery

### Error Scenario 1: XML File Issues
- **Error**: Invalid XML structure
- **Recovery**: 
  - Show clear error message
  - Explain what's wrong
  - Suggest re-exporting from Rekordbox
  - Allow user to select different file
- **Implementation**: See XML validation code above

### Error Scenario 2: Network Issues
- **Error**: Network timeout during processing
- **Recovery**:
  - Use cached data if available
  - Show warning about network issue
  - Allow retry for failed tracks
  - Continue with available data
- **Implementation**:
  ```python
  def handle_network_error(self, track: Track, error: Exception):
      """Handle network error during processing"""
      logging.warning(f"Network error for {track.title}: {error}")
      
      # Try cache
      cached_result = self.cache_manager.get_cached(track)
      if cached_result:
          return cached_result
      
      # Mark as failed, continue
      return create_unmatched_result(track, error="Network error")
  ```

### Error Scenario 3: Processing Interruption
- **Error**: User cancels or app crashes during processing
- **Recovery**:
  - Save partial results
  - Allow resume from checkpoint
  - Show summary of completed vs remaining
- **Implementation**:
  ```python
  def save_checkpoint(self, playlist_name: str, completed_tracks: int, results: List[TrackResult]):
      """Save processing checkpoint"""
      checkpoint = {
          "playlist": playlist_name,
          "completed": completed_tracks,
          "results": [r.to_dict() for r in results],
          "timestamp": datetime.now().isoformat()
      }
      checkpoint_path = AppPaths.cache_dir() / f"checkpoint_{playlist_name}.json"
      checkpoint_path.write_text(json.dumps(checkpoint, indent=2))
  ```

## Testing Scenarios

### Test Scenario 1: First Run Complete Flow
1. Launch app (first time)
2. Complete onboarding
3. Select XML file
4. Select playlist
5. Start processing
6. Review results
7. Export results
- **Expected**: All steps complete successfully
- **Success Criteria**: No errors, results accurate, export works

### Test Scenario 2: Repeat Run Quick Start
1. Launch app (returning user)
2. Recent file auto-loaded
3. Click Start
4. Review results
5. Export
- **Expected**: Faster workflow, state restored
- **Success Criteria**: < 2 minutes to export

### Test Scenario 3: Filter and Refine
1. Load results
2. Apply multiple filters
3. Review filtered results
4. Export filtered subset
- **Expected**: Filters work correctly, export only filtered
- **Success Criteria**: Filters accurate, export correct

### Test Scenario 4: Error Recovery
1. Start processing
2. Simulate network error
3. Verify recovery
4. Complete processing
- **Expected**: Graceful error handling, processing continues
- **Success Criteria**: No crashes, partial results saved

## Performance Benchmarks

### Workflow Performance Targets
- **First Run**: < 5 minutes to first export
- **Repeat Run**: < 2 minutes to export
- **Filter Application**: < 200ms for 1000 rows
- **Export**: < 5 seconds for 1000 tracks
- **State Restoration**: < 1 second

## References

- Main document: `../01_Product_Requirements_and_Definition.md`
- Related: Step 1.2 (Personas), Step 1.8 (UX Requirements), Step 5 (Updates)
- Onboarding: Step 9.4
- Update System: Step 5

