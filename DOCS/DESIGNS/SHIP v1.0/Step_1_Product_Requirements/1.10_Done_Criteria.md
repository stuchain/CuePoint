# Implementation Step 1.10: "Done" Criteria for v1.0

## Implementation Overview
**What We're Building**: Quality gates, testing infrastructure, and validation checks to ensure v1.0 meets all "done" criteria.

## Implementation Tasks

### Task 1.10.1: Implement Build Criteria

**What to Build**
- CI build configuration
- Signing verification
- Artifact validation
- Build success gates

**Implementation Details**

**1.10.1.1 CI Build Configuration**
- **File to Create**: `.github/workflows/build.yml` (Step 2)
- **Implementation**: See Step 2 for full CI configuration
- **Purpose**: Automated builds
- **Success Criteria**:
  - ✅ Builds produce signed artifacts
  - ✅ Builds complete successfully
  - ✅ Artifacts are valid

**1.10.1.2 Signing Verification**
- **File to Create**: `scripts/verify_signing.sh` and `scripts/verify_signing.ps1`
- **Implementation**:
  ```bash
  # macOS signing verification
  #!/bin/bash
  APP_PATH="$1"
  
  # Verify code signing
  codesign --verify --deep --strict --verbose=2 "$APP_PATH"
  if [ $? -ne 0 ]; then
      echo "ERROR: Code signing verification failed"
      exit 1
  fi
  
  # Verify Gatekeeper
  spctl -a -vv --type execute "$APP_PATH"
  if [ $? -ne 0 ]; then
      echo "ERROR: Gatekeeper verification failed"
      exit 1
  fi
  
  echo "Signing verification passed"
  ```
- **Purpose**: Verify signing in CI
- **Integration**: CI build pipeline

**1.10.1.3 Artifact Validation**
- **File to Create**: `scripts/validate_artifacts.py`
- **Implementation**:
  ```python
  """Validate build artifacts"""
  from pathlib import Path
  import subprocess
    
  def validate_macos_dmg(dmg_path: Path) -> bool:
      """Validate macOS DMG"""
      # Check DMG exists
      if not dmg_path.exists():
          return False
      
      # Check DMG can be mounted
      # Verify app bundle structure
      # Verify signing
      return True
    
  def validate_windows_installer(installer_path: Path) -> bool:
      """Validate Windows installer"""
      # Check installer exists
      # Verify signing
      # Check installer structure
      return True
  ```
- **Purpose**: Validate artifacts before release
- **Integration**: CI release pipeline

### Task 1.10.2: Implement Release Criteria

**What to Build**
- GitHub Release creation
- Update metadata generation
- Release validation

**Implementation Details**

**1.10.2.1 GitHub Release Creation**
- **File to Create**: `.github/workflows/release.yml` (Step 2)
- **Implementation**: See Step 2 for release workflow
- **Purpose**: Automated release publishing
- **Success Criteria**:
  - ✅ Releases published to GitHub
  - ✅ Artifacts uploaded
  - ✅ Release notes included

**1.10.2.2 Update Metadata Generation**
- **File to Create**: `scripts/generate_appcast.py` (Step 5)
- **Implementation**: See Step 5 for appcast generation
- **Purpose**: Generate update feeds
- **Success Criteria**:
  - ✅ Appcast XML generated
  - ✅ Metadata includes version, size, signature
  - ✅ Appcast published to GitHub Pages

### Task 1.10.3: Implement Update Criteria

**What to Build**
- Update checker integration
- Update prompt UI
- Update installation flow

**Implementation Details**

**1.10.3.1 Update Checker Integration**
- **File to Create**: `SRC/cuepoint/services/update_checker.py` (Step 5)
- **Implementation**: See Step 5 for update system
- **Purpose**: Check for updates
- **Success Criteria**:
  - ✅ Update check works
  - ✅ Update prompt appears
  - ✅ Update installation works

### Task 1.10.4: Implement Repository Criteria

**What to Build**
- Large file detection
- CI gate for large files
- Repository hygiene checks

**Implementation Details**

**1.10.4.1 Large File Detection**
- **File to Create**: `.github/workflows/large-file-check.yml`
- **Implementation**:
  ```yaml
  name: Large File Check
  on: [push, pull_request]
  jobs:
    check:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v3
        - name: Check for large files
          run: |
            find . -type f -size +50M ! -path "./.git/*" | while read file; do
              echo "ERROR: Large file detected: $file"
              exit 1
            done
  ```
- **Purpose**: Prevent large file commits
- **Integration**: Required CI check

**1.10.4.2 Repository Hygiene**
- **File to Modify**: `.gitignore`
- **Implementation**:
  ```gitignore
  # Build artifacts
  build/
  dist/
  *.spec
  
  # Python
  .venv/
  __pycache__/
  *.pyc
  
  # IDE
  .vscode/
  .idea/
  
  # OS
  .DS_Store
  Thumbs.db
  ```
- **Purpose**: Keep repository clean
- **Verification**: CI checks

## Implementation Checklist

### Build Criteria
- [ ] CI builds produce signed artifacts (Step 2)
- [ ] Signing verification works
- [ ] Artifact validation works
- [ ] Build gates pass

### Release Criteria
- [ ] Releases published to GitHub (Step 2)
- [ ] Update metadata generated (Step 5)
- [ ] Release validation works

### Update Criteria
- [ ] Update checker works (Step 5)
- [ ] Update prompt appears
- [ ] Update installation works

### Repository Criteria
- [ ] Large file check implemented
- [ ] Repository hygiene maintained
- [ ] CI gates pass

## Files to Create/Modify

### New Files
1. `.github/workflows/build.yml` - Build workflow (Step 2)
2. `.github/workflows/release.yml` - Release workflow (Step 2)
3. `.github/workflows/large-file-check.yml` - Large file check
4. `scripts/verify_signing.sh` - macOS signing verification
5. `scripts/verify_signing.ps1` - Windows signing verification
6. `scripts/validate_artifacts.py` - Artifact validation

### Files to Modify
1. `.gitignore` - Repository hygiene
2. `SRC/cuepoint/services/update_checker.py` - Update checking (Step 5)
3. `scripts/generate_appcast.py` - Update metadata (Step 5)

## Implementation Dependencies

### Prerequisites
- Step 1.1-1.9: All product requirements defined
- Step 2: Build system (implements build/release)
- Step 3-4: Packaging (produces artifacts)
- Step 5: Update system (implements updates)

### Enables
- Step 7: QA and testing (validates these criteria)

## Success Criteria

### Build
- ✅ CI builds produce signed artifacts
- ✅ All builds pass verification
- ✅ Artifacts are valid

### Release
- ✅ Releases published successfully
- ✅ Update metadata generated
- ✅ Release notes included

### Update
- ✅ Update check works
- ✅ Update prompt appears
- ✅ Update installation works

### Repository
- ✅ No large files committed
- ✅ Repository hygiene maintained
- ✅ CI gates pass

## Next Implementation Steps

After completing Step 1.10:
1. **Step 2**: Build system (implements build/release)
2. **Step 5**: Update system (implements updates)
3. **Step 7**: QA testing (validates criteria)

## Detailed Done Criteria Implementation

### Build Criteria - Complete Implementation

**1.10.1.4 Complete Signing Verification Scripts**
- **macOS Signing Verification**:
  ```bash
  #!/bin/bash
  # scripts/verify_signing.sh
  set -e
  
  APP_PATH="${1:-dist/CuePoint.app}"
  DMG_PATH="${2:-}"
  
  echo "Verifying code signing for: $APP_PATH"
  
  # Verify app bundle signing
  echo "Checking app bundle signature..."
  codesign --verify --deep --strict --verbose=2 "$APP_PATH"
  if [ $? -ne 0 ]; then
      echo "ERROR: Code signing verification failed"
      exit 1
  fi
  
  # Verify Gatekeeper
  echo "Checking Gatekeeper acceptance..."
  spctl -a -vv --type execute "$APP_PATH"
  if [ $? -ne 0 ]; then
      echo "ERROR: Gatekeeper verification failed"
      exit 1
  fi
  
  # Check entitlements
  echo "Checking entitlements..."
  codesign -d --entitlements - "$APP_PATH" > /dev/null
  if [ $? -ne 0 ]; then
      echo "WARNING: Could not verify entitlements"
  fi
  
  # If DMG provided, verify notarization
  if [ -n "$DMG_PATH" ] && [ -f "$DMG_PATH" ]; then
      echo "Verifying DMG notarization..."
      spctl -a -vv -t install "$DMG_PATH"
      if [ $? -ne 0 ]; then
          echo "ERROR: DMG notarization verification failed"
          exit 1
      fi
      
      # Check stapled ticket
      stapler validate "$DMG_PATH"
      if [ $? -ne 0 ]; then
          echo "WARNING: Notarization ticket not stapled"
      fi
  fi
  
  echo "All signing verifications passed!"
  ```

- **Windows Signing Verification**:
  ```powershell
  # scripts/verify_signing.ps1
  param(
      [string]$ExePath = "dist\CuePoint.exe",
      [string]$InstallerPath = "dist\CuePoint-v1.0.0-windows-x64-setup.exe"
  )
  
  $errors = @()
  
  # Verify executable signing
  if (Test-Path $ExePath) {
      Write-Host "Verifying executable signature: $ExePath"
      & signtool verify /pa /v $ExePath
      if ($LASTEXITCODE -ne 0) {
          $errors += "Executable signature verification failed"
      }
  } else {
      $errors += "Executable not found: $ExePath"
  }
  
  # Verify installer signing
  if (Test-Path $InstallerPath) {
      Write-Host "Verifying installer signature: $InstallerPath"
      & signtool verify /pa /v $InstallerPath
      if ($LASTEXITCODE -ne 0) {
          $errors += "Installer signature verification failed"
      }
  } else {
      $errors += "Installer not found: $InstallerPath"
  }
  
  if ($errors.Count -gt 0) {
      Write-Error "Signing verification failed:"
      $errors | ForEach-Object { Write-Error $_ }
      exit 1
  }
  
  Write-Host "All signing verifications passed!"
  ```

**1.10.1.5 Complete Artifact Validation**
- **Comprehensive Artifact Validator**:
  ```python
  # scripts/validate_artifacts.py
  """Comprehensive artifact validation"""
  import subprocess
  import tempfile
  from pathlib import Path
  from typing import List, Tuple
  import platform
  
  class ArtifactValidator:
      """Validate build artifacts"""
      
      def __init__(self):
          self.errors = []
          self.warnings = []
      
      def validate_all(self, artifacts_dir: Path) -> Tuple[bool, List[str]]:
          """Validate all artifacts in directory"""
          self.errors = []
          self.warnings = []
          
          # Find artifacts
          dmgs = list(artifacts_dir.glob("*.dmg"))
          installers = list(artifacts_dir.glob("*-setup.exe"))
          
          # Validate macOS DMG
          for dmg in dmgs:
              self.validate_macos_dmg(dmg)
          
          # Validate Windows installer
          for installer in installers:
              self.validate_windows_installer(installer)
          
          return len(self.errors) == 0, self.errors
      
      def validate_macos_dmg(self, dmg_path: Path) -> bool:
          """Validate macOS DMG"""
          print(f"Validating macOS DMG: {dmg_path.name}")
          
          # Check DMG exists
          if not dmg_path.exists():
              self.errors.append(f"DMG not found: {dmg_path}")
              return False
          
          # Check DMG size (not empty)
          if dmg_path.stat().st_size < 1024 * 1024:  # < 1MB
              self.errors.append(f"DMG appears to be empty: {dmg_path}")
              return False
          
          # Try to mount DMG
          with tempfile.TemporaryDirectory() as mount_point:
              result = subprocess.run(
                  ["hdiutil", "attach", str(dmg_path), "-mountpoint", mount_point],
                  capture_output=True,
                  text=True
              )
              
              if result.returncode != 0:
                  self.errors.append(f"Failed to mount DMG: {result.stderr}")
                  return False
              
              try:
                  # Check app bundle exists
                  app_path = Path(mount_point) / "CuePoint.app"
                  if not app_path.exists():
                      self.errors.append("App bundle not found in DMG")
                      return False
                  
                  # Check app bundle structure
                  required_paths = [
                      "Contents/MacOS/CuePoint",
                      "Contents/Info.plist",
                      "Contents/Resources"
                  ]
                  for req_path in required_paths:
                      if not (app_path / req_path).exists():
                          self.errors.append(f"Missing required path: {req_path}")
                  
                  # Check Applications symlink
                  apps_link = Path(mount_point) / "Applications"
                  if not apps_link.exists():
                      self.warnings.append("Applications symlink not found")
                  
                  # Verify signing
                  result = subprocess.run(
                      ["codesign", "--verify", "--deep", "--strict", str(app_path)],
                      capture_output=True,
                      text=True
                  )
                  if result.returncode != 0:
                      self.errors.append(f"App bundle not signed: {result.stderr}")
                  
              finally:
                  # Unmount
                  subprocess.run(["hdiutil", "detach", mount_point], check=False)
          
          return len(self.errors) == 0
      
      def validate_windows_installer(self, installer_path: Path) -> bool:
          """Validate Windows installer"""
          print(f"Validating Windows installer: {installer_path.name}")
          
          # Check installer exists
          if not installer_path.exists():
              self.errors.append(f"Installer not found: {installer_path}")
              return False
          
          # Check installer size
          if installer_path.stat().st_size < 1024 * 1024:  # < 1MB
              self.errors.append(f"Installer appears to be empty: {installer_path}")
              return False
          
          # Verify signing (if on Windows)
          if platform.system() == "Windows":
              result = subprocess.run(
                  ["signtool", "verify", "/pa", "/v", str(installer_path)],
                  capture_output=True,
                  text=True
              )
              if result.returncode != 0:
                  self.errors.append(f"Installer not signed: {result.stderr}")
          
          return len(self.errors) == 0
  
  if __name__ == "__main__":
      import sys
      artifacts_dir = Path(sys.argv[1]) if len(sys.argv) > 1 else Path("dist")
      validator = ArtifactValidator()
      valid, errors = validator.validate_all(artifacts_dir)
      
      if valid:
          print("All artifacts validated successfully!")
          sys.exit(0)
      else:
          print("Validation failed:")
          for error in errors:
              print(f"  ERROR: {error}")
          sys.exit(1)
  ```

### Release Criteria - Complete Implementation

**1.10.2.3 Release Validation Checklist**
- **Pre-Release Validation**:
  ```python
  # scripts/validate_release.py
  """Validate release before publishing"""
  from pathlib import Path
  import json
  import subprocess
  
  def validate_release(version: str) -> tuple[bool, list[str]]:
      """Validate release before publishing"""
      errors = []
      
      # Check version format
      import re
      if not re.match(r'^\d+\.\d+\.\d+$', version):
          errors.append(f"Invalid version format: {version}")
      
      # Check artifacts exist
      artifacts_dir = Path("dist")
      dmgs = list(artifacts_dir.glob(f"*{version}*.dmg"))
      installers = list(artifacts_dir.glob(f"*{version}*-setup.exe"))
      
      if not dmgs:
          errors.append("macOS DMG not found")
      if not installers:
          errors.append("Windows installer not found")
      
      # Check artifacts are signed
      # (use verify_signing scripts)
      
      # Check release notes exist
      release_notes = Path("RELEASE_NOTES.md")
      if not release_notes.exists():
          errors.append("RELEASE_NOTES.md not found")
      
      # Check git tag exists
      result = subprocess.run(
          ["git", "tag", "-l", f"v{version}"],
          capture_output=True,
          text=True
      )
      if not result.stdout.strip():
          errors.append(f"Git tag v{version} not found")
      
      return len(errors) == 0, errors
  ```

**1.10.2.4 Update Metadata Validation**
- **Appcast Validation**:
  ```python
  # scripts/validate_appcast.py
  """Validate appcast XML"""
  from pathlib import Path
  import xml.etree.ElementTree as ET
  
  def validate_appcast(appcast_path: Path) -> tuple[bool, list[str]]:
      """Validate appcast XML structure"""
      errors = []
      
      if not appcast_path.exists():
          errors.append(f"Appcast not found: {appcast_path}")
          return False, errors
      
      try:
          tree = ET.parse(appcast_path)
          root = tree.getroot()
          
          # Check root element
          if root.tag != "rss":
              errors.append("Appcast root must be 'rss'")
          
          # Check channel
          channel = root.find("channel")
          if channel is None:
              errors.append("Appcast must have 'channel' element")
          else:
              # Check items
              items = channel.findall("item")
              if not items:
                  errors.append("Appcast must have at least one 'item'")
              
              for item in items:
                  # Check required fields
                  required = ["title", "pubDate", "enclosure"]
                  for req in required:
                      if item.find(req) is None:
                          errors.append(f"Item missing required field: {req}")
                  
                  # Check enclosure attributes
                  enclosure = item.find("enclosure")
                  if enclosure is not None:
                      required_attrs = ["url", "length", "type"]
                      for attr in required_attrs:
                          if attr not in enclosure.attrib:
                              errors.append(f"Enclosure missing attribute: {attr}")
      
      except ET.ParseError as e:
          errors.append(f"Appcast XML parse error: {e}")
      
      return len(errors) == 0, errors
  ```

### Update Criteria - Complete Implementation

**1.10.3.2 Update Flow Validation**
- **Update System Tests**:
  ```python
  # tests/acceptance/test_updates.py
  """Test update system"""
  import pytest
  from pathlib import Path
  
  def test_update_checker_works():
      """Test update checker can fetch appcast"""
      # Test update checker service
      # Verify appcast can be fetched
      # Verify version comparison works
      pass
  
  def test_update_dialog_appears():
      """Test update dialog appears when update available"""
      # Simulate update available
      # Verify dialog appears
      # Verify dialog content correct
      pass
  
  def test_update_installation():
      """Test update installation flow"""
      # Test update download
      # Test update installation
      # Test app relaunch
      pass
  ```

### Repository Criteria - Complete Implementation

**1.10.4.3 Enhanced Large File Check**
- **Complete Large File Check Workflow**:
  ```yaml
  # .github/workflows/large-file-check.yml
  name: Large File Check
  on: [push, pull_request]
  
  jobs:
    check:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        
        - name: Check for large files
          run: |
            MAX_SIZE=52428800  # 50MB
            LARGE_FILES=()
            
            # Find large files
            while IFS= read -r file; do
              size=$(stat -c%s "$file" 2>/dev/null || echo 0)
              if [ "$size" -gt "$MAX_SIZE" ]; then
                LARGE_FILES+=("$file ($(numfmt --to=iec-i --suffix=B $size))")
              fi
            done < <(find . -type f ! -path "./.git/*" ! -path "./.venv/*" ! -path "./node_modules/*" ! -path "./dist/*" ! -path "./build/*")
            
            if [ ${#LARGE_FILES[@]} -gt 0 ]; then
              echo "ERROR: Large files detected:"
              printf '%s\n' "${LARGE_FILES[@]}"
              echo ""
              echo "Files larger than 50MB should not be committed to the repository."
              echo "Consider using Git LFS or storing large files elsewhere."
              exit 1
            fi
            
            echo "No large files detected. ✓"
  ```

**1.10.4.4 Repository Hygiene Checks**
- **Complete .gitignore**:
  ```gitignore
  # Build artifacts
  build/
  dist/
  *.spec
  *.pyc
  __pycache__/
  
  # Python
  .venv/
  venv/
  env/
  *.egg-info/
  .pytest_cache/
  .coverage
  htmlcov/
  
  # IDE
  .vscode/
  .idea/
  *.swp
  *.swo
  *~
  
  # OS
  .DS_Store
  Thumbs.db
  desktop.ini
  
  # Logs
  *.log
  logs/
  
  # Temporary files
  *.tmp
  *.temp
  .tmp/
  
  # Certificates and secrets
  *.p12
  *.pfx
  *.key
  *.pem
  secrets/
  .env
  
  # Test artifacts
  test_output/
  test_logs/
  
  # Documentation builds
  docs/_build/
  site/
  ```

## Quality Gates Implementation

**1.10.5 Complete Quality Gate System**
- **Quality Gate Workflow**:
  ```yaml
  # .github/workflows/quality-gates.yml
  name: Quality Gates
  on:
    pull_request:
      types: [opened, synchronize, reopened]
    push:
      branches: [main]
  
  jobs:
    quality-gates:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        
        - name: Run linting
          run: |
            pylint SRC/ --fail-under=8.0
        
        - name: Run type checking
          run: |
            mypy SRC/ --strict
        
        - name: Run tests
          run: |
            pytest tests/ -v --cov=SRC --cov-report=xml --cov-fail-under=80
        
        - name: Check for large files
          uses: ./.github/workflows/large-file-check.yml
        
        - name: Validate version consistency
          run: |
            python scripts/validate_version.py
  ```

## Success Metrics Tracking

**1.10.6 Metrics Collection**
- **Build Metrics**:
  - Build success rate
  - Build time
  - Artifact size
  - Signing success rate
  
- **Release Metrics**:
  - Release frequency
  - Release success rate
  - Update adoption rate
  
- **Repository Metrics**:
  - Large file incidents
  - CI failure rate
  - Code quality scores

**1.10.7 Complete Metrics Collection System**
- **Metrics Collection Implementation**:
  ```python
  # scripts/collect_metrics.py
  """Collect build and release metrics"""
  import json
  from datetime import datetime
  from pathlib import Path
  
  class MetricsCollector:
      """Collect and report metrics"""
      
      def collect_build_metrics(self) -> dict:
          """Collect build metrics"""
          return {
              "build_time": self.get_build_time(),
              "artifact_sizes": self.get_artifact_sizes(),
              "signing_status": self.get_signing_status(),
              "test_results": self.get_test_results()
          }
      
      def collect_release_metrics(self) -> dict:
          """Collect release metrics"""
          return {
              "release_time": datetime.now().isoformat(),
              "version": self.get_version(),
              "artifact_count": self.get_artifact_count(),
              "update_feed_generated": self.check_update_feed()
          }
  ```

## Complete Done Criteria Validation

**1.10.8 Pre-Release Validation Checklist**
- **Automated Checks**:
  ```python
  # scripts/pre_release_check.py
  """Pre-release validation checklist"""
  from pathlib import Path
  import subprocess
  
  def run_pre_release_checks() -> bool:
      """Run all pre-release validation checks"""
      checks = [
          ("Version consistency", check_version_consistency),
          ("Artifact signing", check_artifact_signing),
          ("Artifact validation", check_artifact_validation),
          ("Test coverage", check_test_coverage),
          ("Large files", check_large_files),
          ("Documentation", check_documentation),
      ]
      
      all_passed = True
      for name, check_func in checks:
          print(f"Checking {name}...")
          if not check_func():
              print(f"  FAILED: {name}")
              all_passed = False
          else:
              print(f"  PASSED: {name}")
      
      return all_passed
  ```

**1.10.9 Release Gate Implementation**
- **Release Gate Workflow**:
  ```yaml
  # .github/workflows/release-gate.yml
  name: Release Gate
  on:
    pull_request:
      types: [labeled]
      labels: [release-candidate]
  
  jobs:
    release-gate:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        
        - name: Run all quality gates
          run: |
            python scripts/pre_release_check.py
            python scripts/validate_version.py
            python scripts/validate_artifacts.py
        
        - name: Check test coverage
          run: |
            pytest --cov=SRC --cov-report=term-missing
            coverage report --fail-under=80
        
        - name: Check code quality
          run: |
            pylint SRC/ --fail-under=8.0
            mypy SRC/ --strict
  ```

## Done Criteria Acceptance Testing

**1.10.10 Acceptance Test Scenarios**
- **Scenario 1**: Build produces signed artifacts
  - **Steps**: Trigger build, verify artifacts, check signing
  - **Expected**: All artifacts signed and valid
- **Scenario 2**: Release published successfully
  - **Steps**: Create release tag, verify release, check artifacts
  - **Expected**: Release published with all artifacts
- **Scenario 3**: Update system works
  - **Steps**: Check for updates, verify prompt, test installation
  - **Expected**: Update check works, prompt appears, install succeeds
- **Scenario 4**: Repository hygiene maintained
  - **Steps**: Check for large files, verify .gitignore
  - **Expected**: No large files, clean repository

## Continuous Improvement

**1.10.11 Metrics-Driven Improvement**
- **Track Metrics**: Build success rate, release frequency
- **Identify Issues**: Common failure points, bottlenecks
- **Improve Process**: Automate manual steps, optimize workflows
- **Document Learnings**: Update processes based on metrics

**1.10.12 Complete Release Validation Pipeline**
- **Release Validation Workflow**:
  ```python
  # scripts/validate_release_complete.py
  """Complete release validation"""
  from pathlib import Path
  import subprocess
  import json
  
  class ReleaseValidator:
      """Validate release before publishing"""
      
      def validate_all(self, version: str) -> tuple[bool, list[str]]:
          """Validate all release criteria"""
          errors = []
          
          # Check version format
          if not self.validate_version_format(version):
              errors.append(f"Invalid version format: {version}")
          
          # Check artifacts exist
          artifacts_dir = Path("dist")
          dmgs = list(artifacts_dir.glob(f"*{version}*.dmg"))
          installers = list(artifacts_dir.glob(f"*{version}*-setup.exe"))
          
          if not dmgs:
              errors.append("macOS DMG not found")
          if not installers:
              errors.append("Windows installer not found")
          
          # Validate artifacts
          for dmg in dmgs:
              valid, dmg_errors = self.validate_dmg(dmg)
              if not valid:
                  errors.extend(dmg_errors)
          
          for installer in installers:
              valid, inst_errors = self.validate_installer(installer)
              if not valid:
                  errors.extend(inst_errors)
          
          # Check release notes
          release_notes = Path("RELEASE_NOTES.md")
          if not release_notes.exists():
              errors.append("RELEASE_NOTES.md not found")
          
          # Check git tag
          result = subprocess.run(
              ["git", "tag", "-l", f"v{version}"],
              capture_output=True,
              text=True
          )
          if not result.stdout.strip():
              errors.append(f"Git tag v{version} not found")
          
          return len(errors) == 0, errors
  ```

**1.10.13 Build Success Criteria**
- **Build Must Pass**:
  - ✅ All tests pass
  - ✅ Linting passes
  - ✅ Type checking passes
  - ✅ Code coverage > 80%
  - ✅ No large files
  - ✅ Version consistency
  - ✅ Artifacts created
  - ✅ Artifacts signed
  - ✅ Artifacts validated

**1.10.14 Release Success Criteria**
- **Release Must Include**:
  - ✅ GitHub Release created
  - ✅ All artifacts uploaded
  - ✅ Release notes included
  - ✅ Update metadata generated
  - ✅ Appcast published
  - ✅ Checksums provided
  - ✅ Signatures verified

**1.10.15 Update Success Criteria**
- **Update System Must**:
  - ✅ Check for updates successfully
  - ✅ Show update prompt
  - ✅ Download update securely
  - ✅ Verify update signature
  - ✅ Install update correctly
  - ✅ Preserve user data
  - ✅ Relaunch app

**1.10.16 Repository Success Criteria**
- **Repository Must**:
  - ✅ No large files (> 50MB)
  - ✅ Clean .gitignore
  - ✅ All CI checks pass
  - ✅ Documentation up to date
  - ✅ Code quality maintained

## Done Criteria Testing Framework

**1.10.17 Automated Done Criteria Tests**
- **Test Suite**:
  ```python
  # tests/acceptance/test_done_criteria.py
  """Test done criteria are met"""
  import pytest
  
  def test_build_produces_signed_artifacts():
      """Test build produces signed artifacts"""
      # Trigger build
      # Verify artifacts exist
      # Verify signing
      pass
  
  def test_release_published():
      """Test release is published correctly"""
      # Create release
      # Verify GitHub release
      # Verify artifacts uploaded
      pass
  
  def test_update_system_works():
      """Test update system functions"""
      # Check for updates
      # Verify prompt
      # Test installation
      pass
  
  def test_repository_hygiene():
      """Test repository hygiene"""
      # Check for large files
      # Verify .gitignore
      # Check CI status
      pass
  ```

## Done Criteria Monitoring

**1.10.18 Metrics Dashboard**
- **Track Over Time**:
  - Build success rate trend
  - Release frequency
  - Update adoption rate
  - CI failure rate
  - Code quality metrics

**1.10.19 Alerting System**
- **Alerts For**:
  - Build failures
  - Signing failures
  - Test failures
  - Large file commits
  - Version inconsistencies

## References

- Main document: `../01_Product_Requirements_and_Definition.md`
- Related: Step 2 (Build System), Step 5 (Updates), Step 7 (QA)
- CI/CD: GitHub Actions documentation
- Code Signing: Platform-specific documentation

