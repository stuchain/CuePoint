# Implementation Step 1.8: UX Requirements (Professional Baseline)

## Implementation Overview
**What We're Building**: Professional UX components including responsive layouts, progress indicators, discoverability features, and export functionality with clear error handling.

## Implementation Tasks

### Task 1.8.1: Implement Layout Requirements

**What to Build**
- Responsive layout system
- Scrollable content areas
- Table visibility optimization
- Window size management

**Implementation Details**

**1.8.1.1 Responsive Layout System**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  class MainWindow(QMainWindow):
      def __init__(self):
          # Use QVBoxLayout with stretch factors
          # Use QSplitter for resizable sections
          # Set minimum sizes for critical components
          
          self.setMinimumSize(1024, 768)  # Minimum window size
          
          # Main layout with splitter
          splitter = QSplitter(Qt.Vertical)
          splitter.setChildrenCollapsible(False)
          
          # Top section (filters, controls)
          top_widget = QWidget()
          top_widget.setMaximumHeight(200)  # Prevent excessive height
          splitter.addWidget(top_widget)
          
          # Bottom section (results table)
          bottom_widget = QWidget()
          splitter.addWidget(bottom_widget)
          
          # Set initial sizes (30% top, 70% bottom)
          splitter.setSizes([300, 700])
  ```
- **Purpose**: Ensure all controls remain visible
- **Integration**: Main window layout

**1.8.1.2 Scrollable Content Areas**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  from PySide6.QtWidgets import QScrollArea
  
  # Wrap main content in scroll area
  scroll_area = QScrollArea()
  scroll_area.setWidgetResizable(True)
  scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
  scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
  scroll_area.setWidget(main_content_widget)
  ```
- **Purpose**: Enable scrolling when window is small
- **Integration**: Main content area

**1.8.1.3 Table Visibility Optimization**
- **File to Modify**: `SRC/cuepoint/ui/widgets/results_view.py`
- **Implementation**:
  ```python
  def _ensure_table_min_rows(self, table: QTableWidget, rows: int = 10):
      """Ensure table shows N rows when space allows"""
      header_h = table.horizontalHeader().height()
      row_h = table.verticalHeader().defaultSectionSize()
      frame = table.frameWidth() * 2
      min_height = header_h + (row_h * rows) + frame + 6
      table.setMinimumHeight(min_height)
  ```
- **Purpose**: Target ~10 visible rows
- **Usage**: Called after table population

**1.8.1.4 Window Size Management**
- **File to Modify**: `SRC/cuepoint/ui/main_window.py`
- **Implementation**:
  ```python
  def resizeEvent(self, event):
      """Handle window resize"""
      super().resizeEvent(event)
      # Ensure critical controls remain visible
      # Adjust table height if needed
      self.results_view._ensure_table_min_rows(self.results_view.table)
  ```
- **Purpose**: Maintain usability at different sizes

### Task 1.8.2: Implement Progress Requirements

**What to Build**
- Progress dialog for processing
- Progress indicators with details
- Cancel functionality
- Safe state preservation

**Implementation Details**

**1.8.2.1 Processing Progress Dialog**
- **File to Create**: `SRC/cuepoint/ui/dialogs/processing_dialog.py`
- **Implementation**:
  ```python
  class ProcessingDialog(QDialog):
      """Progress dialog for track processing"""
      def __init__(self, parent=None):
          super().__init__(parent)
          self.setWindowTitle("Processing...")
          self.setModal(True)
          
          layout = QVBoxLayout()
          
          # Current track info
          self.current_track_label = QLabel("Starting...")
          layout.addWidget(self.current_track_label)
          
          # Progress bar
          self.progress_bar = QProgressBar()
          self.progress_bar.setRange(0, 0)  # Indeterminate initially
          layout.addWidget(self.progress_bar)
          
          # Statistics
          stats_layout = QHBoxLayout()
          self.elapsed_label = QLabel("Elapsed: 0s")
          self.remaining_label = QLabel("Remaining: --")
          self.matched_label = QLabel("Matched: 0")
          self.unmatched_label = QLabel("Unmatched: 0")
          stats_layout.addWidget(self.elapsed_label)
          stats_layout.addWidget(self.remaining_label)
          stats_layout.addWidget(self.matched_label)
          stats_layout.addWidget(self.unmatched_label)
          layout.addLayout(stats_layout)
          
          # Cancel button
          self.cancel_button = QPushButton("Cancel")
          self.cancel_button.clicked.connect(self.on_cancel)
          layout.addWidget(self.cancel_button)
          
          self.setLayout(layout)
      
      def update_progress(self, current: int, total: int, track_name: str):
          """Update progress display"""
          self.current_track_label.setText(f"Processing: {track_name}")
          self.progress_bar.setRange(0, total)
          self.progress_bar.setValue(current)
      
      def update_stats(self, elapsed: int, remaining: int, matched: int, unmatched: int):
          """Update statistics"""
          self.elapsed_label.setText(f"Elapsed: {elapsed}s")
          self.remaining_label.setText(f"Remaining: {remaining}s")
          self.matched_label.setText(f"Matched: {matched}")
          self.unmatched_label.setText(f"Unmatched: {unmatched}")
  ```
- **Purpose**: Show detailed progress during processing
- **Integration**: Called from processing service

**1.8.2.2 Cancel Functionality**
- **File to Modify**: `SRC/cuepoint/services/processor_service.py`
- **Implementation**:
  ```python
  class ProcessorService:
      def __init__(self):
          self._cancelled = False
      
      def cancel(self):
          """Cancel processing"""
          self._cancelled = True
      
      def process_tracks(self, tracks):
          """Process tracks with cancellation support"""
          for track in tracks:
              if self._cancelled:
                  # Save partial results
                  self._save_partial_results()
                  return
              # Process track
  ```
- **Purpose**: Allow safe cancellation
- **Integration**: Connected to cancel button

**1.8.2.3 Safe State Preservation**
- **File to Modify**: `SRC/cuepoint/services/processor_service.py`
- **Implementation**:
  ```python
  def _save_partial_results(self):
      """Save results processed so far"""
      # Save to temporary file
      # Allow user to resume or export partial results
  ```
- **Purpose**: Preserve work on cancel
- **Integration**: Called on cancel

### Task 1.8.3: Implement Discoverability Requirements

**What to Build**
- Tooltip system
- Shortcuts dialog
- Help system
- Contextual help

**Implementation Details**

**1.8.3.1 Tooltip System**
- **File to Modify**: All UI widgets
- **Implementation**:
  ```python
  # Add tooltips to all interactive elements
  self.xml_browse_button.setToolTip(
      "Browse for Rekordbox Collection XML file.\n"
      "Export from Rekordbox: File → Export Collection"
  )
  
  self.playlist_combo.setToolTip(
      "Select playlist to process.\n"
      "Single mode: Process one playlist.\n"
      "Batch mode: Process multiple playlists."
  )
  ```
- **Purpose**: Explain key steps
- **Coverage**: All major UI elements

**1.8.3.2 Shortcuts Dialog**
- **File to Create**: `SRC/cuepoint/ui/dialogs/shortcuts_dialog.py`
- **Implementation**:
  ```python
  class ShortcutsDialog(QDialog):
      """Keyboard shortcuts dialog"""
      def __init__(self, parent=None):
          super().__init__(parent)
          self.setWindowTitle("Keyboard Shortcuts")
          
          layout = QVBoxLayout()
          
          # Shortcuts table
          table = QTableWidget()
          table.setColumnCount(2)
          table.setHorizontalHeaderLabels(["Shortcut", "Action"])
          
          shortcuts = [
              ("Ctrl+O", "Open XML file"),
              ("Ctrl+E", "Export results"),
              ("Ctrl+F", "Focus search box"),
              ("Ctrl+Shift+F", "Clear all filters"),
              ("Esc", "Cancel processing"),
              ("Enter", "Start processing"),
          ]
          
          table.setRowCount(len(shortcuts))
          for row, (shortcut, action) in enumerate(shortcuts):
              table.setItem(row, 0, QTableWidgetItem(shortcut))
              table.setItem(row, 1, QTableWidgetItem(action))
          
          layout.addWidget(table)
          
          close_button = QPushButton("Close")
          close_button.clicked.connect(self.accept)
          layout.addWidget(close_button)
          
          self.setLayout(layout)
  ```
- **Purpose**: Show available shortcuts
- **Integration**: Help menu → Keyboard Shortcuts

**1.8.3.3 Help System**
- **File to Create**: `SRC/cuepoint/ui/dialogs/help_dialog.py`
- **Implementation**:
  ```python
  class HelpDialog(QDialog):
      """Help dialog with documentation"""
      def __init__(self, parent=None):
          super().__init__(parent)
          self.setWindowTitle("Help")
          
          # Use QTextBrowser for rich content
          browser = QTextBrowser()
          browser.setSource(QUrl("qrc:/help/index.html"))  # Or load from file
          
          layout = QVBoxLayout()
          layout.addWidget(browser)
          self.setLayout(layout)
  ```
- **Purpose**: Provide in-app help
- **Integration**: Help menu → Help

### Task 1.8.4: Implement Export Requirements

**What to Build**
- Clear export buttons
- Output location display
- "Open Output Folder" functionality
- Export status feedback

**Implementation Details**

**1.8.4.1 Export Buttons**
- **File to Modify**: `SRC/cuepoint/ui/widgets/results_view.py`
- **Implementation**:
  ```python
  # Export button (prominent, clear)
  self.export_btn = QPushButton("Export...")
  self.export_btn.setObjectName("primaryActionButton")  # Styled button
  self.export_btn.setFixedHeight(32)
  self.export_btn.clicked.connect(self.show_export_dialog)
  self.export_btn.setToolTip("Export results to CSV, JSON, or Excel (Ctrl+E)")
  ```
- **Purpose**: Obvious export functionality
- **Styling**: Use primary button style

**1.8.4.2 Output Location Display**
- **File to Modify**: `SRC/cuepoint/ui/dialogs/export_dialog.py`
- **Implementation**:
  ```python
  class ExportDialog(QDialog):
      def __init__(self, parent=None):
          # Show current output directory
          self.output_dir_label = QLabel()
          self.update_output_dir_display()
          
          # Browse button
          browse_btn = QPushButton("Browse...")
          browse_btn.clicked.connect(self.browse_output_dir)
      
      def update_output_dir_display(self):
          """Update output directory display"""
          output_dir = self.get_output_directory()
          self.output_dir_label.setText(f"Output: {output_dir}")
  ```
- **Purpose**: Show where files will be saved
- **Integration**: Export dialog

**1.8.4.3 Open Output Folder**
- **File to Modify**: `SRC/cuepoint/ui/widgets/results_view.py`
- **Implementation**:
  ```python
  def open_output_folder(self):
      """Open output folder in file explorer"""
      output_dir = self.get_output_directory()
      
      import platform
      import subprocess
      
      if platform.system() == "Windows":
          subprocess.Popen(f'explorer "{output_dir}"')
      elif platform.system() == "Darwin":
          subprocess.Popen(["open", output_dir])
      else:
          subprocess.Popen(["xdg-open", output_dir])
  ```
- **Purpose**: Easy access to exported files
- **Integration**: Export dialog and results view

**1.8.4.4 Export Status Feedback**
- **File to Modify**: `SRC/cuepoint/ui/dialogs/export_dialog.py`
- **Implementation**:
  ```python
  def on_export_complete(self, file_path: str):
      """Show export completion message"""
      msg = QMessageBox(self)
      msg.setIcon(QMessageBox.Information)
      msg.setWindowTitle("Export Complete")
      msg.setText(f"Exported to:\n{file_path}")
      
      # Add "Open Folder" button
      open_btn = msg.addButton("Open Folder", QMessageBox.ActionRole)
      msg.addButton("OK", QMessageBox.AcceptRole)
      
      msg.exec()
      
      if msg.clickedButton() == open_btn:
          self.open_output_folder()
  ```
- **Purpose**: Confirm export and provide next action
- **Integration**: Export completion handler

### Task 1.8.5: Implement UX Acceptance Criteria

**What to Build**
- No clipped controls
- Keyboard navigation
- Comprehensive error messages

**Implementation Details**

**1.8.5.1 No Clipped Controls**
- **File to Modify**: All UI widgets
- **Implementation**:
  ```python
  # Test at common resolutions
  # macOS 13" MacBook: 1440x900
  # Ensure all controls visible at minimum size
  
  def test_no_clipped_controls():
      """Test no controls are clipped"""
      window = MainWindow()
      window.resize(1024, 768)  # Minimum supported size
      # Verify all critical controls visible
  ```
- **Purpose**: Ensure usability at common resolutions
- **Testing**: Manual and automated tests

**1.8.5.2 Keyboard Navigation**
- **File to Modify**: All UI widgets
- **Implementation**:
  ```python
  # Set tab order
  self.setTabOrder(self.xml_browse_button, self.playlist_combo)
  self.setTabOrder(self.playlist_combo, self.start_button)
  
  # Enable keyboard shortcuts
  self.shortcut_manager.register_shortcut(
      "focus_search", "Ctrl+F", self.focus_search_box
  )
  ```
- **Purpose**: Full keyboard usability
- **Coverage**: All interactive elements

**1.8.5.3 Comprehensive Error Messages**
- **File to Modify**: `SRC/cuepoint/utils/error_handler.py`
- **Implementation**:
  ```python
  class ErrorHandler:
      @staticmethod
      def format_error(error: Exception, context: str) -> str:
          """Format error with context and guidance"""
          error_msg = f"Error in {context}: {str(error)}\n\n"
          
          # What happened
          error_msg += "What happened:\n"
          error_msg += f"- {error.__class__.__name__}: {str(error)}\n\n"
          
          # What user can do
          error_msg += "What you can do:\n"
          if isinstance(error, FileNotFoundError):
              error_msg += "- Check the file path is correct\n"
              error_msg += "- Ensure the file exists\n"
          elif isinstance(error, PermissionError):
              error_msg += "- Check file permissions\n"
              error_msg += "- Try running as administrator (Windows)\n"
          # ... more error types
          
          # Where logs are
          error_msg += f"\nLogs location: {AppPaths.logs_dir()}\n"
          
          return error_msg
  ```
- **Purpose**: Clear, actionable error messages
- **Usage**: All error displays

## Implementation Checklist

### Layout
- [ ] Implement responsive layout system
- [ ] Add scrollable content areas
- [ ] Optimize table visibility
- [ ] Test at common resolutions

### Progress
- [ ] Create processing progress dialog
- [ ] Implement progress indicators
- [ ] Add cancel functionality
- [ ] Implement safe state preservation

### Discoverability
- [ ] Add tooltips to all UI elements
- [ ] Create shortcuts dialog
- [ ] Create help system
- [ ] Add contextual help

### Export
- [ ] Enhance export buttons
- [ ] Add output location display
- [ ] Implement "Open Output Folder"
- [ ] Add export status feedback

### Acceptance Criteria
- [ ] Test no clipped controls
- [ ] Implement keyboard navigation
- [ ] Enhance error messages
- [ ] Test error recovery

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/ui/dialogs/processing_dialog.py` - Progress dialog
2. `SRC/cuepoint/ui/dialogs/shortcuts_dialog.py` - Shortcuts dialog
3. `SRC/cuepoint/ui/dialogs/help_dialog.py` - Help dialog

### Files to Modify
1. `SRC/cuepoint/ui/main_window.py` - Layout, window management
2. `SRC/cuepoint/ui/widgets/results_view.py` - Table, export buttons
3. `SRC/cuepoint/ui/dialogs/export_dialog.py` - Export UI enhancements
4. `SRC/cuepoint/services/processor_service.py` - Progress, cancel
5. `SRC/cuepoint/utils/error_handler.py` - Error message formatting
6. All UI widgets - Add tooltips and keyboard support

## Implementation Dependencies

### Prerequisites
- Step 1.3: User workflows (defines UX needs)
- Step 1.2: User personas (informs UX priorities)

### Enables
- Step 9: UX Polish (builds on these requirements)

## Success Criteria

### Layout
- ✅ No clipped controls at 1024x768
- ✅ All controls accessible via keyboard
- ✅ Tables show ~10 rows when space allows

### Progress
- ✅ Progress visible for all long operations
- ✅ Cancel works reliably
- ✅ Partial results preserved on cancel

### Discoverability
- ✅ All major UI elements have tooltips
- ✅ Shortcuts dialog accessible
- ✅ Help system functional

### Export
- ✅ Export buttons obvious and accessible
- ✅ Output location clearly displayed
- ✅ "Open Folder" works on all platforms

## Next Implementation Steps

After completing Step 1.8:
1. **Step 9**: UX Polish (enhances these requirements)
2. **Step 6**: Runtime design (implements error handling)

## Detailed UX Implementation

### Layout Requirements - Complete Implementation

**1.8.1.5 Complete Responsive Layout System**
- **Enhanced Main Window Layout**:
  ```python
  # SRC/cuepoint/ui/main_window.py
  from PySide6.QtWidgets import (
      QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, QSplitter,
      QScrollArea, QGroupBox, QSizePolicy
  )
  from PySide6.QtCore import Qt
  
  class MainWindow(QMainWindow):
      def __init__(self):
          super().__init__()
          self.setWindowTitle("CuePoint")
          self.setMinimumSize(1024, 768)  # Minimum window size
          
          # Central widget with splitter
          central_widget = QWidget()
          self.setCentralWidget(central_widget)
          
          main_layout = QVBoxLayout(central_widget)
          main_layout.setContentsMargins(8, 8, 8, 8)
          main_layout.setSpacing(8)
          
          # Top section: Controls and filters
          top_section = self._create_top_section()
          main_layout.addWidget(top_section)
          
          # Bottom section: Results (resizable)
          splitter = QSplitter(Qt.Vertical)
          splitter.setChildrenCollapsible(False)
          
          # Results table (takes most space)
          results_section = self._create_results_section()
          splitter.addWidget(results_section)
          
          # Status bar section (small, fixed)
          status_section = self._create_status_section()
          splitter.addWidget(status_section)
          
          # Set initial sizes (90% results, 10% status)
          splitter.setSizes([900, 100])
          main_layout.addWidget(splitter)
          
          # Restore window state
          self.restore_state()
      
      def _create_top_section(self) -> QWidget:
          """Create top section with controls"""
          widget = QWidget()
          layout = QVBoxLayout(widget)
          layout.setContentsMargins(0, 0, 0, 0)
          layout.setSpacing(8)
          
          # File selection group
          file_group = QGroupBox("Collection XML")
          file_layout = QHBoxLayout()
          self.xml_path_label = QLabel("No file selected")
          self.xml_browse_button = QPushButton("Browse...")
          file_layout.addWidget(self.xml_path_label, stretch=1)
          file_layout.addWidget(self.xml_browse_button)
          file_group.setLayout(file_layout)
          layout.addWidget(file_group)
          
          # Playlist selection group
          playlist_group = QGroupBox("Playlist Selection")
          playlist_layout = QVBoxLayout()
          
          # Mode selection
          mode_layout = QHBoxLayout()
          self.mode_single = QRadioButton("Single Playlist")
          self.mode_batch = QRadioButton("Batch (Multiple)")
          mode_layout.addWidget(self.mode_single)
          mode_layout.addWidget(self.mode_batch)
          playlist_layout.addLayout(mode_layout)
          
          # Playlist selector
          playlist_selector_layout = QHBoxLayout()
          self.playlist_combo = QComboBox()
          self.playlist_list = QListWidget()
          playlist_selector_layout.addWidget(self.playlist_combo)
          playlist_layout.addLayout(playlist_selector_layout)
          
          playlist_group.setLayout(playlist_layout)
          layout.addWidget(playlist_group)
          
          # Start button
          self.start_button = QPushButton("Start Processing")
          self.start_button.setObjectName("primaryActionButton")
          layout.addWidget(self.start_button)
          
          # Set maximum height to prevent excessive expansion
          widget.setMaximumHeight(300)
          widget.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Maximum)
          
          return widget
      
      def _create_results_section(self) -> QWidget:
          """Create results section with table"""
          # Results view widget (already exists)
          return self.results_view
      
      def _create_status_section(self) -> QWidget:
          """Create status bar section"""
          widget = QWidget()
          layout = QHBoxLayout(widget)
          layout.setContentsMargins(4, 4, 4, 4)
          
          self.status_label = QLabel("Ready")
          layout.addWidget(self.status_label)
          layout.addStretch()
          
          # Statistics
          self.stats_label = QLabel("")
          layout.addWidget(self.stats_label)
          
          widget.setMaximumHeight(30)
          widget.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Fixed)
          
          return widget
      
      def resizeEvent(self, event):
          """Handle window resize"""
          super().resizeEvent(event)
          # Ensure table maintains minimum visible rows
          if hasattr(self, 'results_view'):
              self.results_view._ensure_table_min_rows(self.results_view.table)
  ```

**1.8.1.6 Advanced Scrollable Content**
- **Scroll Area Implementation**:
  ```python
  # Enhanced scroll area for main content
  def _create_scrollable_content(self, content_widget: QWidget) -> QScrollArea:
      """Create scrollable content area"""
      scroll_area = QScrollArea()
      scroll_area.setWidgetResizable(True)
      scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarAsNeeded)
      scroll_area.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
      scroll_area.setFrameShape(QScrollArea.NoFrame)
      scroll_area.setWidget(content_widget)
      
      # Set minimum size
      scroll_area.setMinimumSize(800, 600)
      
      return scroll_area
  ```

### Progress Requirements - Complete Implementation

**1.8.2.4 Enhanced Processing Dialog**
- **Complete Processing Dialog**:
  ```python
  # SRC/cuepoint/ui/dialogs/processing_dialog.py
  from PySide6.QtWidgets import (
      QDialog, QVBoxLayout, QHBoxLayout, QLabel, QProgressBar,
      QPushButton, QTextEdit
  )
  from PySide6.QtCore import Qt, QTimer
  import time
  
  class ProcessingDialog(QDialog):
      """Enhanced progress dialog for track processing"""
      
      cancelled = Signal()
      
      def __init__(self, parent=None, total_tracks: int = 0):
          super().__init__(parent)
          self.setWindowTitle("Processing Tracks...")
          self.setModal(True)
          self.setMinimumWidth(500)
          
          self.total_tracks = total_tracks
          self.current_track = 0
          self.start_time = time.time()
          self.matched_count = 0
          self.unmatched_count = 0
          self.cancelled_flag = False
          
          self.init_ui()
      
      def init_ui(self):
          """Initialize UI"""
          layout = QVBoxLayout()
          layout.setSpacing(12)
          
          # Title
          title_label = QLabel("Processing Tracks")
          title_label.setStyleSheet("font-size: 14px; font-weight: bold;")
          layout.addWidget(title_label)
          
          # Current track info
          self.current_track_label = QLabel("Starting...")
          self.current_track_label.setWordWrap(True)
          layout.addWidget(self.current_track_label)
          
          # Progress bar
          self.progress_bar = QProgressBar()
          self.progress_bar.setRange(0, self.total_tracks if self.total_tracks > 0 else 0)
          self.progress_bar.setValue(0)
          self.progress_bar.setFormat("%p% (%v/%m)")
          layout.addWidget(self.progress_bar)
          
          # Statistics
          stats_group = QGroupBox("Statistics")
          stats_layout = QVBoxLayout()
          
          stats_row1 = QHBoxLayout()
          self.elapsed_label = QLabel("Elapsed: 0s")
          self.remaining_label = QLabel("Remaining: --")
          stats_row1.addWidget(self.elapsed_label)
          stats_row1.addWidget(self.remaining_label)
          stats_layout.addLayout(stats_row1)
          
          stats_row2 = QHBoxLayout()
          self.matched_label = QLabel("Matched: 0")
          self.unmatched_label = QLabel("Unmatched: 0")
          stats_row2.addWidget(self.matched_label)
          stats_row2.addWidget(self.unmatched_label)
          stats_layout.addLayout(stats_row2)
          
          stats_group.setLayout(stats_layout)
          layout.addWidget(stats_group)
          
          # Details (collapsible)
          self.details_text = QTextEdit()
          self.details_text.setReadOnly(True)
          self.details_text.setMaximumHeight(150)
          self.details_text.hide()
          layout.addWidget(self.details_text)
          
          # Buttons
          button_layout = QHBoxLayout()
          
          self.show_details_button = QPushButton("Show Details")
          self.show_details_button.clicked.connect(self.toggle_details)
          button_layout.addWidget(self.show_details_button)
          
          button_layout.addStretch()
          
          self.cancel_button = QPushButton("Cancel")
          self.cancel_button.clicked.connect(self.on_cancel)
          button_layout.addWidget(self.cancel_button)
          
          layout.addLayout(button_layout)
          
          self.setLayout(layout)
          
          # Update timer
          self.update_timer = QTimer()
          self.update_timer.timeout.connect(self.update_display)
          self.update_timer.start(250)  # Update every 250ms
      
      def update_progress(self, current: int, total: int, track_name: str, matched: bool = None):
          """Update progress display"""
          self.current_track = current
          self.total_tracks = total
          
          # Update progress bar
          self.progress_bar.setRange(0, total)
          self.progress_bar.setValue(current)
          
          # Update current track label
          if track_name:
              self.current_track_label.setText(f"Processing: {track_name}")
          
          # Update matched/unmatched counts
          if matched is not None:
              if matched:
                  self.matched_count += 1
              else:
                  self.unmatched_count += 1
          
          # Update details
          if self.details_text.isVisible():
              details = f"Track {current}/{total}: {track_name}\n"
              if matched is not None:
                  details += f"Match: {'Yes' if matched else 'No'}\n"
              self.details_text.append(details)
      
      def update_display(self):
          """Update elapsed/remaining time"""
          if self.current_track == 0:
              return
          
          elapsed = time.time() - self.start_time
          self.elapsed_label.setText(f"Elapsed: {int(elapsed)}s")
          
          # Calculate remaining
          if self.current_track > 0:
              avg_time_per_track = elapsed / self.current_track
              remaining_tracks = self.total_tracks - self.current_track
              remaining_time = avg_time_per_track * remaining_tracks
              self.remaining_label.setText(f"Remaining: ~{int(remaining_time)}s")
          
          # Update stats
          self.matched_label.setText(f"Matched: {self.matched_count}")
          self.unmatched_label.setText(f"Unmatched: {self.unmatched_count}")
      
      def toggle_details(self):
          """Toggle details view"""
          if self.details_text.isVisible():
              self.details_text.hide()
              self.show_details_button.setText("Show Details")
          else:
              self.details_text.show()
              self.show_details_button.setText("Hide Details")
      
      def on_cancel(self):
          """Handle cancel button click"""
          self.cancelled_flag = True
          self.cancel_button.setEnabled(False)
          self.cancel_button.setText("Cancelling...")
          self.current_track_label.setText("Cancelling... Please wait.")
          self.cancelled.emit()
      
      def closeEvent(self, event):
          """Handle dialog close"""
          if not self.cancelled_flag and self.current_track < self.total_tracks:
              # Ask for confirmation
              from PySide6.QtWidgets import QMessageBox
              reply = QMessageBox.question(
                  self,
                  "Cancel Processing?",
                  "Processing is not complete. Do you want to cancel?",
                  QMessageBox.Yes | QMessageBox.No,
                  QMessageBox.No
              )
              if reply == QMessageBox.Yes:
                  self.on_cancel()
                  event.accept()
              else:
                  event.ignore()
          else:
              event.accept()
  ```

**1.8.2.5 Safe Cancellation Implementation**
- **Complete Cancellation Support**:
  ```python
  # In SRC/cuepoint/services/processor_service.py
  class ProcessorService:
      def __init__(self):
          self._cancelled = False
          self._partial_results = []
          self._checkpoint_path = None
      
      def cancel(self):
          """Cancel processing"""
          self._cancelled = True
          logging.info("Processing cancellation requested")
      
      def process_tracks(self, tracks: List[Track], progress_callback):
          """Process tracks with cancellation support"""
          self._cancelled = False
          self._partial_results = []
          
          for i, track in enumerate(tracks):
              # Check cancellation
              if self._cancelled:
                  logging.info(f"Processing cancelled at track {i+1}/{len(tracks)}")
                  self._save_checkpoint(i)
                  return self._partial_results
              
              try:
                  # Process track
                  result = self.process_track(track)
                  self._partial_results.append(result)
                  
                  # Update progress
                  progress_callback(
                      i + 1,
                      len(tracks),
                      track.title,
                      result.matched if hasattr(result, 'matched') else None
                  )
                  
                  # Save checkpoint every 10 tracks
                  if (i + 1) % 10 == 0:
                      self._save_checkpoint(i + 1)
              
              except Exception as e:
                  logging.error(f"Error processing track {track.title}: {e}")
                  # Create unmatched result
                  result = create_unmatched_result(track, error=str(e))
                  self._partial_results.append(result)
          
          return self._partial_results
      
      def _save_checkpoint(self, completed_count: int):
          """Save processing checkpoint"""
          checkpoint = {
              "completed": completed_count,
              "results": [r.to_dict() for r in self._partial_results],
              "timestamp": datetime.now().isoformat()
          }
          
          checkpoint_path = AppPaths.cache_dir() / "processing_checkpoint.json"
          checkpoint_path.write_text(json.dumps(checkpoint, indent=2))
          self._checkpoint_path = checkpoint_path
      
      def load_checkpoint(self) -> Optional[List[TrackResult]]:
          """Load processing checkpoint"""
          checkpoint_path = AppPaths.cache_dir() / "processing_checkpoint.json"
          if not checkpoint_path.exists():
              return None
          
          try:
              checkpoint = json.loads(checkpoint_path.read_text())
              results = [TrackResult.from_dict(r) for r in checkpoint["results"]]
              return results
          except Exception as e:
              logging.error(f"Error loading checkpoint: {e}")
              return None
  ```

### Discoverability Requirements - Complete Implementation

**1.8.3.4 Complete Tooltip System**
- **Comprehensive Tooltip Implementation**:
  ```python
  # SRC/cuepoint/ui/tooltips.py
  """Centralized tooltip definitions"""
  
  TOOLTIPS = {
      "xml_browse": (
          "Browse for Rekordbox Collection XML file.\n\n"
          "To export from Rekordbox:\n"
          "1. Open Rekordbox\n"
          "2. Go to File → Export Collection in xml format\n"
          "3. Save the file\n"
          "4. Select it here"
      ),
      "playlist_select": (
          "Select playlist to process.\n\n"
          "Single mode: Process one playlist at a time.\n"
          "Batch mode: Process multiple playlists in one operation."
      ),
      "start_processing": (
          "Start processing the selected playlist(s).\n\n"
          "This will:\n"
          "1. Search Beatport for each track\n"
          "2. Match tracks with metadata\n"
          "3. Display results in the table"
      ),
      "export_results": (
          "Export results to file.\n\n"
          "Supported formats:\n"
          "- CSV (compatible with Excel)\n"
          "- JSON (for automation)\n"
          "- Excel (with formatting)\n\n"
          "Shortcut: Ctrl+E"
      ),
      "filter_search": (
          "Search results by title or artist.\n\n"
          "Searches in:\n"
          "- Original track title\n"
          "- Original artist\n"
          "- Beatport title\n"
          "- Beatport artists"
      ),
      "filter_confidence": (
          "Filter by match confidence score.\n\n"
          "Higher scores indicate better matches.\n"
          "Recommended: 0.7 or higher for reliable matches."
      ),
      "filter_year": (
          "Filter by release year.\n\n"
          "Enter year range to filter results.\n"
          "Leave empty to include all years."
      ),
      "filter_bpm": (
          "Filter by BPM (beats per minute).\n\n"
          "Enter BPM range to filter results.\n"
          "Useful for finding tracks in specific tempo ranges."
      ),
      "filter_key": (
          "Filter by musical key.\n\n"
          "Select key to show only tracks in that key.\n"
          "Uses Camelot wheel notation."
      ),
      "advanced_filters": (
          "Show/hide advanced filter options.\n\n"
          "Advanced filters include:\n"
          "- Year range\n"
          "- BPM range\n"
          "- Key filter\n"
          "- Match status"
      ),
  }
  
  def apply_tooltips(widget):
      """Apply tooltips to widget and children"""
      for child in widget.findChildren(QWidget):
          object_name = child.objectName()
          if object_name in TOOLTIPS:
              child.setToolTip(TOOLTIPS[object_name])
  ```

**1.8.3.5 Complete Help System**
- **Enhanced Help Dialog**:
  ```python
  # SRC/cuepoint/ui/dialogs/help_dialog.py
  from PySide6.QtWidgets import (
      QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
      QTextBrowser, QTabWidget, QWidget
  )
  from PySide6.QtCore import QUrl
  from pathlib import Path
  
  class HelpDialog(QDialog):
      """Comprehensive help dialog"""
      
      def __init__(self, parent=None, initial_topic: str = None):
          super().__init__(parent)
          self.setWindowTitle("CuePoint Help")
          self.setMinimumSize(700, 500)
          self.init_ui(initial_topic)
      
      def init_ui(self, initial_topic: str = None):
          """Initialize UI"""
          layout = QVBoxLayout()
          
          # Tab widget for different help sections
          tabs = QTabWidget()
          
          # Getting Started tab
          getting_started = self._create_getting_started_tab()
          tabs.addTab(getting_started, "Getting Started")
          
          # Workflows tab
          workflows = self._create_workflows_tab()
          tabs.addTab(workflows, "Workflows")
          
          # Export tab
          export_help = self._create_export_tab()
          tabs.addTab(export_help, "Export")
          
          # Troubleshooting tab
          troubleshooting = self._create_troubleshooting_tab()
          tabs.addTab(troubleshooting, "Troubleshooting")
          
          # Keyboard Shortcuts tab
          shortcuts = self._create_shortcuts_tab()
          tabs.addTab(shortcuts, "Shortcuts")
          
          layout.addWidget(tabs)
          
          # Close button
          close_button = QPushButton("Close")
          close_button.clicked.connect(self.accept)
          layout.addWidget(close_button)
          
          self.setLayout(layout)
          
          # Show specific topic if requested
          if initial_topic:
              self.show_topic(initial_topic)
      
      def _create_getting_started_tab(self) -> QWidget:
          """Create getting started help content"""
          widget = QWidget()
          layout = QVBoxLayout(widget)
          
          browser = QTextBrowser()
          content = """
          <h1>Getting Started with CuePoint</h1>
          
          <h2>Step 1: Export from Rekordbox</h2>
          <p>Before using CuePoint, you need to export your Rekordbox collection:</p>
          <ol>
              <li>Open Rekordbox</li>
              <li>Go to <b>File → Export Collection in xml format</b></li>
              <li>Save the XML file somewhere you can find it</li>
          </ol>
          
          <h2>Step 2: Select XML File</h2>
          <p>In CuePoint, click <b>Browse...</b> and select the XML file you exported.</p>
          
          <h2>Step 3: Select Playlist</h2>
          <p>Choose the playlist you want to enrich with Beatport metadata.</p>
          
          <h2>Step 4: Start Processing</h2>
          <p>Click <b>Start Processing</b> to begin. CuePoint will search Beatport for each track and match them with metadata.</p>
          
          <h2>Step 5: Review and Export</h2>
          <p>Review the results, apply filters if needed, and export to your preferred format.</p>
          """
          browser.setHtml(content)
          layout.addWidget(browser)
          
          return widget
      
      def _create_workflows_tab(self) -> QWidget:
          """Create workflows help content"""
          widget = QWidget()
          layout = QVBoxLayout(widget)
          
          browser = QTextBrowser()
          content = """
          <h1>Workflows</h1>
          
          <h2>Single Playlist Processing</h2>
          <p>Process one playlist at a time. Best for focused work on a specific playlist.</p>
          
          <h2>Batch Processing</h2>
          <p>Process multiple playlists in one operation. Best for processing entire collections.</p>
          
          <h2>Past Searches</h2>
          <p>Load previously exported CSV files to review or re-filter results.</p>
          """
          browser.setHtml(content)
          layout.addWidget(browser)
          
          return widget
      
      def _create_export_tab(self) -> QWidget:
          """Create export help content"""
          widget = QWidget()
          layout = QVBoxLayout(widget)
          
          browser = QTextBrowser()
          content = """
          <h1>Export Formats</h1>
          
          <h2>CSV</h2>
          <p>Comma-separated values format. Compatible with Excel, Google Sheets, and most spreadsheet applications.</p>
          
          <h2>JSON</h2>
          <p>JavaScript Object Notation format. Useful for automation, scripting, or importing into other applications.</p>
          
          <h2>Excel</h2>
          <p>Microsoft Excel format (.xlsx). Includes formatting and multiple sheets if needed.</p>
          """
          browser.setHtml(content)
          layout.addWidget(browser)
          
          return widget
      
      def _create_troubleshooting_tab(self) -> QWidget:
          """Create troubleshooting help content"""
          widget = QWidget()
          layout = QVBoxLayout(widget)
          
          browser = QTextBrowser()
          content = """
          <h1>Troubleshooting</h1>
          
          <h2>No Matches Found</h2>
          <p>If no matches are found for your tracks:</p>
          <ul>
              <li>Check that track titles and artists are spelled correctly in Rekordbox</li>
              <li>Try searching Beatport manually to verify tracks exist</li>
              <li>Some tracks may not be available on Beatport</li>
          </ul>
          
          <h2>Processing is Slow</h2>
          <p>Processing speed depends on:</p>
          <ul>
              <li>Number of tracks</li>
              <li>Network speed</li>
              <li>Beatport response time</li>
          </ul>
          <p>Large playlists (500+ tracks) may take 10+ minutes.</p>
          
          <h2>Export Fails</h2>
          <p>If export fails:</p>
          <ul>
              <li>Check you have write permissions for the output folder</li>
              <li>Ensure there's enough disk space</li>
              <li>Try a different output location</li>
          </ul>
          """
          browser.setHtml(content)
          layout.addWidget(browser)
          
          return widget
      
      def _create_shortcuts_tab(self) -> QWidget:
          """Create keyboard shortcuts content"""
          widget = QWidget()
          layout = QVBoxLayout(widget)
          
          browser = QTextBrowser()
          content = """
          <h1>Keyboard Shortcuts</h1>
          
          <table border="1" cellpadding="5">
              <tr><th>Shortcut</th><th>Action</th></tr>
              <tr><td>Ctrl+O</td><td>Open XML file</td></tr>
              <tr><td>Ctrl+E</td><td>Export results</td></tr>
              <tr><td>Ctrl+F</td><td>Focus search box</td></tr>
              <tr><td>Ctrl+Shift+F</td><td>Clear all filters</td></tr>
              <tr><td>Esc</td><td>Cancel processing</td></tr>
              <tr><td>Enter</td><td>Start processing</td></tr>
              <tr><td>F1</td><td>Show help</td></tr>
          </table>
          """
          browser.setHtml(content)
          layout.addWidget(browser)
          
          return widget
      
      def show_topic(self, topic: str):
          """Show specific help topic"""
          # Switch to appropriate tab based on topic
          topic_map = {
              "getting_started": 0,
              "workflows": 1,
              "export": 2,
              "troubleshooting": 3,
              "shortcuts": 4
          }
          if topic in topic_map:
              tabs = self.findChild(QTabWidget)
              if tabs:
                  tabs.setCurrentIndex(topic_map[topic])
  ```

### Export Requirements - Complete Implementation

**1.8.4.5 Enhanced Export Dialog**
- **Complete Export Dialog with All Features**:
  ```python
  # Enhanced SRC/cuepoint/ui/dialogs/export_dialog.py
  class ExportDialog(QDialog):
      """Enhanced export dialog with all features"""
      
      def __init__(self, parent=None, results_count: int = 0):
          super().__init__(parent)
          self.setWindowTitle("Export Results")
          self.setMinimumWidth(500)
          self.results_count = results_count
          self.exported_path = None
          
          self.init_ui()
      
      def init_ui(self):
          """Initialize UI"""
          layout = QVBoxLayout()
          layout.setSpacing(12)
          
          # Results count
          count_label = QLabel(f"Exporting {self.results_count} result(s)")
          count_label.setStyleSheet("font-weight: bold;")
          layout.addWidget(count_label)
          
          # Format selection
          format_group = QGroupBox("Export Format")
          format_layout = QVBoxLayout()
          
          self.format_csv = QRadioButton("CSV (Comma-separated values)")
          self.format_csv.setChecked(True)
          self.format_csv.setToolTip("Compatible with Excel and most spreadsheet applications")
          
          self.format_json = QRadioButton("JSON (JavaScript Object Notation)")
          self.format_json.setToolTip("Useful for automation and scripting")
          
          self.format_excel = QRadioButton("Excel (.xlsx)")
          self.format_excel.setToolTip("Microsoft Excel format with formatting")
          
          format_layout.addWidget(self.format_csv)
          format_layout.addWidget(self.format_json)
          format_layout.addWidget(self.format_excel)
          format_group.setLayout(format_layout)
          layout.addWidget(format_group)
          
          # Output location
          location_group = QGroupBox("Output Location")
          location_layout = QVBoxLayout()
          
          self.output_dir_label = QLabel()
          self.update_output_dir_display()
          location_layout.addWidget(self.output_dir_label)
          
          browse_button = QPushButton("Browse...")
          browse_button.clicked.connect(self.browse_output_dir)
          location_layout.addWidget(browse_button)
          
          location_group.setLayout(location_layout)
          layout.addWidget(location_group)
          
          # Options
          options_group = QGroupBox("Options")
          options_layout = QVBoxLayout()
          
          self.include_candidates_checkbox = QCheckBox("Include candidate matches")
          self.include_candidates_checkbox.setToolTip("Include alternative matches for each track")
          options_layout.addWidget(self.include_candidates_checkbox)
          
          self.include_metadata_checkbox = QCheckBox("Include processing metadata")
          self.include_metadata_checkbox.setToolTip("Include processing date, version, etc.")
          options_layout.addWidget(self.include_metadata_checkbox)
          
          options_group.setLayout(options_layout)
          layout.addWidget(options_group)
          
          # Buttons
          button_layout = QHBoxLayout()
          
          open_folder_button = QPushButton("Open Output Folder")
          open_folder_button.clicked.connect(self.open_output_folder)
          button_layout.addWidget(open_folder_button)
          
          button_layout.addStretch()
          
          cancel_button = QPushButton("Cancel")
          cancel_button.clicked.connect(self.reject)
          button_layout.addWidget(cancel_button)
          
          export_button = QPushButton("Export")
          export_button.setObjectName("primaryActionButton")
          export_button.clicked.connect(self.on_export)
          button_layout.addWidget(export_button)
          
          layout.addLayout(button_layout)
          
          self.setLayout(layout)
      
      def update_output_dir_display(self):
          """Update output directory display"""
          from cuepoint.utils.paths import AppPaths
          output_dir = AppPaths.exports_dir()
          self.output_dir_label.setText(f"Output: {output_dir}")
          self.output_dir_label.setToolTip(str(output_dir))
      
      def browse_output_dir(self):
          """Browse for output directory"""
          from PySide6.QtWidgets import QFileDialog
          from cuepoint.utils.paths import AppPaths
          
          output_dir = QFileDialog.getExistingDirectory(
              self,
              "Select Output Directory",
              str(AppPaths.exports_dir())
          )
          
          if output_dir:
              from pathlib import Path
              AppPaths.exports_dir = lambda: Path(output_dir)
              self.update_output_dir_display()
      
      def open_output_folder(self):
          """Open output folder in file explorer"""
          from cuepoint.utils.paths import AppPaths
          import platform
          import subprocess
          
          output_dir = AppPaths.exports_dir()
          
          if platform.system() == "Windows":
              subprocess.Popen(f'explorer "{output_dir}"')
          elif platform.system() == "Darwin":
              subprocess.Popen(["open", str(output_dir)])
          else:
              subprocess.Popen(["xdg-open", str(output_dir)])
      
      def on_export(self):
          """Handle export button click"""
          # Get selected format
          if self.format_csv.isChecked():
              format_type = "csv"
          elif self.format_json.isChecked():
              format_type = "json"
          elif self.format_excel.isChecked():
              format_type = "excel"
          else:
              return
          
          # Get options
          options = {
              "include_candidates": self.include_candidates_checkbox.isChecked(),
              "include_metadata": self.include_metadata_checkbox.isChecked()
          }
          
          # Emit signal or call export function
          # (implementation depends on parent)
          self.accept()
  ```

**1.8.4.6 Export Status Feedback**
- **Complete Export Completion Handler**:
  ```python
  def on_export_complete(self, file_path: Path, success: bool):
      """Show export completion message"""
      from PySide6.QtWidgets import QMessageBox
      from cuepoint.utils.paths import AppPaths
      import platform
      import subprocess
      
      if success:
          msg = QMessageBox(self)
          msg.setIcon(QMessageBox.Information)
          msg.setWindowTitle("Export Complete")
          msg.setText(f"Results exported successfully!")
          msg.setInformativeText(f"File: {file_path.name}\nLocation: {file_path.parent}")
          
          # Add buttons
          open_file_btn = msg.addButton("Open File", QMessageBox.ActionRole)
          open_folder_btn = msg.addButton("Open Folder", QMessageBox.ActionRole)
          msg.addButton("OK", QMessageBox.AcceptRole)
          
          msg.exec()
          
          if msg.clickedButton() == open_file_btn:
              # Open file
              if platform.system() == "Windows":
                  subprocess.Popen(['start', '', str(file_path)], shell=True)
              elif platform.system() == "Darwin":
                  subprocess.Popen(["open", str(file_path)])
              else:
                  subprocess.Popen(["xdg-open", str(file_path)])
          
          elif msg.clickedButton() == open_folder_btn:
              # Open folder
              if platform.system() == "Windows":
                  subprocess.Popen(f'explorer "{file_path.parent}"')
              elif platform.system() == "Darwin":
                  subprocess.Popen(["open", str(file_path.parent)])
              else:
                  subprocess.Popen(["xdg-open", str(file_path.parent)])
      else:
          # Show error
          QMessageBox.critical(
              self,
              "Export Failed",
              f"Failed to export results.\n\nCheck logs for details:\n{AppPaths.logs_dir()}"
          )
  ```

### UX Acceptance Criteria - Complete Testing

**1.8.5.4 Complete Acceptance Testing**
- **UX Acceptance Test Suite**:
  ```python
  # tests/acceptance/test_ux_requirements.py
  """UX requirements acceptance tests"""
  import pytest
  from PySide6.QtWidgets import QApplication
  from cuepoint.ui.main_window import MainWindow
  
  @pytest.fixture
  def app():
      """Create QApplication"""
      app = QApplication.instance()
      if app is None:
          app = QApplication([])
      return app
  
  @pytest.fixture
  def window(app):
      """Create main window"""
      return MainWindow()
  
  def test_no_clipped_controls_at_minimum_size(window):
      """Test no controls are clipped at minimum window size"""
      window.resize(1024, 768)  # Minimum supported size
      window.show()
      
      # Check all critical controls are visible
      assert window.xml_browse_button.isVisible()
      assert window.playlist_combo.isVisible()
      assert window.start_button.isVisible()
      assert window.results_view.isVisible()
      
      # Check buttons are not clipped
      assert window.xml_browse_button.height() > 0
      assert window.start_button.height() > 0
  
  def test_keyboard_navigation(window):
      """Test keyboard navigation works"""
      # Test tab order
      # Test shortcuts
      # Test focus management
      pass
  
  def test_progress_indication(window):
      """Test progress indication appears for long operations"""
      # Start processing
      # Verify progress dialog appears
      # Verify progress updates
      pass
  
  def test_tooltips_present(window):
      """Test all major UI elements have tooltips"""
      # Check tooltips on all interactive elements
      assert window.xml_browse_button.toolTip()
      assert window.playlist_combo.toolTip()
      assert window.start_button.toolTip()
      assert window.export_button.toolTip()
  
  def test_error_messages_clear(window):
      """Test error messages are clear and actionable"""
      # Trigger various errors
      # Verify error messages are user-friendly
      # Verify error messages include guidance
      pass
  ```

## Performance Benchmarks

### UX Performance Targets
- **Window Resize**: < 50ms
- **Table Update**: < 200ms for 1000 rows
- **Progress Update**: < 100ms per update
- **Tooltip Display**: < 50ms
- **Help Dialog Open**: < 200ms

## Edge Cases

### Layout Edge Cases
- **Case 1**: Very small window (< 1024x768)
  - **Handling**: Enable scrolling, show minimum controls
- **Case 2**: Very large window
  - **Handling**: Limit maximum sizes, maintain proportions
- **Case 3**: High DPI display
  - **Handling**: Scale appropriately, test on Retina displays

### Progress Edge Cases
- **Case 1**: Processing completes very quickly
  - **Handling**: Show completion message, don't flash dialog
- **Case 2**: Processing takes very long
  - **Handling**: Show detailed progress, allow cancellation
- **Case 3**: User closes progress dialog
  - **Handling**: Ask for confirmation, save partial results

## References

- Main document: `../01_Product_Requirements_and_Definition.md`
- Related: Step 1.3 (Workflows), Step 9 (UX Polish)
- Qt Layouts: Qt documentation
- UX Best Practices: Material Design, Human Interface Guidelines

