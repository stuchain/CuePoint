# Implementation Step 6.5: Caching Strategy

## Implementation Overview
**What We're Building**: A comprehensive caching strategy system that manages HTTP response caching using requests-cache, provides cache invalidation mechanisms, implements cache pruning for disk space management, exposes cache controls in the UI, and integrates cache diagnostics into support bundles. This system ensures that CuePoint can reduce network requests, improve performance, work offline with cached data, and give users control over cache behavior while maintaining data freshness and managing storage efficiently.

## Implementation Tasks

### Task 6.5.1: Implement Cache Management

**What to Build**
- Cache configuration system
- Cache storage management
- Cache location management
- Cache size monitoring
- Cache statistics collection

**Implementation Details**

**6.5.1.1 Cache Configuration**
- **Purpose**: Configure caching behavior
- **Rationale**:
  - Centralized cache configuration
  - Easy to modify cache behavior
  - Supports different cache policies
  - Enables user configuration
- **File to Create/Modify**: `SRC/cuepoint/utils/cache_manager.py` (may already exist)
- **Configuration Options**:
  - Cache location (default: cache_dir/http_cache)
  - Cache TTL (default: 7 days)
  - Cache size limit (default: 100MB)
  - Cache backend (SQLite, filesystem)
  - Cache expiration policy
- **Implementation**:
  ```python
  from pathlib import Path
  from typing import Optional
  from datetime import timedelta
  import requests_cache
  from requests_cache import CachedSession
  
  from cuepoint.utils.paths import AppPaths
  
  class CacheConfig:
      """Cache configuration."""
      
      # Default configuration
      default_ttl = timedelta(days=7)
      default_backend = "sqlite"
      default_cache_name = "http_cache"
      default_size_limit = 100 * 1024 * 1024  # 100MB
      
      def __init__(
          self,
          cache_dir: Optional[Path] = None,
          ttl: Optional[timedelta] = None,
          backend: str = None,
          size_limit: Optional[int] = None
      ):
          """Initialize cache configuration.
          
          Args:
              cache_dir: Cache directory (default: AppPaths.cache_dir())
              ttl: Time to live (default: 7 days)
              backend: Cache backend (default: "sqlite")
              size_limit: Maximum cache size in bytes (default: 100MB)
          """
          self.cache_dir = cache_dir or AppPaths.cache_dir() / "http_cache"
          self.ttl = ttl or CacheConfig.default_ttl
          self.backend = backend or CacheConfig.default_backend
          self.size_limit = size_limit or CacheConfig.default_size_limit
      
      def get_cache_path(self) -> Path:
          """Get cache database path.
          
          Returns:
              Path to cache database
          """
          self.cache_dir.mkdir(parents=True, exist_ok=True)
          return self.cache_dir / f"{CacheConfig.default_cache_name}.sqlite"
  
  class CacheManager:
      """Manage HTTP response caching."""
      
      _session: Optional[CachedSession] = None
      _config: Optional[CacheConfig] = None
      
      @staticmethod
      def initialize(config: Optional[CacheConfig] = None):
          """Initialize cache manager.
          
          Args:
              config: Cache configuration (default: default config)
          """
          if CacheManager._session is not None:
              return
          
          if config is None:
              config = CacheConfig()
          
          CacheManager._config = config
          
          # Create cached session
          cache_path = config.get_cache_path()
          CacheManager._session = requests_cache.CachedSession(
              cache_name=str(cache_path.with_suffix('')),
              backend=config.backend,
              expire_after=config.ttl,
              allowable_methods=['GET', 'POST'],  # Cache GET and POST
              allowable_codes=[200, 203, 300, 301, 308],  # Cache successful responses
              match_headers=False,  # Don't match on headers
              stale_if_error=True,  # Use stale cache on error
          )
      
      @staticmethod
      def get_session() -> CachedSession:
          """Get cached session.
          
          Returns:
              CachedSession instance
          """
          if CacheManager._session is None:
              CacheManager.initialize()
          return CacheManager._session
      
      @staticmethod
      def clear_cache():
          """Clear all cached responses."""
          if CacheManager._session is not None:
              CacheManager._session.cache.clear()
      
      @staticmethod
      def get_cache_size() -> int:
          """Get current cache size in bytes.
          
          Returns:
              Cache size in bytes
          """
          if CacheManager._session is None:
              return 0
          
          cache_path = CacheManager._config.get_cache_path()
          if cache_path.exists():
              return cache_path.stat().st_size
          return 0
      
      @staticmethod
      def get_cache_stats() -> Dict[str, Any]:
          """Get cache statistics.
          
          Returns:
              Dictionary with cache statistics
          """
          if CacheManager._session is None:
              return {
                  "enabled": False,
                  "size": 0,
                  "entries": 0,
              }
          
          cache = CacheManager._session.cache
          size = CacheManager.get_cache_size()
          
          try:
              entries = len(cache.responses)
          except Exception:
              entries = 0
          
          return {
              "enabled": True,
              "size": size,
              "size_mb": size / (1024 * 1024),
              "entries": entries,
              "location": str(CacheManager._config.get_cache_path()),
              "ttl_days": CacheManager._config.ttl.days,
          }
  ```
- **Integration**: Used by all HTTP requests
- **Initialization**: Called at application startup
- **Benefits**: Reduces network requests, improves performance

**6.5.1.2 Cache Storage Management**
- **Purpose**: Manage cache storage location and organization
- **Implementation**:
  ```python
  class CacheStorage:
      """Manage cache storage."""
      
      @staticmethod
      def get_cache_location() -> Path:
          """Get cache storage location.
          
          Returns:
              Path to cache directory
          """
          return AppPaths.cache_dir() / "http_cache"
      
      @staticmethod
      def ensure_cache_dir() -> Path:
          """Ensure cache directory exists.
          
          Returns:
              Path to cache directory
          """
          cache_dir = CacheStorage.get_cache_location()
          cache_dir.mkdir(parents=True, exist_ok=True)
          return cache_dir
      
      @staticmethod
      def get_cache_files() -> List[Path]:
          """Get all cache files.
          
          Returns:
              List of cache file paths
          """
          cache_dir = CacheStorage.get_cache_location()
          if not cache_dir.exists():
              return []
          
          # SQLite cache files
          cache_files = list(cache_dir.glob("*.sqlite"))
          cache_files.extend(cache_dir.glob("*.sqlite-shm"))
          cache_files.extend(cache_dir.glob("*.sqlite-wal"))
          
          return cache_files
  ```
- **Organization**: Cache files in dedicated directory
- **Cleanup**: Old cache files can be removed

### Task 6.5.2: Implement Cache Invalidation

**What to Build**
- TTL-based expiration
- Manual cache invalidation
- Selective cache invalidation
- Cache validation
- Cache refresh mechanisms

**Implementation Details**

**6.5.2.1 TTL-Based Expiration**
- **Purpose**: Automatically expire cached entries after TTL
- **Implementation**: Handled by requests-cache (configured in CacheConfig)
- **TTL Configuration**:
  - Default: 7 days
  - User-configurable in settings
  - Can be different for different URL patterns
- **Benefits**: Ensures data freshness

**6.5.2.2 Manual Cache Invalidation**
- **Purpose**: Allow users to clear cache manually
- **Implementation**:
  ```python
  class CacheInvalidation:
      """Cache invalidation utilities."""
      
      @staticmethod
      def clear_all():
          """Clear all cached entries."""
          CacheManager.clear_cache()
      
      @staticmethod
      def clear_expired():
          """Clear expired cache entries."""
          if CacheManager._session is not None:
              CacheManager._session.cache.remove_expired_responses()
      
      @staticmethod
      def clear_by_url_pattern(pattern: str):
          """Clear cache entries matching URL pattern.
          
          Args:
              pattern: URL pattern (supports wildcards)
          """
          if CacheManager._session is None:
              return
          
          import fnmatch
          cache = CacheManager._session.cache
          
          # Get all cached URLs
          for key in list(cache.responses.keys()):
              if fnmatch.fnmatch(key, pattern):
                  cache.delete(key)
      
      @staticmethod
      def clear_old_entries(days: int = 7):
          """Clear cache entries older than specified days.
          
          Args:
              days: Number of days
          """
          if CacheManager._session is None:
              return
          
          from datetime import datetime, timedelta
          cutoff = datetime.now() - timedelta(days=days)
          
          cache = CacheManager._session.cache
          for key in list(cache.responses.keys()):
              try:
                  response = cache.responses[key]
                  if response.created_at < cutoff:
                      cache.delete(key)
              except Exception:
                  pass
  ```
- **UI Integration**: "Clear Cache" button in settings
- **User Control**: Users can clear cache when needed

**6.5.2.3 Cache Validation**
- **Purpose**: Validate cache entries before use
- **Implementation**:
  ```python
  class CacheValidator:
      """Validate cache entries."""
      
      @staticmethod
      def is_cache_valid(url: str, max_age: Optional[timedelta] = None) -> bool:
          """Check if cache entry is valid.
          
          Args:
              url: URL to check
              max_age: Maximum age for cache entry
              
          Returns:
              True if cache entry is valid
          """
          if CacheManager._session is None:
              return False
          
          cache = CacheManager._session.cache
          
          if url not in cache.responses:
              return False
          
          response = cache.responses[url]
          
          # Check if expired
          if response.is_expired:
              return False
          
          # Check max age if specified
          if max_age is not None:
              age = datetime.now() - response.created_at
              if age > max_age:
                  return False
          
          return True
  ```
- **Usage**: Check cache validity before using cached response
- **Benefits**: Ensures data freshness

### Task 6.5.3: Implement Cache Pruning

**What to Build**
- Cache size monitoring
- Automatic cache pruning
- Cache size limits
- Pruning strategies
- Pruning UI feedback

**Implementation Details**

**6.5.3.1 Cache Size Monitoring**
- **Purpose**: Monitor cache size and trigger pruning when needed
- **Implementation**:
  ```python
  class CacheSizeMonitor:
      """Monitor cache size and trigger pruning."""
      
      @staticmethod
      def check_cache_size() -> Dict[str, Any]:
          """Check current cache size.
          
          Returns:
              Dictionary with size information
          """
          stats = CacheManager.get_cache_stats()
          config = CacheManager._config
          
          if config is None:
              return stats
          
          stats["limit"] = config.size_limit
          stats["limit_mb"] = config.size_limit / (1024 * 1024)
          stats["usage_percent"] = (stats["size"] / config.size_limit * 100) if config.size_limit > 0 else 0
          stats["needs_pruning"] = stats["size"] > config.size_limit
          
          return stats
      
      @staticmethod
      def should_prune() -> bool:
          """Check if cache should be pruned.
          
          Returns:
              True if cache exceeds size limit
          """
          stats = CacheSizeMonitor.check_cache_size()
          return stats.get("needs_pruning", False)
  ```
- **Monitoring**: Can be checked periodically
- **Trigger**: Prune when size exceeds limit

**6.5.3.2 Automatic Cache Pruning**
- **Purpose**: Automatically prune cache when size limit exceeded
- **Pruning Strategy**:
  - Remove oldest entries first (LRU)
  - Remove expired entries first
  - Remove largest entries if needed
  - Keep at least 50% of limit after pruning
- **Implementation**:
  ```python
  class CachePruner:
      """Prune cache to manage size."""
      
      @staticmethod
      def prune_to_size(target_size: int):
          """Prune cache to target size.
          
          Args:
              target_size: Target size in bytes
          """
          if CacheManager._session is None:
              return
          
          cache = CacheManager._session.cache
          current_size = CacheManager.get_cache_size()
          
          if current_size <= target_size:
              return
          
          # Get all entries sorted by age (oldest first)
          entries = []
          for key in cache.responses.keys():
              try:
                  response = cache.responses[key]
                  entries.append((key, response.created_at, response.size))
              except Exception:
                  pass
          
          # Sort by creation time (oldest first)
          entries.sort(key=lambda x: x[1])
          
          # Remove entries until under target size
          removed = 0
          for key, _, size in entries:
              if CacheManager.get_cache_size() <= target_size:
                  break
              
              cache.delete(key)
              removed += 1
          
          logger = logging.getLogger(__name__)
          logger.info(f"Pruned cache: removed {removed} entries")
      
      @staticmethod
      def prune_expired():
          """Remove all expired cache entries."""
          if CacheManager._session is not None:
              CacheManager._session.cache.remove_expired_responses()
      
      @staticmethod
      def prune_old(days: int = 30):
          """Remove cache entries older than specified days.
          
          Args:
              days: Number of days
          """
          CacheInvalidation.clear_old_entries(days)
  ```
- **Automatic**: Can run periodically or on size check
- **Manual**: Can be triggered by user

### Task 6.5.4: Implement Cache UI Controls

**What to Build**
- Cache settings in UI
- Cache statistics display
- Clear cache button
- Cache location display
- Cache size display

**Implementation Details**

**6.5.4.1 Cache Settings UI**
- **Purpose**: Allow users to configure cache behavior
- **Implementation Location**: Settings dialog
- **UI Elements**:
  - Enable/disable cache checkbox
  - Cache TTL setting (days)
  - Cache size limit setting (MB)
  - Clear cache button
  - Cache statistics display
  - Cache location display
- **Implementation**:
  ```python
  from PySide6.QtWidgets import (
      QWidget, QVBoxLayout, QHBoxLayout, QLabel,
      QCheckBox, QSpinBox, QPushButton, QGroupBox
  )
  
  class CacheSettingsWidget(QWidget):
      """Cache settings widget for settings dialog."""
      
      def __init__(self, parent=None):
          super().__init__(parent)
          self._setup_ui()
          self._load_settings()
      
      def _setup_ui(self):
          """Setup UI components."""
          layout = QVBoxLayout(self)
          
          # Enable cache
          self.enable_cache = QCheckBox("Enable HTTP caching")
          self.enable_cache.setChecked(True)
          layout.addWidget(self.enable_cache)
          
          # Cache TTL
          ttl_layout = QHBoxLayout()
          ttl_layout.addWidget(QLabel("Cache duration (days):"))
          self.cache_ttl = QSpinBox()
          self.cache_ttl.setMinimum(1)
          self.cache_ttl.setMaximum(365)
          self.cache_ttl.setValue(7)
          ttl_layout.addWidget(self.cache_ttl)
          ttl_layout.addStretch()
          layout.addLayout(ttl_layout)
          
          # Cache size limit
          size_layout = QHBoxLayout()
          size_layout.addWidget(QLabel("Cache size limit (MB):"))
          self.cache_size_limit = QSpinBox()
          self.cache_size_limit.setMinimum(10)
          self.cache_size_limit.setMaximum(1000)
          self.cache_size_limit.setValue(100)
          size_layout.addWidget(self.cache_size_limit)
          size_layout.addStretch()
          layout.addLayout(size_layout)
          
          # Cache statistics
          stats_group = QGroupBox("Cache Statistics")
          stats_layout = QVBoxLayout(stats_group)
          
          self.cache_stats_label = QLabel()
          self._update_stats()
          stats_layout.addWidget(self.cache_stats_label)
          
          # Refresh button
          refresh_btn = QPushButton("Refresh Statistics")
          refresh_btn.clicked.connect(self._update_stats)
          stats_layout.addWidget(refresh_btn)
          
          layout.addWidget(stats_group)
          
          # Actions
          actions_layout = QHBoxLayout()
          
          clear_btn = QPushButton("Clear Cache")
          clear_btn.clicked.connect(self._clear_cache)
          actions_layout.addWidget(clear_btn)
          
          open_location_btn = QPushButton("Open Cache Location")
          open_location_btn.clicked.connect(self._open_cache_location)
          actions_layout.addWidget(open_location_btn)
          
          actions_layout.addStretch()
          layout.addLayout(actions_layout)
      
      def _update_stats(self):
          """Update cache statistics display."""
          stats = CacheManager.get_cache_stats()
          
          if stats["enabled"]:
              text = f"""Cache Status: Enabled
Size: {stats['size_mb']:.2f} MB / {stats.get('limit_mb', 0):.2f} MB
Entries: {stats['entries']}
Location: {stats['location']}
TTL: {stats['ttl_days']} days"""
          else:
              text = "Cache Status: Disabled"
          
          self.cache_stats_label.setText(text)
      
      def _clear_cache(self):
          """Clear cache."""
          from PySide6.QtWidgets import QMessageBox
          
          reply = QMessageBox.question(
              self,
              "Clear Cache",
              "Are you sure you want to clear the cache? This will remove all cached data.",
              QMessageBox.Yes | QMessageBox.No
          )
          
          if reply == QMessageBox.Yes:
              CacheManager.clear_cache()
              self._update_stats()
              QMessageBox.information(self, "Cache Cleared", "Cache has been cleared.")
      
      def _open_cache_location(self):
          """Open cache location in file manager."""
          from PySide6.QtCore import QUrl
          from PySide6.QtGui import QDesktopServices
          
          cache_dir = CacheStorage.get_cache_location()
          QDesktopServices.openUrl(QUrl.fromLocalFile(str(cache_dir)))
      
      def _load_settings(self):
          """Load cache settings."""
          # Load from user preferences
          # Implementation depends on settings system
          pass
      
      def save_settings(self):
          """Save cache settings."""
          # Save to user preferences
          # Implementation depends on settings system
          pass
  ```
- **Integration**: Add to settings dialog
- **User Control**: Users can configure cache behavior

**6.5.4.2 Cache Diagnostics**
- **Purpose**: Include cache information in diagnostics
- **Implementation**:
  ```python
  def get_cache_diagnostics() -> Dict[str, Any]:
      """Get cache diagnostics for support bundle.
      
      Returns:
          Dictionary with cache diagnostic information
      """
      stats = CacheManager.get_cache_stats()
      config = CacheManager._config
      
      diagnostics = {
          "cache_enabled": stats.get("enabled", False),
          "cache_size_mb": stats.get("size_mb", 0),
          "cache_entries": stats.get("entries", 0),
          "cache_location": stats.get("location", ""),
          "cache_ttl_days": stats.get("ttl_days", 0),
      }
      
      if config:
          diagnostics["cache_limit_mb"] = config.size_limit / (1024 * 1024)
          diagnostics["cache_backend"] = config.backend
      
      return diagnostics
  ```
- **Integration**: Included in support bundle generation
- **Benefits**: Helps diagnose cache-related issues

## Implementation Checklist

### Documentation Tasks
- [ ] Document cache configuration
- [ ] Document cache TTL behavior
- [ ] Document cache pruning
- [ ] Document cache UI controls

### Code Analysis Tasks
- [ ] Review existing cache implementation
- [ ] Identify all HTTP requests
- [ ] Check cache usage
- [ ] Review cache size

### Implementation Tasks (Code)
- [ ] Create/enhance CacheManager
- [ ] Implement cache configuration
- [ ] Implement cache invalidation
- [ ] Implement cache pruning
- [ ] Create cache settings UI
- [ ] Add cache diagnostics
- [ ] Update all HTTP requests to use cache

### Testing Tasks
- [ ] Test cache storage
- [ ] Test cache expiration
- [ ] Test cache invalidation
- [ ] Test cache pruning
- [ ] Test cache UI
- [ ] Test cache diagnostics

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/utils/cache_manager.py` - Cache management (if doesn't exist or enhance)

### Files to Modify
1. `SRC/cuepoint/data/beatport.py` - Use cached session
2. `SRC/cuepoint/data/beatport_search.py` - Use cached session
3. `SRC/cuepoint/ui/dialogs/settings_dialog.py` - Add cache settings
4. `SRC/cuepoint/utils/diagnostics.py` - Add cache diagnostics

## Implementation Dependencies

### Prerequisites
- Step 6.1: File System Locations (needs cache directory)
- requests-cache library
- SQLite (for cache backend)

### Enables
- Reduced network requests
- Offline operation capability
- Improved performance
- Better user experience

## Success Criteria

### Functional
- ✅ Cache stores HTTP responses
- ✅ Cache expires after TTL
- ✅ Cache can be cleared manually
- ✅ Cache prunes when size limit exceeded
- ✅ Cache statistics displayed
- ✅ Cache location accessible

### Technical
- ✅ Cache configuration works
- ✅ Cache invalidation works
- ✅ Cache pruning works
- ✅ Cache size monitored
- ✅ Cache diagnostics complete

### User Experience
- ✅ Cache settings accessible
- ✅ Cache can be cleared easily
- ✅ Cache statistics visible
- ✅ Cache location can be opened
- ✅ Clear cache confirmation

## Next Implementation Steps

After completing Step 6.5:
1. **Step 6.6**: Performance (cache improves performance)
2. **Step 6.4**: Networking Reliability (cache reduces network requests)

## Detailed Implementation Guidance

### Caching Best Practices

**Cache Configuration**:
- Set appropriate TTL for data freshness
- Set size limits to prevent disk space issues
- Use SQLite backend for reliability
- Enable stale-if-error for resilience

**Cache Invalidation**:
- Expire cache after TTL
- Allow manual cache clearing
- Prune cache when size limit exceeded
- Remove expired entries periodically

**Cache Usage**:
- Cache GET requests
- Cache successful responses only
- Don't cache sensitive data
- Use cache for expensive operations

### Performance Considerations

**Cache Benefits**:
- Reduces network requests
- Improves response time
- Enables offline operation
- Reduces server load

**Cache Overhead**:
- Disk space usage
- Cache lookup time (minimal)
- Cache maintenance (periodic)

**Cache Size Management**:
- Monitor cache size
- Prune when needed
- Set reasonable size limits
- Clean up old entries

## References

- Main document: `../06_Runtime_Operational_Design.md`
- requests-cache: https://requests-cache.readthedocs.io/
- Step 6.1: File System Locations (provides cache directory)
- Step 6.4: Networking Reliability (cache reduces network requests)
