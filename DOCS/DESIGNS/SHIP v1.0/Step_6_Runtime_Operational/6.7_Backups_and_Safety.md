# Implementation Step 6.7: Backups and Safety

## Implementation Overview
**What We're Building**: A comprehensive file safety system that implements atomic write operations, backup mechanisms for important files, safe file overwrite patterns with user confirmation, data integrity verification, and conflict resolution. This system ensures that CuePoint never loses user data, handles file operations safely, provides recovery options, and maintains data integrity while giving users control over file operations and clear feedback about potential data loss.

## Implementation Tasks

### Task 6.7.1: Implement Safe Write Patterns

**What to Build**
- Atomic write operations
- Temporary file pattern
- Atomic rename operations
- fsync/flush guarantees
- Write verification

**Implementation Details**

**6.7.1.1 Atomic Write Pattern**
- **Purpose**: Ensure file writes are atomic (all-or-nothing)
- **Rationale**:
  - Prevents corrupted files from partial writes
  - Ensures data integrity
  - Enables safe overwrites
  - Prevents data loss
- **Pattern**:
  1. Write to temporary file (`file.tmp`)
  2. Flush and sync to disk
  3. Verify write succeeded
  4. Atomically rename to target file
  5. Clean up temporary file
- **File to Create/Modify**: `SRC/cuepoint/utils/file_safety.py`
- **Implementation**:
  ```python
  import os
  import shutil
  from pathlib import Path
  from typing import Optional, Callable
  
  class SafeFileWriter:
      """Safe file writing with atomic operations."""
      
      @staticmethod
      def write_atomic(
          file_path: Path,
          content: bytes,
          mode: str = 'wb',
          backup: bool = False
      ) -> bool:
          """Write file atomically.
          
          Args:
              file_path: Target file path
              content: Content to write (bytes or string)
              mode: Write mode ('wb' for bytes, 'w' for text)
              backup: Create backup of existing file
              
          Returns:
              True if write succeeded
          """
          # Convert string to bytes if needed
          if isinstance(content, str) and mode == 'wb':
              content = content.encode('utf-8')
          elif isinstance(content, bytes) and mode == 'w':
              mode = 'wb'
          
          # Create backup if requested and file exists
          if backup and file_path.exists():
              backup_path = file_path.with_suffix(file_path.suffix + '.bak')
              shutil.copy2(file_path, backup_path)
          
          # Write to temporary file
          temp_path = file_path.with_suffix(file_path.suffix + '.tmp')
          
          try:
              # Write content
              with open(temp_path, mode) as f:
                  if mode == 'wb':
                      f.write(content)
                  else:
                      f.write(content)
                  f.flush()
                  os.fsync(f.fileno())  # Ensure written to disk
              
              # Verify write
              if not temp_path.exists() or temp_path.stat().st_size == 0:
                  raise IOError("Temporary file write verification failed")
              
              # Atomic rename
              temp_path.replace(file_path)
              
              return True
              
          except Exception as e:
              # Clean up temp file on error
              if temp_path.exists():
                  try:
                      temp_path.unlink()
                  except Exception:
                      pass
              
              logger = logging.getLogger(__name__)
              logger.error(f"Atomic write failed for {file_path}: {e}")
              raise
      
      @staticmethod
      def write_text_atomic(
          file_path: Path,
          text: str,
          encoding: str = 'utf-8',
          backup: bool = False
      ) -> bool:
          """Write text file atomically.
          
          Args:
              file_path: Target file path
              text: Text content
              encoding: Text encoding
              backup: Create backup
              
          Returns:
              True if write succeeded
          """
          content = text.encode(encoding)
          return SafeFileWriter.write_atomic(file_path, content, 'wb', backup)
  ```
- **Benefits**: Prevents corrupted files, ensures data integrity
- **Usage**: Use for all file writes

**6.7.1.2 File Sync Guarantees**
- **Purpose**: Ensure data is written to disk
- **Implementation**: Uses `os.fsync()` after write
- **Rationale**:
  - OS may buffer writes
  - Power loss could lose buffered data
  - fsync ensures data on disk
  - Critical for important files
- **Performance**: fsync is slower but safer
- **Usage**: Use for configuration and important data files

**6.7.1.3 Write Verification**
- **Purpose**: Verify file was written correctly
- **Implementation**:
  ```python
  class WriteVerifier:
      """Verify file writes."""
      
      @staticmethod
      def verify_write(file_path: Path, expected_size: Optional[int] = None) -> bool:
          """Verify file write succeeded.
          
          Args:
              file_path: File to verify
              expected_size: Expected file size (optional)
              
          Returns:
              True if write verified
          """
          if not file_path.exists():
              return False
          
          if expected_size is not None:
              actual_size = file_path.stat().st_size
              if actual_size != expected_size:
                  return False
          
          # Try to read file
          try:
              with open(file_path, 'rb') as f:
                  f.read(1)  # Try to read at least one byte
              return True
          except Exception:
              return False
      
      @staticmethod
      def verify_content(file_path: Path, expected_content: bytes) -> bool:
          """Verify file content matches expected.
          
          Args:
              file_path: File to verify
              expected_content: Expected content
              
          Returns:
              True if content matches
          """
          try:
              with open(file_path, 'rb') as f:
                  actual_content = f.read()
              return actual_content == expected_content
          except Exception:
              return False
  ```
- **Usage**: Verify after atomic write
- **Benefits**: Catches write errors early

### Task 6.7.2: Implement Backup Mechanisms

**What to Build**
- Automatic backup creation
- Backup retention policy
- Backup restoration
- Backup cleanup
- Backup UI controls

**Implementation Details**

**6.7.2.1 Automatic Backup Creation**
- **Purpose**: Create backups before overwriting files
- **Backup Strategy**:
  - Create `.bak` file before overwrite
  - Keep last N backups (configurable)
  - Timestamp backups for history
  - Optional: Compress old backups
- **Implementation**:
  ```python
  from datetime import datetime
  from typing import List
  
  class BackupManager:
      """Manage file backups."""
      
      @staticmethod
      def create_backup(
          file_path: Path,
          backup_dir: Optional[Path] = None,
          max_backups: int = 5
      ) -> Path:
          """Create backup of file.
          
          Args:
              file_path: File to backup
              backup_dir: Backup directory (default: same as file)
              max_backups: Maximum number of backups to keep
              
          Returns:
              Path to backup file
          """
          if not file_path.exists():
              raise FileNotFoundError(f"File not found: {file_path}")
          
          if backup_dir is None:
              backup_dir = file_path.parent
          
          backup_dir.mkdir(parents=True, exist_ok=True)
          
          # Create timestamped backup
          timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
          backup_name = f"{file_path.stem}-{timestamp}{file_path.suffix}.bak"
          backup_path = backup_dir / backup_name
          
          # Copy file
          shutil.copy2(file_path, backup_path)
          
          # Clean up old backups
          BackupManager._cleanup_old_backups(file_path, backup_dir, max_backups)
          
          return backup_path
      
      @staticmethod
      def _cleanup_old_backups(
          file_path: Path,
          backup_dir: Path,
          max_backups: int
      ):
          """Remove old backups beyond limit.
          
          Args:
              file_path: Original file
              backup_dir: Backup directory
              max_backups: Maximum backups to keep
          """
          # Find all backups for this file
          pattern = f"{file_path.stem}-*.bak"
          backups = sorted(backup_dir.glob(pattern), key=lambda p: p.stat().st_mtime)
          
          # Remove oldest if over limit
          while len(backups) > max_backups:
              oldest = backups.pop(0)
              try:
                  oldest.unlink()
              except Exception as e:
                  logger = logging.getLogger(__name__)
                  logger.warning(f"Failed to remove old backup {oldest}: {e}")
      
      @staticmethod
      def list_backups(file_path: Path, backup_dir: Optional[Path] = None) -> List[Path]:
          """List available backups for file.
          
          Args:
              file_path: Original file
              backup_dir: Backup directory
              
          Returns:
              List of backup file paths (newest first)
          """
          if backup_dir is None:
              backup_dir = file_path.parent
          
          pattern = f"{file_path.stem}-*.bak"
          backups = sorted(
              backup_dir.glob(pattern),
              key=lambda p: p.stat().st_mtime,
              reverse=True
          )
          
          return backups
      
      @staticmethod
      def restore_backup(backup_path: Path, target_path: Path) -> bool:
          """Restore file from backup.
          
          Args:
              backup_path: Backup file path
              target_path: Target file path
              
          Returns:
              True if restore succeeded
          """
          try:
              # Create backup of current file if exists
              if target_path.exists():
                  BackupManager.create_backup(target_path)
              
              # Restore from backup
              shutil.copy2(backup_path, target_path)
              return True
          except Exception as e:
              logger = logging.getLogger(__name__)
              logger.error(f"Failed to restore backup {backup_path}: {e}")
              return False
  ```
- **Usage**: Call before overwriting important files
- **Benefits**: Enables recovery from mistakes

**6.7.2.2 Backup Retention Policy**
- **Purpose**: Manage backup storage
- **Policy**:
  - Keep last N backups (default: 5)
  - Remove oldest when limit exceeded
  - Optional: Compress old backups
  - Optional: Move old backups to archive
- **Configuration**: User-configurable in settings
- **Benefits**: Prevents unlimited backup growth

### Task 6.7.3: Implement Overwrite Protection

**What to Build**
- User confirmation for overwrites
- File conflict detection
- Overwrite options (skip, overwrite, rename)
- Conflict resolution UI
- Safe overwrite patterns

**Implementation Details**

**6.7.3.1 Overwrite Confirmation**
- **Purpose**: Ask user before overwriting files
- **Implementation**:
  ```python
  from PySide6.QtWidgets import QMessageBox, QDialog, QVBoxLayout, QLabel, QPushButton
  
  class OverwriteDialog(QDialog):
      """Dialog for file overwrite confirmation."""
      
      def __init__(self, file_path: Path, parent=None):
          """Initialize dialog.
          
          Args:
              file_path: File that would be overwritten
              parent: Parent widget
          """
          super().__init__(parent)
          self.file_path = file_path
          self.result_action = None
          self._setup_ui()
      
      def _setup_ui(self):
          """Setup dialog UI."""
          self.setWindowTitle("File Already Exists")
          layout = QVBoxLayout(self)
          
          message = QLabel(
              f"The file already exists:\n\n{self.file_path}\n\n"
              f"What would you like to do?"
          )
          message.setWordWrap(True)
          layout.addWidget(message)
          
          # Buttons
          buttons_layout = QVBoxLayout()
          
          overwrite_btn = QPushButton("Overwrite")
          overwrite_btn.clicked.connect(lambda: self._set_result("overwrite"))
          buttons_layout.addWidget(overwrite_btn)
          
          skip_btn = QPushButton("Skip")
          skip_btn.clicked.connect(lambda: self._set_result("skip"))
          buttons_layout.addWidget(skip_btn)
          
          rename_btn = QPushButton("Rename")
          rename_btn.clicked.connect(lambda: self._set_result("rename"))
          buttons_layout.addWidget(rename_btn)
          
          cancel_btn = QPushButton("Cancel")
          cancel_btn.clicked.connect(self.reject)
          buttons_layout.addWidget(cancel_btn)
          
          layout.addLayout(buttons_layout)
      
      def _set_result(self, action: str):
          """Set result action and close dialog."""
          self.result_action = action
          self.accept()
      
      @staticmethod
      def ask_overwrite(file_path: Path, parent=None) -> Optional[str]:
          """Ask user about overwrite.
          
          Args:
              file_path: File that would be overwritten
              parent: Parent widget
              
          Returns:
              "overwrite", "skip", "rename", or None (cancel)
          """
          dialog = OverwriteDialog(file_path, parent)
          if dialog.exec() == QDialog.Accepted:
              return dialog.result_action
          return None
  ```
- **Usage**: Show before overwriting user files
- **Benefits**: Prevents accidental data loss

**6.7.3.2 File Conflict Resolution**
- **Purpose**: Handle file conflicts intelligently
- **Conflict Types**:
  - File already exists
  - File is read-only
  - File is locked
  - Insufficient permissions
- **Resolution Options**:
  - Overwrite (with confirmation)
  - Skip
  - Rename (auto-generate new name)
  - Cancel operation
- **Implementation**:
  ```python
  class ConflictResolver:
      """Resolve file conflicts."""
      
      @staticmethod
      def resolve_conflict(
          file_path: Path,
          parent_widget=None
      ) -> Optional[Path]:
          """Resolve file conflict.
          
          Args:
              file_path: Conflicting file path
              parent_widget: Parent widget for dialogs
              
          Returns:
              Resolved file path or None (skip/cancel)
          """
          # Check if file exists
          if not file_path.exists():
              return file_path
          
          # Ask user
          action = OverwriteDialog.ask_overwrite(file_path, parent_widget)
          
          if action == "overwrite":
              return file_path
          elif action == "skip":
              return None
          elif action == "rename":
              return ConflictResolver._generate_unique_name(file_path)
          else:  # cancel
              return None
      
      @staticmethod
      def _generate_unique_name(file_path: Path) -> Path:
          """Generate unique filename.
          
          Args:
              file_path: Original file path
              
          Returns:
              Unique file path
          """
          base = file_path.stem
          suffix = file_path.suffix
          parent = file_path.parent
          
          counter = 1
          while True:
              new_name = f"{base} ({counter}){suffix}"
              new_path = parent / new_name
              if not new_path.exists():
                  return new_path
              counter += 1
  ```
- **Usage**: Call before file operations
- **Benefits**: Handles conflicts gracefully

### Task 6.7.4: Implement Data Integrity Checks

**What to Build**
- File integrity verification
- Checksum validation
- Data validation
- Corruption detection
- Recovery mechanisms

**Implementation Details**

**6.7.4.1 File Integrity Verification**
- **Purpose**: Verify files are not corrupted
- **Implementation**:
  ```python
  import hashlib
  
  class IntegrityChecker:
      """Check file integrity."""
      
      @staticmethod
      def calculate_checksum(file_path: Path, algorithm: str = 'sha256') -> str:
          """Calculate file checksum.
          
          Args:
              file_path: File to checksum
              algorithm: Hash algorithm ('md5', 'sha1', 'sha256')
              
          Returns:
              Hexadecimal checksum string
          """
          hash_obj = hashlib.new(algorithm)
          
          with open(file_path, 'rb') as f:
              for chunk in iter(lambda: f.read(4096), b''):
                  hash_obj.update(chunk)
          
          return hash_obj.hexdigest()
      
      @staticmethod
      def verify_checksum(file_path: Path, expected_checksum: str, algorithm: str = 'sha256') -> bool:
          """Verify file checksum.
          
          Args:
              file_path: File to verify
              expected_checksum: Expected checksum
              algorithm: Hash algorithm
              
          Returns:
              True if checksum matches
          """
          actual = IntegrityChecker.calculate_checksum(file_path, algorithm)
          return actual.lower() == expected_checksum.lower()
      
      @staticmethod
      def store_checksum(file_path: Path, checksum_file: Optional[Path] = None) -> Path:
          """Store checksum for file.
          
          Args:
              file_path: File to checksum
              checksum_file: Checksum file path (default: file.checksum)
              
          Returns:
              Path to checksum file
          """
          if checksum_file is None:
              checksum_file = file_path.with_suffix(file_path.suffix + '.checksum')
          
          checksum = IntegrityChecker.calculate_checksum(file_path)
          
          with open(checksum_file, 'w') as f:
              f.write(f"{checksum}  {file_path.name}\n")
          
          return checksum_file
  ```
- **Usage**: Verify important files after write
- **Benefits**: Detects corruption early

**6.7.4.2 Data Validation**
- **Purpose**: Validate data before writing
- **Implementation**: Depends on data format
- **Examples**:
  - JSON: Validate JSON syntax
  - XML: Validate XML structure
  - CSV: Validate CSV format
  - Config: Validate configuration schema
- **Benefits**: Prevents writing invalid data

## Implementation Checklist

### Documentation Tasks
- [ ] Document safe write patterns
- [ ] Document backup policies
- [ ] Document conflict resolution
- [ ] Document integrity checks

### Code Analysis Tasks
- [ ] Review all file write operations
- [ ] Identify files that need backups
- [ ] Check for unsafe write patterns
- [ ] Review conflict handling

### Implementation Tasks (Code)
- [ ] Create file_safety.py
- [ ] Implement atomic writes
- [ ] Implement backup manager
- [ ] Implement overwrite protection
- [ ] Implement integrity checks
- [ ] Update all file writes to use safe patterns
- [ ] Add backup UI controls

### Testing Tasks
- [ ] Test atomic writes
- [ ] Test backup creation
- [ ] Test overwrite protection
- [ ] Test integrity checks
- [ ] Test conflict resolution
- [ ] Test recovery from backups

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/utils/file_safety.py` - Safe file operations
2. `SRC/cuepoint/services/backup_service.py` - Backup service

### Files to Modify
1. All modules that write files - Use safe write patterns
2. `SRC/cuepoint/services/export_service.py` - Use safe writes
3. `SRC/cuepoint/services/config_service.py` - Use safe writes

## Implementation Dependencies

### Prerequisites
- Step 6.1: File System Locations (needs paths for backups)
- Step 6.2: Logging (logs file operations)

### Enables
- Data safety
- Recovery from errors
- User confidence
- Data integrity

## Success Criteria

### Functional
- ✅ All file writes are atomic
- ✅ Backups created for important files
- ✅ User confirmation for overwrites
- ✅ Conflicts resolved gracefully
- ✅ Integrity checks work
- ✅ Recovery from backups works

### Technical
- ✅ Atomic write pattern implemented
- ✅ Backup system works
- ✅ Overwrite protection works
- ✅ Integrity verification works
- ✅ No data loss from partial writes

### User Experience
- ✅ Clear overwrite confirmations
- ✅ Easy backup restoration
- ✅ Conflict resolution options
- ✅ Confidence in data safety
- ✅ Recovery options available

## Next Implementation Steps

After completing Step 6.7:
1. All file operations (use safe patterns)
2. Export functionality (use safe writes)
3. Configuration management (use safe writes)

## Detailed Implementation Guidance

### Safe Write Best Practices

**Atomic Operations**:
- Always write to temp file first
- Verify write succeeded
- Use atomic rename
- Clean up temp files

**Backup Strategy**:
- Backup before overwriting
- Keep reasonable number of backups
- Clean up old backups
- Make backups accessible

**User Confirmation**:
- Ask before overwriting user files
- Provide clear options
- Show file information
- Allow cancellation

### Data Integrity

**Verification**:
- Verify writes after completion
- Use checksums for important files
- Validate data before writing
- Check file permissions

**Recovery**:
- Keep backups accessible
- Provide restore functionality
- Document recovery procedures
- Test recovery regularly

### File Operation Safety Patterns

**Read Operations**:
- Check file exists before reading
- Handle file permission errors
- Validate file content
- Handle corrupted files
- Provide fallback options

**Write Operations**:
- Always use atomic write pattern
- Verify write succeeded
- Handle disk full errors
- Handle permission errors
- Provide user feedback

**Delete Operations**:
- Confirm before deleting
- Create backup before deleting
- Handle locked files
- Handle permission errors
- Provide undo option when possible

### Backup Management

**Backup Strategy**:
- Automatic backups for important files
- Manual backup option
- Backup before risky operations
- Timestamped backups
- Backup retention policy

**Backup Storage**:
- Store backups in safe location
- Organize backups by type
- Compress old backups
- Archive very old backups
- Monitor backup storage usage

**Backup Restoration**:
- Easy restore from UI
- Restore from backup list
- Verify backup before restore
- Create backup before restore
- Test restore functionality

### Conflict Resolution Strategies

**File Locking**:
- Detect file locks
- Handle locked files gracefully
- Wait for lock release (with timeout)
- Show lock information to user
- Provide unlock options

**Permission Issues**:
- Detect permission problems
- Provide clear error messages
- Suggest solutions
- Handle read-only files
- Handle access denied errors

**Concurrent Access**:
- Detect concurrent modifications
- Handle merge conflicts
- Provide conflict resolution UI
- Preserve both versions when needed
- Log conflict resolution

### Data Integrity Verification

**Checksum Usage**:
- Calculate checksums for important files
- Store checksums with files
- Verify checksums on read
- Recalculate checksums after write
- Include checksums in backups

**File Validation**:
- Validate file format
- Validate file structure
- Validate file content
- Detect corruption early
- Provide recovery options

**Integrity Monitoring**:
- Periodic integrity checks
- Verify backups integrity
- Monitor for corruption
- Alert on integrity issues
- Automatic repair when possible

### Advanced Safety Features

**Transaction Support**:
- Group related file operations
- Rollback on failure
- Atomic transaction commits
- Transaction logging
- Recovery from incomplete transactions

**Version Control Integration**:
- Track file versions
- Compare file versions
- Revert to previous versions
- Show version history
- Merge file versions

**File Watching**:
- Monitor file changes
- Detect external modifications
- Warn about concurrent edits
- Auto-reload when safe
- Handle file deletion

### Error Recovery Procedures

**Recovery from Partial Writes**:
- Detect partial writes
- Restore from backup
- Recover from temp files
- Verify file integrity
- Notify user of recovery

**Recovery from Corruption**:
- Detect file corruption
- Attempt automatic repair
- Restore from backup
- Provide manual recovery options
- Log corruption events

**Recovery from Deletion**:
- Restore from backup
- Recover from trash/recycle bin
- Provide file recovery UI
- Show deleted file history
- Prevent accidental deletion

### User Education and Feedback

**Safety Indicators**:
- Show file status (saved, modified, locked)
- Indicate backup status
- Show last backup time
- Display file integrity status
- Warn about unsafe operations

**User Guidance**:
- Explain safety features
- Provide safety tips
- Show backup locations
- Explain recovery procedures
- Offer safety recommendations

**Feedback Mechanisms**:
- Confirm successful operations
- Warn about risky operations
- Show operation progress
- Display error messages clearly
- Provide recovery suggestions

## References

- Main document: `../06_Runtime_Operational_Design.md`
- Step 6.1: File System Locations (provides paths)
- Step 6.2: Logging (logs file operations)
- Python file operations: https://docs.python.org/3/library/os.html#os.fsync
- Atomic file operations: https://en.wikipedia.org/wiki/Atomic_file_operation
- Data integrity: https://en.wikipedia.org/wiki/Data_integrity


