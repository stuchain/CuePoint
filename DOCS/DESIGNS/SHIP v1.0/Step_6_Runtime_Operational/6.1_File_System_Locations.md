# Implementation Step 6.1: File System Locations

## Implementation Overview
**What We're Building**: A comprehensive file system location management system that provides consistent, platform-agnostic paths for all application data, configuration, logs, cache, and exports using Qt Standard Paths. This system ensures that CuePoint follows platform conventions, never writes to restricted locations, and provides predictable storage locations that enhance reliability, maintainability, and user experience across macOS and Windows platforms.

## Implementation Tasks

### Task 6.1.1: Define Qt Standard Paths Architecture

**What to Build**
- Qt Standard Paths integration layer
- Platform-specific path mapping
- Path validation and creation logic
- Path utility functions
- Storage location constants

**Implementation Details**

**6.1.1.1 Qt Standard Paths Integration**
- **Purpose**: Use Qt's QStandardPaths to get platform-appropriate locations
- **Rationale**: 
  - Qt handles platform differences automatically
  - Follows OS conventions (macOS, Windows, Linux)
  - Provides consistent API across platforms
  - Handles edge cases (portable apps, network drives, etc.)
- **Implementation Location**: `SRC/cuepoint/utils/paths.py` (enhance existing)
- **Key QStandardPaths Used**:
  - `AppConfigLocation`: Configuration files
  - `AppLocalDataLocation`: Application data
  - `CacheLocation`: Cache files
  - `DocumentsLocation`: User documents (for exports)
  - `DownloadLocation`: Downloads folder
- **Implementation**:
  ```python
  from PySide6.QtCore import QStandardPaths
  from pathlib import Path
  
  class AppPaths:
      @staticmethod
      def config_dir() -> Path:
          """Get configuration directory."""
          path = Path(
              QStandardPaths.writableLocation(QStandardPaths.AppConfigLocation)
          ) / "CuePoint"
          path.mkdir(parents=True, exist_ok=True)
          return path
      
      @staticmethod
      def data_dir() -> Path:
          """Get application data directory."""
          path = Path(
              QStandardPaths.writableLocation(QStandardPaths.AppLocalDataLocation)
          ) / "CuePoint"
          path.mkdir(parents=True, exist_ok=True)
          return path
      
      @staticmethod
      def cache_dir() -> Path:
          """Get cache directory."""
          path = Path(
              QStandardPaths.writableLocation(QStandardPaths.CacheLocation)
          ) / "CuePoint"
          path.mkdir(parents=True, exist_ok=True)
          return path
  ```
- **Benefits**:
  - Automatic platform detection
  - Handles special cases (portable mode, network drives)
  - Future-proof for new platforms
  - Consistent with Qt ecosystem

**6.1.1.2 Platform-Specific Path Mapping**
- **Purpose**: Map Qt paths to concrete platform locations
- **Rationale**: 
  - Provides transparency about where files are stored
  - Enables documentation and user communication
  - Helps with debugging and support
  - Allows platform-specific optimizations
- **macOS Paths**:
  - Config: `~/Library/Preferences/com.stuchain.cuepoint.plist` (QSettings)
  - Config Files: `~/Library/Application Support/CuePoint/config/`
  - App Data: `~/Library/Application Support/CuePoint/`
  - Cache: `~/Library/Caches/CuePoint/`
  - Logs: `~/Library/Logs/CuePoint/` (or subdirectory of App Data)
  - Exports: `~/Documents/CuePoint/` (default, user-configurable)
- **Windows Paths**:
  - Config: `%APPDATA%\CuePoint\config\`
  - App Data: `%LOCALAPPDATA%\CuePoint\`
  - Cache: `%LOCALAPPDATA%\CuePoint\Cache\`
  - Logs: `%LOCALAPPDATA%\CuePoint\Logs\`
  - Exports: `%USERPROFILE%\Documents\CuePoint\` (default, user-configurable)
- **Implementation**:
  ```python
  from cuepoint.utils.platform import is_macos, is_windows
  
  class AppPaths:
      @staticmethod
      def get_platform_paths() -> Dict[str, str]:
          """Get platform-specific path mappings for documentation."""
          paths = {
              "config": str(AppPaths.config_dir()),
              "data": str(AppPaths.data_dir()),
              "cache": str(AppPaths.cache_dir()),
              "logs": str(AppPaths.logs_dir()),
              "exports": str(AppPaths.exports_dir()),
          }
          
          # Add platform-specific notes
          if is_macos():
              paths["notes"] = {
                  "config": "Uses ~/Library/Application Support/CuePoint/config/",
                  "qsettings": "Uses ~/Library/Preferences/com.stuchain.cuepoint.plist",
              }
          elif is_windows():
              paths["notes"] = {
                  "config": "Uses %APPDATA%\\CuePoint\\config\\",
                  "appdata": "Uses %LOCALAPPDATA%\\CuePoint\\",
              }
          
          return paths
  ```
- **Documentation**: Paths should be documented in user guide and diagnostics

**6.1.1.3 Path Validation and Creation**
- **Purpose**: Ensure paths exist and are writable
- **Rationale**:
  - Prevents runtime errors from missing directories
  - Handles permission issues gracefully
  - Provides clear error messages
  - Enables early failure detection
- **Validation Checks**:
  - Directory exists
  - Directory is writable
  - Sufficient disk space (optional, for large operations)
  - Path is not on network drive (optional, for performance)
- **Implementation**:
  ```python
  import os
  from pathlib import Path
  from typing import Tuple, Optional
  
  class PathValidator:
      @staticmethod
      def validate_path(path: Path, create: bool = True) -> Tuple[bool, Optional[str]]:
          """
          Validate a path exists and is writable.
          
          Args:
              path: Path to validate
              create: If True, create directory if missing
              
          Returns:
              Tuple of (is_valid, error_message)
          """
          try:
              # Create if needed
              if create:
                  path.mkdir(parents=True, exist_ok=True)
              
              # Check exists
              if not path.exists():
                  return False, f"Path does not exist: {path}"
              
              # Check is directory
              if not path.is_dir():
                  return False, f"Path is not a directory: {path}"
              
              # Check writable
              if not os.access(path, os.W_OK):
                  return False, f"Path is not writable: {path}"
              
              return True, None
              
          except PermissionError as e:
              return False, f"Permission denied: {e}"
          except OSError as e:
              return False, f"OS error: {e}"
      
      @staticmethod
      def ensure_path(path: Path) -> Path:
          """
          Ensure path exists, creating if necessary.
          
          Raises:
              PermissionError: If cannot create
              OSError: If creation fails
          """
          path.mkdir(parents=True, exist_ok=True)
          
          # Validate after creation
          is_valid, error = PathValidator.validate_path(path, create=False)
          if not is_valid:
              raise OSError(f"Failed to create or validate path: {error}")
          
          return path
  ```
- **Error Handling**: Should provide user-friendly error messages and recovery suggestions

### Task 6.1.2: Implement Storage Location Management

**What to Build**
- Storage location manager class
- Path initialization system
- Path access methods
- Path migration support
- Path diagnostics

**Implementation Details**

**6.1.2.1 Storage Location Manager**
- **Purpose**: Centralized management of all storage locations
- **File to Create/Modify**: `SRC/cuepoint/utils/paths.py` (enhance existing AppPaths)
- **Implementation**:
  ```python
  from pathlib import Path
  from typing import Dict, Optional
  from PySide6.QtCore import QStandardPaths
  
  class AppPaths:
      """Standard application paths using QStandardPaths.
      
      Provides consistent paths across platforms:
      - macOS: Uses ~/Library/Application Support, ~/Library/Caches, etc.
      - Windows: Uses %APPDATA%, %LOCALAPPDATA%, etc.
      - Linux: Uses ~/.config, ~/.local/share, etc.
      
      All paths are created automatically if they don't exist.
      """
      
      _initialized = False
      _paths_cache: Dict[str, Path] = {}
      
      @staticmethod
      def _ensure_dir(path: Path) -> Path:
          """Ensure directory exists, create if needed."""
          path.mkdir(parents=True, exist_ok=True)
          return path
      
      @staticmethod
      def config_dir() -> Path:
          """Get configuration directory.
          
          Platform-specific locations:
          - macOS: ~/Library/Application Support/CuePoint/config/
          - Windows: %APPDATA%\\CuePoint\\config\\
          - Linux: ~/.config/CuePoint/
          
          Returns:
              Path to configuration directory.
          """
          if "config" not in AppPaths._paths_cache:
              path = Path(
                  QStandardPaths.writableLocation(QStandardPaths.AppConfigLocation)
              ) / "CuePoint" / "config"
              AppPaths._paths_cache["config"] = AppPaths._ensure_dir(path)
          return AppPaths._paths_cache["config"]
      
      @staticmethod
      def config_file() -> Path:
          """Get main configuration file path.
          
          Returns:
              Path to config.yaml file.
          """
          return AppPaths.config_dir() / "config.yaml"
      
      @staticmethod
      def data_dir() -> Path:
          """Get application data directory.
          
          Platform-specific locations:
          - macOS: ~/Library/Application Support/CuePoint/
          - Windows: %LOCALAPPDATA%\\CuePoint\\
          - Linux: ~/.local/share/CuePoint/
          
          Returns:
              Path to data directory.
          """
          if "data" not in AppPaths._paths_cache:
              path = Path(
                  QStandardPaths.writableLocation(QStandardPaths.AppLocalDataLocation)
              ) / "CuePoint"
              AppPaths._paths_cache["data"] = AppPaths._ensure_dir(path)
          return AppPaths._paths_cache["data"]
      
      @staticmethod
      def cache_dir() -> Path:
          """Get cache directory.
          
          Platform-specific locations:
          - macOS: ~/Library/Caches/CuePoint/
          - Windows: %LOCALAPPDATA%\\CuePoint\\Cache\\
          - Linux: ~/.cache/CuePoint/
          
          Returns:
              Path to cache directory.
          """
          if "cache" not in AppPaths._paths_cache:
              path = Path(
                  QStandardPaths.writableLocation(QStandardPaths.CacheLocation)
              ) / "CuePoint"
              AppPaths._paths_cache["cache"] = AppPaths._ensure_dir(path)
          return AppPaths._paths_cache["cache"]
      
      @staticmethod
      def logs_dir() -> Path:
          """Get logs directory.
          
          Returns:
              Path to logs directory (subdirectory of data_dir).
          """
          if "logs" not in AppPaths._paths_cache:
              path = AppPaths.data_dir() / "Logs"
              AppPaths._paths_cache["logs"] = AppPaths._ensure_dir(path)
          return AppPaths._paths_cache["logs"]
      
      @staticmethod
      def exports_dir() -> Path:
          """Get default exports directory.
          
          Uses Downloads folder on first run, user can change in settings.
          
          Returns:
              Path to exports directory.
          """
          if "exports" not in AppPaths._paths_cache:
              downloads = Path(
                  QStandardPaths.writableLocation(QStandardPaths.DownloadLocation)
              )
              exports = downloads / "CuePoint Exports"
              AppPaths._paths_cache["exports"] = AppPaths._ensure_dir(exports)
          return AppPaths._paths_cache["exports"]
      
      @staticmethod
      def temp_dir() -> Path:
          """Get temporary files directory.
          
          Returns:
              Path to temporary files directory (subdirectory of cache_dir).
          """
          if "temp" not in AppPaths._paths_cache:
              path = AppPaths.cache_dir() / "temp"
              AppPaths._paths_cache["temp"] = AppPaths._ensure_dir(path)
          return AppPaths._paths_cache["temp"]
      
      @staticmethod
      def initialize_all() -> None:
          """Initialize all standard paths.
          
          Creates all directories if they don't exist.
          Should be called at application startup.
          
          Raises:
              PermissionError: If any directory cannot be created.
              OSError: If directory creation fails.
          """
          if AppPaths._initialized:
              return
          
          try:
              # Initialize all paths (creates directories)
              AppPaths.config_dir()
              AppPaths.data_dir()
              AppPaths.cache_dir()
              AppPaths.logs_dir()
              AppPaths.exports_dir()
              AppPaths.temp_dir()
              AppPaths._initialized = True
          except Exception as e:
              raise RuntimeError(f"Failed to initialize application paths: {e}") from e
      
      @staticmethod
      def get_all_paths() -> Dict[str, str]:
          """Get all paths for diagnostics.
          
          Returns:
              Dictionary mapping path names to absolute paths.
          """
          return {
              "config": str(AppPaths.config_dir()),
              "config_file": str(AppPaths.config_file()),
              "data": str(AppPaths.data_dir()),
              "cache": str(AppPaths.cache_dir()),
              "logs": str(AppPaths.logs_dir()),
              "exports": str(AppPaths.exports_dir()),
              "temp": str(AppPaths.temp_dir()),
          }
      
      @staticmethod
      def validate_paths() -> Dict[str, bool]:
          """Validate all paths are accessible.
          
          Returns:
              Dictionary mapping path names to accessibility status.
          """
          results = {}
          paths = AppPaths.get_all_paths()
          
          for name, path_str in paths.items():
              path = Path(path_str)
              try:
                  # Check if path exists and is accessible
                  if path.exists():
                      results[name] = os.access(path, os.R_OK)
                  else:
                      # Check if parent is writable (can create)
                      results[name] = os.access(path.parent, os.W_OK)
              except Exception:
                  results[name] = False
          
          return results
  ```
- **Integration**: Called at application startup in `gui_app.py` or main entry point
- **Caching**: Paths are cached after first access to avoid repeated QStandardPaths calls
- **Error Handling**: Provides clear error messages if paths cannot be created

**6.1.2.2 Path Initialization System**
- **Purpose**: Ensure all paths are ready before application use
- **Implementation Location**: Application startup code
- **Initialization Order**:
  1. Core paths (config, data, cache)
  2. Derived paths (logs, temp)
  3. User-configurable paths (exports)
  4. Validation
- **Implementation**:
  ```python
  # In gui_app.py or main entry point
  from cuepoint.utils.paths import AppPaths
  
  def initialize_application():
      """Initialize application before starting UI."""
      try:
          # Initialize all paths
          AppPaths.initialize_all()
          
          # Validate paths
          validation = AppPaths.validate_paths()
          if not all(validation.values()):
              # Log warning but continue
              failed = [k for k, v in validation.items() if not v]
              logger.warning(f"Some paths are not accessible: {failed}")
          
      except Exception as e:
          # Critical error - cannot continue
          logger.critical(f"Failed to initialize paths: {e}")
          raise
  ```
- **Error Recovery**: Should provide fallback paths if primary paths fail

**6.1.2.3 Path Access Methods**
- **Purpose**: Provide convenient access to common file locations
- **Implementation**:
  ```python
  class AppPaths:
      @staticmethod
      def get_log_file(name: str = "cuepoint.log") -> Path:
          """Get path to log file."""
          return AppPaths.logs_dir() / name
      
      @staticmethod
      def get_cache_file(name: str) -> Path:
          """Get path to cache file."""
          return AppPaths.cache_dir() / name
      
      @staticmethod
      def get_config_file(name: str) -> Path:
          """Get path to config file."""
          return AppPaths.config_dir() / name
      
      @staticmethod
      def get_temp_file(prefix: str = "tmp", suffix: str = "") -> Path:
          """Get path to temporary file."""
          import tempfile
          return Path(tempfile.mktemp(
              prefix=prefix,
              suffix=suffix,
              dir=str(AppPaths.temp_dir())
          ))
  ```
- **Benefits**: Reduces code duplication, ensures consistency

### Task 6.1.3: Implement Storage Invariants

**What to Build**
- Storage invariant validation
- Read-only location detection
- Write permission checking
- Bundle protection (macOS)
- Install directory protection (Windows)

**Implementation Details**

**6.1.3.1 Storage Invariant Rules**
- **Rule 1**: Never write into app bundle (macOS `.app`)
- **Rule 2**: Never write into install directory (Windows `Program Files`)
- **Rule 3**: All mutable state goes to user-writable locations
- **Rule 4**: Configuration is user-specific
- **Rule 5**: Cache can be cleared without data loss
- **Implementation**:
  ```python
  import sys
  from pathlib import Path
  from cuepoint.utils.platform import is_macos, is_windows
  
  class StorageInvariants:
      """Enforce storage invariants to prevent writing to restricted locations."""
      
      @staticmethod
      def get_app_dir() -> Path:
          """Get application installation directory."""
          if getattr(sys, "frozen", False):
              # Running as bundled app
              exe_path = Path(sys.executable)
              if is_macos():
                  # macOS: executable is in Contents/MacOS, go up to .app
                  return exe_path.parent.parent.parent
              else:
                  # Windows/Linux: executable directory
                  return exe_path.parent
          else:
              # Running from source
              return Path(__file__).parent.parent.parent
      
      @staticmethod
      def is_restricted_location(path: Path) -> bool:
          """Check if path is in a restricted location."""
          app_dir = StorageInvariants.get_app_dir()
          path_abs = path.resolve()
          app_dir_abs = app_dir.resolve()
          
          # Check if path is within app directory
          try:
              path_abs.relative_to(app_dir_abs)
              # Path is within app directory - restricted!
              return True
          except ValueError:
              # Path is not within app directory - OK
              pass
          
          # Check for other restricted locations
          if is_windows():
              # Check Program Files
              program_files = Path(os.environ.get("ProgramFiles", ""))
              if program_files and path_abs.is_relative_to(program_files):
                  return True
              
              # Check Program Files (x86)
              program_files_x86 = Path(os.environ.get("ProgramFiles(x86)", ""))
              if program_files_x86 and path_abs.is_relative_to(program_files_x86):
                  return True
          
          return False
      
      @staticmethod
      def validate_write_location(path: Path) -> Tuple[bool, Optional[str]]:
          """Validate that a path is safe to write to.
          
          Returns:
              Tuple of (is_safe, error_message)
          """
          if StorageInvariants.is_restricted_location(path):
              return False, f"Cannot write to restricted location: {path}"
          
          # Check parent is writable
          parent = path.parent
          if not os.access(parent, os.W_OK):
              return False, f"Parent directory is not writable: {parent}"
          
          return True, None
  ```
- **Integration**: Should be called before any file write operations
- **Error Handling**: Should provide clear error messages and suggest alternatives

**6.1.3.2 Bundle Protection (macOS)**
- **Purpose**: Prevent writing to `.app` bundle
- **Rationale**: 
  - App bundles are code-signed and should not be modified
  - Modifications break code signing
  - System may prevent writes anyway
  - Updates should replace bundle, not modify it
- **Implementation**:
  ```python
  def is_app_bundle(path: Path) -> bool:
      """Check if path is within an app bundle."""
      if not is_macos():
          return False
      
      # Check if any parent is .app
      current = path.resolve()
      while current != current.parent:
          if current.suffix == ".app":
              return True
          current = current.parent
      
      return False
  ```
- **Enforcement**: Should be checked before any write to app directory

**6.1.3.3 Install Directory Protection (Windows)**
- **Purpose**: Prevent writing to `Program Files`
- **Rationale**:
  - Requires administrator privileges
  - Violates Windows conventions
  - Causes permission issues
  - Updates should use installer, not direct writes
- **Implementation**: Included in `is_restricted_location` above
- **Detection**: Check environment variables `ProgramFiles` and `ProgramFiles(x86)`

### Task 6.1.4: Implement Path Migration Support

**What to Build**
- Path migration detection
- Migration logic
- Migration validation
- User notification for migrations

**Implementation Details**

**6.1.4.1 Path Migration Detection**
- **Purpose**: Detect when paths need to be migrated (e.g., after app update)
- **Scenarios**:
  - App moved to different location
  - User changed home directory
  - OS upgrade changed path conventions
  - Path structure changed in app update
- **Implementation**:
  ```python
  class PathMigration:
      """Handle path migrations when app structure changes."""
      
      @staticmethod
      def detect_migration_needed() -> bool:
          """Detect if path migration is needed."""
          # Check for old path structure
          old_paths = PathMigration.get_old_paths()
          
          for old_path in old_paths:
              if old_path.exists():
                  # Check if new path doesn't have data
                  new_path = PathMigration.map_old_to_new(old_path)
                  if not new_path.exists() or not any(new_path.iterdir()):
                      return True
          
          return False
      
      @staticmethod
      def get_old_paths() -> List[Path]:
          """Get list of old path locations."""
          old_paths = []
          
          # Check for old structure (example)
          if is_macos():
              old_data = Path.home() / "Library" / "Application Support" / "CuePoint" / "data"
              if old_data.exists():
                  old_paths.append(old_data)
          
          return old_paths
      
      @staticmethod
      def map_old_to_new(old_path: Path) -> Path:
          """Map old path to new path structure."""
          # Implementation depends on specific migration
          return AppPaths.data_dir()
  ```
- **Trigger**: Check at application startup
- **User Notification**: Should inform user if migration is needed

**6.1.4.2 Migration Execution**
- **Purpose**: Safely migrate data from old paths to new paths
- **Implementation**:
  ```python
  class PathMigration:
      @staticmethod
      def migrate_paths() -> Tuple[bool, Optional[str]]:
          """Migrate paths from old structure to new.
          
          Returns:
              Tuple of (success, error_message)
          """
          try:
              old_paths = PathMigration.get_old_paths()
              
              for old_path in old_paths:
                  if not old_path.exists():
                      continue
                  
                  new_path = PathMigration.map_old_to_new(old_path)
                  
                  # Create new path
                  new_path.mkdir(parents=True, exist_ok=True)
                  
                  # Copy files
                  import shutil
                  for item in old_path.iterdir():
                      dest = new_path / item.name
                      if item.is_dir():
                          shutil.copytree(item, dest, dirs_exist_ok=True)
                      else:
                          shutil.copy2(item, dest)
                  
                  # Backup old path (rename with .old suffix)
                  backup_path = old_path.with_suffix(old_path.suffix + ".old")
                  old_path.rename(backup_path)
                  
              return True, None
              
          except Exception as e:
              return False, str(e)
  ```
- **Safety**: Always backup old paths before migration
- **Validation**: Verify migration succeeded before removing old paths

### Task 6.1.5: Implement Path Diagnostics

**What to Build**
- Path diagnostics collection
- Path information display
- Path validation reporting
- Support bundle integration

**Implementation Details**

**6.1.5.1 Path Diagnostics Collection**
- **Purpose**: Collect path information for diagnostics and support
- **Implementation**:
  ```python
  class PathDiagnostics:
      """Collect path diagnostics for support and debugging."""
      
      @staticmethod
      def collect_diagnostics() -> Dict[str, Any]:
          """Collect comprehensive path diagnostics.
          
          Returns:
              Dictionary with path information.
          """
          import os
          import shutil
          
          diagnostics = {
              "paths": AppPaths.get_all_paths(),
              "validation": AppPaths.validate_paths(),
              "platform": {
                  "system": platform.system(),
                  "home": str(Path.home()),
              },
              "disk_space": {},
              "permissions": {},
          }
          
          # Add disk space information
          for name, path_str in AppPaths.get_all_paths().items():
              path = Path(path_str)
              try:
                  stat = shutil.disk_usage(path)
                  diagnostics["disk_space"][name] = {
                      "total": stat.total,
                      "used": stat.used,
                      "free": stat.free,
                      "free_gb": stat.free / (1024**3),
                  }
              except Exception:
                  diagnostics["disk_space"][name] = "unknown"
          
          # Add permission information
          for name, path_str in AppPaths.get_all_paths().items():
              path = Path(path_str)
              diagnostics["permissions"][name] = {
                  "exists": path.exists(),
                  "readable": os.access(path, os.R_OK) if path.exists() else False,
                  "writable": os.access(path, os.W_OK) if path.exists() else False,
              }
          
          return diagnostics
      
      @staticmethod
      def format_diagnostics() -> str:
          """Format diagnostics as human-readable string."""
          diag = PathDiagnostics.collect_diagnostics()
          
          lines = ["Path Diagnostics", "=" * 60]
          
          lines.append("\nPaths:")
          for name, path in diag["paths"].items():
              lines.append(f"  {name}: {path}")
          
          lines.append("\nValidation:")
          for name, valid in diag["validation"].items():
              status = "✓" if valid else "✗"
              lines.append(f"  {name}: {status}")
          
          lines.append("\nDisk Space:")
          for name, space in diag["disk_space"].items():
              if isinstance(space, dict):
                  free_gb = space.get("free_gb", 0)
                  lines.append(f"  {name}: {free_gb:.2f} GB free")
          
          return "\n".join(lines)
  ```
- **Integration**: Should be included in support bundle generation
- **Usage**: Available via "Copy diagnostic info" in UI

**6.1.5.2 Path Information UI**
- **Purpose**: Display path information to users
- **Implementation Location**: Settings dialog or diagnostics dialog
- **UI Elements**:
  - List of all paths
  - "Open in Finder/Explorer" buttons
  - "Copy path" buttons
  - Validation status indicators
- **Implementation**:
  ```python
  # In settings dialog or diagnostics dialog
  from PySide6.QtWidgets import QLabel, QPushButton, QVBoxLayout
  from PySide6.QtCore import QUrl
  from PySide6.QtGui import QDesktopServices
  
  class PathInfoWidget(QWidget):
      def __init__(self):
          super().__init__()
          layout = QVBoxLayout(self)
          
          paths = AppPaths.get_all_paths()
          for name, path_str in paths.items():
              row = QHBoxLayout()
              
              label = QLabel(f"{name}: {path_str}")
              row.addWidget(label)
              
              open_btn = QPushButton("Open")
              open_btn.clicked.connect(
                  lambda checked, p=path_str: QDesktopServices.openUrl(
                      QUrl.fromLocalFile(p)
                  )
              )
              row.addWidget(open_btn)
              
              layout.addLayout(row)
  ```
- **User Benefit**: Helps users find their data, useful for support

## Implementation Checklist

### Documentation Tasks
- [ ] Document all path locations
- [ ] Document platform differences
- [ ] Document migration procedures
- [ ] Create user guide section on file locations

### Code Analysis Tasks
- [ ] Review existing paths.py implementation
- [ ] Identify gaps in current implementation
- [ ] Review all file write operations for invariant compliance
- [ ] Check for hardcoded paths

### Implementation Tasks (Code)
- [ ] Enhance AppPaths class with all required methods
- [ ] Implement path validation
- [ ] Implement storage invariant checking
- [ ] Implement path migration support
- [ ] Implement path diagnostics
- [ ] Add path initialization to app startup
- [ ] Create path information UI
- [ ] Add path validation to support bundle

### Testing Tasks
- [ ] Test path creation on clean system
- [ ] Test path access on different platforms
- [ ] Test path validation
- [ ] Test storage invariant enforcement
- [ ] Test path migration
- [ ] Test path diagnostics collection

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/utils/storage.py` - Storage management utilities (if needed)
2. `SRC/cuepoint/utils/path_validator.py` - Path validation utilities (if separate module)

### Files to Modify
1. `SRC/cuepoint/utils/paths.py` - Enhance existing AppPaths class
2. `SRC/cuepoint/utils/platform.py` - Add platform detection if needed
3. `SRC/gui_app.py` or main entry point - Add path initialization
4. `SRC/cuepoint/ui/dialogs/settings_dialog.py` - Add path information display
5. `SRC/cuepoint/utils/support_bundle.py` - Add path diagnostics

## Implementation Dependencies

### Prerequisites
- Step 1: Product Requirements (defines storage needs)
- Qt/PySide6 installed
- Basic application structure

### Enables
- Step 6.2: Logging (needs logs directory)
- Step 6.3: Crash Handling (needs crash log location)
- Step 6.5: Caching (needs cache directory)
- All file operations in application

## Success Criteria

### Functional
- ✅ All paths created automatically on first run
- ✅ Paths follow platform conventions
- ✅ Paths are accessible and writable
- ✅ No writes to restricted locations
- ✅ Path information available in diagnostics
- ✅ Path migration works if needed

### Technical
- ✅ Paths use QStandardPaths
- ✅ Path validation passes on all platforms
- ✅ Storage invariants enforced
- ✅ Path diagnostics complete
- ✅ No hardcoded paths in codebase

### User Experience
- ✅ Users can find their data easily
- ✅ Paths are documented
- ✅ "Open folder" buttons work
- ✅ Clear error messages if paths fail

## Next Implementation Steps

After completing Step 6.1:
1. **Step 6.2**: Logging (uses logs directory from this step)
2. **Step 6.3**: Crash Handling (uses paths for crash logs)
3. **Step 6.5**: Caching (uses cache directory)
4. **Step 6.7**: Backups and Safety (uses paths for backup locations)

## Detailed Implementation Guidance

### Path Initialization Best Practices

**Early Initialization**:
- Initialize paths as early as possible in application startup
- Before any file operations
- Before logging (or use fallback for logging)

**Error Handling**:
- If primary path fails, try fallback location
- Log errors but don't crash app if non-critical paths fail
- Provide user notification if critical paths fail

**Caching**:
- Cache path objects after first access
- Avoid repeated QStandardPaths calls
- Invalidate cache if paths change (rare)

### Platform-Specific Considerations

**macOS**:
- Respect sandboxing if app is sandboxed
- Use `~/Library/Application Support` for data
- Use `~/Library/Caches` for cache
- Never write to `.app` bundle

**Windows**:
- Use `%APPDATA%` for roaming config
- Use `%LOCALAPPDATA%` for local data
- Handle per-user vs per-machine installs
- Never write to `Program Files`

**Linux**:
- Follow XDG Base Directory Specification
- Use `~/.config` for config
- Use `~/.local/share` for data
- Use `~/.cache` for cache

### Migration Strategy

**When to Migrate**:
- App structure changes
- Path conventions change
- User requests migration
- After major version update

**Migration Safety**:
- Always backup old paths
- Verify migration before deleting old data
- Provide rollback option
- Log migration steps

## References

- Main document: `../06_Runtime_Operational_Design.md`
- Qt Documentation: https://doc.qt.io/qt-6/qstandardpaths.html
- macOS File System: https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/
- Windows File System: https://docs.microsoft.com/en-us/windows/win32/fileio/file-management


