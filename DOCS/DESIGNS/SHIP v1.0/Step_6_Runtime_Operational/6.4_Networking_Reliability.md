# Implementation Step 6.4: Networking Reliability

## Implementation Overview
**What We're Building**: A comprehensive networking reliability system that implements robust HTTP request handling with configurable timeouts, exponential backoff retry mechanisms, network state detection, rate limiting, and clear user feedback for network operations. This system ensures that CuePoint can handle network failures gracefully, recover from transient errors automatically, respect rate limits, and provide users with clear information about network status while maintaining good performance and user experience.

## Implementation Tasks

### Task 6.4.1: Implement Timeout Policies

**What to Build**
- Configurable timeout system
- Connection timeout handling
- Read timeout handling
- Total request timeout
- Timeout error handling

**Implementation Details**

**6.4.1.1 Timeout Configuration**
- **Purpose**: Define timeout policies for different types of network operations
- **Rationale**:
  - Prevents hanging requests
  - Provides predictable behavior
  - Allows different timeouts for different operations
  - Enables user configuration
- **File to Create/Modify**: `SRC/cuepoint/utils/network.py`
- **Timeout Policy**:
  - Connect timeout: 5 seconds (time to establish connection)
  - Read timeout: 30 seconds (time to read response)
  - Total timeout: 60 seconds (maximum total request time)
  - Search operations: Longer timeout (45s read, 90s total)
  - Quick checks: Shorter timeout (10s read, 20s total)
- **Implementation**:
  ```python
  from typing import Optional
  from dataclasses import dataclass
  
  @dataclass
  class TimeoutConfig:
      """Network timeout configuration."""
      connect: float = 5.0  # Connection timeout in seconds
      read: float = 30.0     # Read timeout in seconds
      total: Optional[float] = 60.0  # Total timeout (None = no limit)
      
      @classmethod
      def for_search(cls) -> 'TimeoutConfig':
          """Timeout config for search operations."""
          return cls(connect=5.0, read=45.0, total=90.0)
      
      @classmethod
      def for_quick_check(cls) -> 'TimeoutConfig':
          """Timeout config for quick checks."""
          return cls(connect=5.0, read=10.0, total=20.0)
      
      @classmethod
      def for_download(cls) -> 'TimeoutConfig':
          """Timeout config for file downloads."""
          return cls(connect=5.0, read=60.0, total=300.0)  # 5 minutes for downloads
  
  class NetworkConfig:
      """Network configuration manager."""
      
      _default_timeout = TimeoutConfig()
      _search_timeout = TimeoutConfig.for_search()
      _quick_timeout = TimeoutConfig.for_quick_check()
      _download_timeout = TimeoutConfig.for_download()
      
      @staticmethod
      def get_timeout(operation_type: str = "default") -> TimeoutConfig:
          """Get timeout configuration for operation type.
          
          Args:
              operation_type: "default", "search", "quick", "download"
              
          Returns:
              TimeoutConfig instance
          """
          configs = {
              "default": NetworkConfig._default_timeout,
              "search": NetworkConfig._search_timeout,
              "quick": NetworkConfig._quick_timeout,
              "download": NetworkConfig._download_timeout,
          }
          return configs.get(operation_type, NetworkConfig._default_timeout)
  ```
- **Configuration**: Can be made user-configurable in settings
- **Benefits**: Prevents indefinite hangs, provides predictable behavior

**6.4.1.2 Timeout Implementation**
- **Purpose**: Apply timeouts to HTTP requests
- **Implementation**:
  ```python
  import requests
  from requests.adapters import HTTPAdapter
  from urllib3.util.retry import Retry
  
  class TimeoutHTTPAdapter(HTTPAdapter):
      """HTTP adapter with configurable timeouts."""
      
      def __init__(self, timeout_config: TimeoutConfig, *args, **kwargs):
          super().__init__(*args, **kwargs)
          self.timeout_config = timeout_config
      
      def send(self, request, **kwargs):
          # Set timeout tuple: (connect, read)
          timeout = (
              self.timeout_config.connect,
              self.timeout_config.read
          )
          kwargs['timeout'] = timeout
          return super().send(request, **kwargs)
  
  def create_session(timeout_config: Optional[TimeoutConfig] = None) -> requests.Session:
      """Create requests session with timeout configuration.
      
      Args:
          timeout_config: Timeout configuration (default: standard)
          
      Returns:
          Configured requests.Session
      """
      if timeout_config is None:
          timeout_config = NetworkConfig.get_timeout()
      
      session = requests.Session()
      adapter = TimeoutHTTPAdapter(timeout_config)
      session.mount('http://', adapter)
      session.mount('https://', adapter)
      
      return session
  ```
- **Integration**: Used by all network operations
- **Error Handling**: Timeout errors should be caught and handled gracefully

### Task 6.4.2: Implement Retry Mechanism

**What to Build**
- Exponential backoff retry logic
- Retry condition detection
- Jitter implementation
- Maximum retry limits
- Retry state tracking

**Implementation Details**

**6.4.2.1 Exponential Backoff Implementation**
- **Purpose**: Retry failed requests with increasing delays
- **Rationale**:
  - Handles transient network errors
  - Avoids overwhelming servers
  - Reduces load during outages
  - Improves success rate
- **Backoff Strategy**:
  - Base delay: 0.5 seconds
  - Exponential multiplier: 2x per retry
  - Jitter: 0-0.25 seconds random
  - Max retries: 3 attempts
  - Max delay: 10 seconds
- **Implementation**:
  ```python
  import time
  import random
  from typing import Callable, Optional, TypeVar, Any
  from functools import wraps
  
  T = TypeVar('T')
  
  class RetryConfig:
      """Retry configuration."""
      max_retries: int = 3
      base_delay: float = 0.5
      max_delay: float = 10.0
      jitter_range: float = 0.25
      exponential_base: float = 2.0
      
      # HTTP status codes that should trigger retry
      retry_status_codes = {500, 502, 503, 504, 429}
      
      # Exceptions that should trigger retry
      retry_exceptions = (
          requests.exceptions.ConnectionError,
          requests.exceptions.Timeout,
          requests.exceptions.HTTPError,
      )
  
  def exponential_backoff(
      func: Callable[..., T],
      config: Optional[RetryConfig] = None
  ) -> Callable[..., T]:
      """Decorator for exponential backoff retry.
      
      Args:
          func: Function to wrap
          config: Retry configuration
          
      Returns:
          Wrapped function with retry logic
      """
      if config is None:
          config = RetryConfig()
      
      @wraps(func)
      def wrapper(*args, **kwargs) -> T:
          last_exception = None
          
          for attempt in range(config.max_retries + 1):
              try:
                  return func(*args, **kwargs)
              except config.retry_exceptions as e:
                  last_exception = e
                  
                  # Check if should retry
                  if attempt >= config.max_retries:
                      break
                  
                  # Calculate delay with exponential backoff and jitter
                  delay = min(
                      config.base_delay * (config.exponential_base ** attempt),
                      config.max_delay
                  )
                  jitter = random.uniform(0, config.jitter_range)
                  total_delay = delay + jitter
                  
                  # Log retry
                  logger = logging.getLogger(__name__)
                  logger.warning(
                      f"Retry {attempt + 1}/{config.max_retries} for {func.__name__} "
                      f"after {total_delay:.2f}s: {e}"
                  )
                  
                  time.sleep(total_delay)
              
              except requests.exceptions.HTTPError as e:
                  # Check if status code should trigger retry
                  if e.response.status_code in config.retry_status_codes:
                      last_exception = e
                      if attempt >= config.max_retries:
                          break
                      
                      delay = min(
                          config.base_delay * (config.exponential_base ** attempt),
                          config.max_delay
                      )
                      jitter = random.uniform(0, config.jitter_range)
                      total_delay = delay + jitter
                      
                      logger = logging.getLogger(__name__)
                      logger.warning(
                          f"Retry {attempt + 1}/{config.max_retries} for {func.__name__} "
                          f"(HTTP {e.response.status_code}) after {total_delay:.2f}s"
                      )
                      
                      time.sleep(total_delay)
                  else:
                      # Don't retry for other HTTP errors
                      raise
          
          # All retries exhausted
          raise last_exception
      
      return wrapper
  ```
- **Usage**: Can be used as decorator or called directly
- **Benefits**: Automatic retry for transient errors

**6.4.2.2 Retry State Tracking**
- **Purpose**: Track retry attempts for UI feedback
- **Implementation**:
  ```python
  from typing import Protocol
  
  class RetryCallback(Protocol):
      """Protocol for retry callbacks."""
      def on_retry(self, attempt: int, max_attempts: int, delay: float, error: Exception) -> None:
          """Called when retry occurs."""
          ...
  
  class RetryTracker:
      """Track retry attempts for UI feedback."""
      
      def __init__(self, callback: Optional[RetryCallback] = None):
          self.callback = callback
          self.attempts = 0
          self.total_delay = 0.0
      
      def on_retry(self, attempt: int, max_attempts: int, delay: float, error: Exception):
          """Handle retry event."""
          self.attempts += 1
          self.total_delay += delay
          
          if self.callback:
              self.callback.on_retry(attempt, max_attempts, delay, error)
  ```
- **UI Integration**: Can update progress indicators during retries

### Task 6.4.3: Implement Network State Detection

**What to Build**
- Network connectivity detection
- Network state monitoring
- Offline mode handling
- Network change detection

**Implementation Details**

**6.4.3.1 Network Connectivity Detection**
- **Purpose**: Detect if network is available
- **Implementation**:
  ```python
  import socket
  from typing import Optional
  
  class NetworkState:
      """Detect and monitor network state."""
      
      _is_online: Optional[bool] = None
      _last_check: Optional[float] = None
      _check_interval = 30.0  # Check every 30 seconds
      
      @staticmethod
      def is_online(force_check: bool = False) -> bool:
          """Check if network is available.
          
          Args:
              force_check: Force new check (ignore cache)
              
          Returns:
              True if network is available
          """
          import time
          
          # Use cached result if recent
          if not force_check and NetworkState._is_online is not None:
              if NetworkState._last_check is not None:
                  if time.time() - NetworkState._last_check < NetworkState._check_interval:
                      return NetworkState._is_online
          
          # Perform check
          try:
              # Try to connect to a reliable host
              socket.create_connection(("8.8.8.8", 53), timeout=3)
              NetworkState._is_online = True
          except OSError:
              NetworkState._is_online = False
          
          NetworkState._last_check = time.time()
          return NetworkState._is_online
      
      @staticmethod
      def check_specific_host(host: str, port: int = 80, timeout: float = 3.0) -> bool:
          """Check connectivity to specific host.
          
          Args:
              host: Hostname to check
              port: Port to check
              timeout: Timeout in seconds
              
          Returns:
              True if host is reachable
          """
          try:
              socket.create_connection((host, port), timeout=timeout)
              return True
          except OSError:
              return False
  ```
- **Usage**: Check before making requests
- **Caching**: Cache result to avoid frequent checks

**6.4.3.2 Network State UI**
- **Purpose**: Show network status to users
- **Implementation**:
  ```python
  from PySide6.QtWidgets import QLabel
  from PySide6.QtCore import QTimer, Signal, QObject
  
  class NetworkStatusIndicator(QObject):
      """Network status indicator for UI."""
      
      status_changed = Signal(bool)  # True if online
      
      def __init__(self):
          super().__init__()
          self._is_online = True
          self._timer = QTimer()
          self._timer.timeout.connect(self._check_status)
          self._timer.start(30000)  # Check every 30 seconds
          self._check_status()
      
      def _check_status(self):
          """Check and update network status."""
          is_online = NetworkState.is_online(force_check=True)
          
          if is_online != self._is_online:
              self._is_online = is_online
              self.status_changed.emit(is_online)
      
      def get_status_text(self) -> str:
          """Get status text for display."""
          return "Online" if self._is_online else "Offline"
  ```
- **UI Integration**: Status bar or settings dialog
- **User Feedback**: Clear indication of network status

### Task 6.4.4: Implement Rate Limiting

**What to Build**
- Rate limit detection
- Request throttling
- Rate limit headers parsing
- Adaptive rate limiting

**Implementation Details**

**6.4.4.1 Rate Limiting Implementation**
- **Purpose**: Respect rate limits and avoid overwhelming servers
- **Implementation**:
  ```python
  import time
  from collections import deque
  from threading import Lock
  
  class RateLimiter:
      """Rate limiter for API requests."""
      
      def __init__(self, max_requests: int = 10, time_window: float = 1.0):
          """Initialize rate limiter.
          
          Args:
              max_requests: Maximum requests per time window
              time_window: Time window in seconds
          """
          self.max_requests = max_requests
          self.time_window = time_window
          self.requests = deque()
          self.lock = Lock()
      
      def acquire(self) -> bool:
          """Acquire permission to make request.
          
          Returns:
              True if request allowed, False if rate limited
          """
          with self.lock:
              now = time.time()
              
              # Remove old requests outside time window
              while self.requests and self.requests[0] < now - self.time_window:
                  self.requests.popleft()
              
              # Check if under limit
              if len(self.requests) < self.max_requests:
                  self.requests.append(now)
                  return True
              
              return False
      
      def wait_if_needed(self):
          """Wait if rate limited.
          
          Blocks until request can be made.
          """
          while not self.acquire():
              # Calculate wait time
              if self.requests:
                  oldest = self.requests[0]
                  wait_time = self.time_window - (time.time() - oldest) + 0.1
                  if wait_time > 0:
                      time.sleep(wait_time)
      
      def get_wait_time(self) -> float:
          """Get time to wait before next request.
          
          Returns:
              Wait time in seconds (0 if no wait needed)
          """
          with self.lock:
              if len(self.requests) < self.max_requests:
                  return 0.0
              
              if self.requests:
                  oldest = self.requests[0]
                  wait_time = self.time_window - (time.time() - oldest)
                  return max(0.0, wait_time)
              
              return 0.0
  ```
- **Usage**: Call before making requests
- **Configuration**: Can be configured per domain

**6.4.4.2 Rate Limit Header Parsing**
- **Purpose**: Parse rate limit headers from responses
- **Implementation**:
  ```python
  class RateLimitParser:
      """Parse rate limit information from HTTP headers."""
      
      @staticmethod
      def parse_headers(response: requests.Response) -> Optional[Dict[str, int]]:
          """Parse rate limit headers.
          
          Args:
              response: HTTP response
              
          Returns:
              Dictionary with rate limit info or None
          """
          rate_limit_info = {}
          
          # Common rate limit headers
          if 'X-RateLimit-Remaining' in response.headers:
              rate_limit_info['remaining'] = int(response.headers['X-RateLimit-Remaining'])
          
          if 'X-RateLimit-Reset' in response.headers:
              rate_limit_info['reset'] = int(response.headers['X-RateLimit-Reset'])
          
          if 'Retry-After' in response.headers:
              rate_limit_info['retry_after'] = int(response.headers['Retry-After'])
          
          return rate_limit_info if rate_limit_info else None
  ```
- **Usage**: Update rate limiter based on server response
- **Benefits**: Adaptive rate limiting based on server feedback

### Task 6.4.5: Implement Network Error Handling

**What to Build**
- Network error classification
- User-friendly error messages
- Error recovery strategies
- Network error UI feedback

**Implementation Details**

**6.4.5.1 Error Classification**
- **Purpose**: Classify network errors for appropriate handling
- **Error Types**:
  - Connection errors (no network, DNS failure)
  - Timeout errors (server too slow)
  - HTTP errors (4xx, 5xx)
  - Rate limit errors (429)
  - SSL errors (certificate issues)
- **Implementation**:
  ```python
  class NetworkError(Exception):
      """Base class for network errors."""
      pass
  
  class ConnectionError(NetworkError):
      """Network connection error."""
      pass
  
  class TimeoutError(NetworkError):
      """Network timeout error."""
      pass
  
  class RateLimitError(NetworkError):
      """Rate limit exceeded error."""
      def __init__(self, retry_after: Optional[int] = None):
          super().__init__("Rate limit exceeded")
          self.retry_after = retry_after
  
  def classify_error(exception: Exception) -> NetworkError:
      """Classify exception into network error type.
      
      Args:
          exception: Exception to classify
          
      Returns:
          Classified NetworkError
      """
      if isinstance(exception, requests.exceptions.ConnectionError):
          return ConnectionError(str(exception))
      elif isinstance(exception, requests.exceptions.Timeout):
          return TimeoutError(str(exception))
      elif isinstance(exception, requests.exceptions.HTTPError):
          if exception.response.status_code == 429:
              retry_after = exception.response.headers.get('Retry-After')
              return RateLimitError(int(retry_after) if retry_after else None)
          return NetworkError(f"HTTP {exception.response.status_code}: {exception}")
      else:
          return NetworkError(str(exception))
  ```
- **Usage**: Classify errors for appropriate handling
- **Benefits**: Enables specific error handling strategies

**6.4.5.2 User-Friendly Error Messages**
- **Purpose**: Convert technical errors to user-friendly messages
- **Implementation**:
  ```python
  class ErrorMessageFormatter:
      """Format network errors for user display."""
      
      @staticmethod
      def format_error(error: NetworkError) -> str:
          """Format error for user display.
          
          Args:
              error: NetworkError instance
              
          Returns:
              User-friendly error message
          """
          if isinstance(error, ConnectionError):
              return (
                  "Unable to connect to the server. Please check your internet connection "
                  "and try again."
              )
          elif isinstance(error, TimeoutError):
              return (
                  "The request took too long to complete. The server may be slow or "
                  "your connection may be unstable. Please try again."
              )
          elif isinstance(error, RateLimitError):
              if error.retry_after:
                  return (
                      f"Too many requests. Please wait {error.retry_after} seconds "
                      f"before trying again."
                  )
              return "Too many requests. Please wait a moment before trying again."
          else:
              return (
                  "A network error occurred. Please check your connection and try again. "
                  "If the problem persists, contact support."
              )
  ```
- **UI Integration**: Show in error dialogs and status messages
- **Benefits**: Users understand what went wrong

## Implementation Checklist

### Documentation Tasks
- [ ] Document timeout policies
- [ ] Document retry behavior
- [ ] Document rate limiting
- [ ] Document error handling

### Code Analysis Tasks
- [ ] Review existing network code
- [ ] Identify all HTTP requests
- [ ] Check timeout usage
- [ ] Review error handling

### Implementation Tasks (Code)
- [ ] Create network.py utility module
- [ ] Implement timeout configuration
- [ ] Implement retry mechanism
- [ ] Implement rate limiting
- [ ] Implement network state detection
- [ ] Update all HTTP requests to use new utilities
- [ ] Add network status UI
- [ ] Add error handling UI

### Testing Tasks
- [ ] Test timeout behavior
- [ ] Test retry mechanism
- [ ] Test rate limiting
- [ ] Test network state detection
- [ ] Test error handling
- [ ] Test error messages

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/utils/network.py` - Network utilities
2. `SRC/cuepoint/utils/retry.py` - Retry mechanism (if separate)

### Files to Modify
1. `SRC/cuepoint/data/beatport.py` - Use new network utilities
2. `SRC/cuepoint/data/beatport_search.py` - Use new network utilities
3. All other modules making HTTP requests

## Implementation Dependencies

### Prerequisites
- Step 6.2: Logging (logs network operations)
- requests library
- Network connectivity

### Enables
- Reliable network operations
- Better error recovery
- Improved user experience
- Performance optimization

## Success Criteria

### Functional
- ✅ All requests have timeouts
- ✅ Retry mechanism works
- ✅ Rate limiting respected
- ✅ Network state detected
- ✅ Clear error messages
- ✅ User feedback during retries

### Technical
- ✅ Timeout configuration works
- ✅ Exponential backoff implemented
- ✅ Rate limiting prevents overload
- ✅ Network state cached appropriately
- ✅ Error classification accurate

### User Experience
- ✅ Clear error messages
- ✅ Retry status shown
- ✅ Network status visible
- ✅ Operations don't hang
- ✅ Graceful error recovery

## Next Implementation Steps

After completing Step 6.4:
1. **Step 6.5**: Caching Strategy (uses network for cache validation)
2. **Step 6.6**: Performance (monitors network performance)

## Detailed Implementation Guidance

### Network Reliability Best Practices

**Timeout Configuration**:
- Set appropriate timeouts for each operation type
- Don't set timeouts too short (causes false failures)
- Don't set timeouts too long (causes hangs)
- Allow user configuration for advanced users

**Retry Strategy**:
- Retry transient errors (connection, timeout, 5xx)
- Don't retry client errors (4xx except 429)
- Use exponential backoff
- Add jitter to prevent thundering herd
- Limit maximum retries

**Rate Limiting**:
- Respect server rate limits
- Parse rate limit headers
- Implement client-side rate limiting
- Show rate limit status to users
- Queue requests when rate limited

### Performance Considerations

**Network Overhead**:
- Minimize number of requests
- Use connection pooling
- Cache responses when possible
- Batch requests when possible
- Compress requests/responses

**Timeout Impact**:
- Balance timeout length with user experience
- Use different timeouts for different operations
- Consider user's connection speed
- Allow configuration for slow connections

### Error Handling Strategies

**Error Recovery**:
- Automatic retry for transient errors
- User notification for persistent errors
- Fallback mechanisms when possible
- Clear error messages
- Recovery suggestions

**Error Classification**:
- Classify errors by type
- Different handling for different error types
- User-friendly error messages
- Technical details available for debugging
- Error logging for analysis

**Network Error UI**:
- Show error status in UI
- Provide retry buttons
- Show network status indicator
- Display error details on demand
- Suggest solutions when possible

### Integration with Existing Code

**Beatport Integration**:
- Update `beatport.py` to use new network utilities
- Replace existing retry logic with standardized retry
- Add timeout configuration
- Add rate limiting
- Improve error handling

**Search Integration**:
- Update `beatport_search.py` to use new utilities
- Add network state checking
- Improve error messages
- Add retry feedback

**All HTTP Requests**:
- Audit all HTTP requests in codebase
- Replace with standardized network utilities
- Add timeout configuration
- Add retry logic
- Add error handling

### Advanced Features

**Connection Pooling**:
- Reuse connections for better performance
- Configure pool size appropriately
- Handle connection errors gracefully
- Monitor connection pool usage

**Request Compression**:
- Compress large requests when possible
- Handle compressed responses
- Monitor compression overhead
- Configure compression levels

**HTTP/2 Support**:
- Use HTTP/2 when available
- Fallback to HTTP/1.1
- Monitor protocol usage
- Optimize for HTTP/2 features

**Proxy Support**:
- Detect and use system proxy
- Allow manual proxy configuration
- Handle proxy authentication
- Test with proxy configurations

### Testing Network Reliability

**Test Scenarios**:
- Network unavailable
- Slow network connection
- Intermittent connectivity
- Server errors (5xx)
- Rate limiting (429)
- Timeout scenarios
- DNS failures
- SSL certificate issues

**Test Tools**:
- Network throttling tools
- Proxy servers for testing
- Mock servers for error simulation
- Network monitoring tools

**Test Coverage**:
- All timeout scenarios
- All retry scenarios
- All error types
- Rate limiting behavior
- Network state detection
- Error message accuracy

## References

- Main document: `../06_Runtime_Operational_Design.md`
- requests library: https://requests.readthedocs.io/
- urllib3 retry: https://urllib3.readthedocs.io/en/stable/reference/urllib3.util.html#urllib3.util.retry.Retry
- Step 6.2: Logging (logs network operations)
- Step 6.5: Caching Strategy (reduces network requests)
- Network Best Practices: https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview


