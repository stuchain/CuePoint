# Implementation Step 6.3: Crash Handling

## Implementation Overview
**What We're Building**: A comprehensive crash handling system that captures unhandled exceptions, generates user-friendly crash dialogs, creates detailed crash reports with diagnostic information, and produces support bundles for troubleshooting. This system ensures that CuePoint can recover gracefully from errors, provides users with actionable information, and gives developers the diagnostic data needed to fix issues while maintaining a professional user experience even during failures.

## Implementation Tasks

### Task 6.3.1: Implement Global Exception Handler

**What to Build**
- Global exception hook
- Unhandled exception capture
- User-friendly error dialogs
- Crash log generation
- Exception context collection

**Implementation Details**

**6.3.1.1 Global Exception Hook**
- **Purpose**: Catch all unhandled exceptions before they crash the application
- **Rationale**:
  - Prevents abrupt application termination
  - Allows graceful error handling
  - Enables crash reporting
  - Provides better user experience
- **File to Create/Modify**: `SRC/cuepoint/utils/crash_handler.py`
- **Implementation**:
  ```python
  import sys
  import traceback
  from typing import Optional, Callable
  from PySide6.QtCore import QObject, Signal
  from PySide6.QtWidgets import QApplication
  
  from cuepoint.utils.crash_logger import CrashLogger
  from cuepoint.utils.logger import CuePointLogger
  
  class CrashHandler(QObject):
      """Global crash handler for unhandled exceptions."""
      
      # Signal emitted when crash occurs
      crash_occurred = Signal(Exception, str)  # exception, traceback
      
      def __init__(self):
          super().__init__()
          self._original_excepthook = sys.excepthook
          self._crash_dialog_shown = False
          self._install_handler()
      
      def _install_handler(self):
          """Install global exception handler."""
          sys.excepthook = self._handle_exception
      
      def _handle_exception(self, exc_type, exc_value, exc_traceback):
          """Handle unhandled exception.
          
          Args:
              exc_type: Exception type
              exc_value: Exception value
              exc_traceback: Traceback object
          """
          # Don't handle if in interactive mode (for debugging)
          if hasattr(sys, 'ps1'):
              self._original_excepthook(exc_type, exc_value, exc_traceback)
              return
          
          # Create exception object
          exception = exc_value if isinstance(exc_value, Exception) else exc_type()
          
          # Get full traceback
          traceback_str = ''.join(
              traceback.format_exception(exc_type, exc_value, exc_traceback)
          )
          
          # Log the crash
          logger = logging.getLogger(__name__)
          logger.critical(
              f"Unhandled exception: {exc_type.__name__}: {exc_value}",
              exc_info=(exc_type, exc_value, exc_traceback)
          )
          
          # Create crash log
          crash_log = CrashLogger.create_crash_log()
          CrashLogger.write_crash_info(crash_log, exception, traceback_str)
          
          # Show crash dialog (only once)
          if not self._crash_dialog_shown:
              self._crash_dialog_shown = True
              self._show_crash_dialog(exception, traceback_str, crash_log)
          
          # Emit signal
          self.crash_occurred.emit(exception, traceback_str)
      
      def _show_crash_dialog(self, exception: Exception, traceback_str: str, crash_log: Path):
          """Show crash dialog to user.
          
          Args:
              exception: Exception that caused crash
              traceback_str: Full traceback
              crash_log: Path to crash log file
          """
          # Use QApplication to show dialog
          app = QApplication.instance()
          if app is None:
              # No GUI available, just exit
              sys.exit(1)
          
          from cuepoint.ui.dialogs.crash_dialog import CrashDialog
          dialog = CrashDialog(exception, traceback_str, crash_log)
          dialog.exec()
      
      def restore_handler(self):
          """Restore original exception handler."""
          sys.excepthook = self._original_excepthook
  ```
- **Integration**: Installed at application startup
- **Thread Safety**: Should handle exceptions from any thread
- **GUI Thread**: Crash dialog must be shown on GUI thread

**6.3.1.2 Thread Exception Handling**
- **Purpose**: Handle exceptions in background threads
- **Rationale**: Exceptions in threads don't trigger sys.excepthook by default
- **Implementation**:
  ```python
  import threading
  
  class ThreadExceptionHandler:
      """Handle exceptions in background threads."""
      
      @staticmethod
      def install_thread_exception_handler():
          """Install exception handler for threads."""
          def thread_exception_handler(args):
              exc_type, exc_value, exc_traceback = args.exc_type, args.exc_value, args.exc_traceback
              
              # Log exception
              logger = logging.getLogger(__name__)
              logger.error(
                  f"Unhandled exception in thread {threading.current_thread().name}: "
                  f"{exc_type.__name__}: {exc_value}",
                  exc_info=(exc_type, exc_value, exc_traceback)
              )
              
              # Create crash log
              exception = exc_value if isinstance(exc_value, Exception) else exc_type()
              traceback_str = ''.join(
                  traceback.format_exception(exc_type, exc_value, exc_traceback)
              )
              
              crash_log = CrashLogger.create_crash_log()
              CrashLogger.write_crash_info(crash_log, exception, traceback_str)
              
              # Show error dialog (on main thread)
              QApplication.instance().postEvent(
                  QApplication.instance(),
                  ThreadExceptionEvent(exception, traceback_str, crash_log)
              )
          
          threading.excepthook = thread_exception_handler
  ```
- **Integration**: Called at application startup
- **Thread Safety**: Handles exceptions from any thread

**6.3.1.3 Exception Context Collection**
- **Purpose**: Collect context information when exception occurs
- **Context to Collect**:
  - Application state (what user was doing)
  - Recent user actions
  - System state (memory, disk space)
  - Configuration settings (non-sensitive)
  - Recent log entries
- **Implementation**:
  ```python
  class ExceptionContext:
      """Collect context information for exceptions."""
      
      _context_stack = []
      
      @staticmethod
      def push_context(context: str):
          """Push context onto stack.
          
          Args:
              context: Context description
          """
          ExceptionContext._context_stack.append({
              "context": context,
              "timestamp": datetime.now().isoformat()
          })
          
          # Keep only last 10 contexts
          if len(ExceptionContext._context_stack) > 10:
              ExceptionContext._context_stack.pop(0)
      
      @staticmethod
      def pop_context():
          """Pop context from stack."""
          if ExceptionContext._context_stack:
              ExceptionContext._context_stack.pop()
      
      @staticmethod
      def get_context() -> Dict[str, Any]:
          """Get current context information.
          
          Returns:
              Dictionary with context information
          """
          import psutil
          import platform
          
          context = {
              "application_context": list(ExceptionContext._context_stack),
              "system": {
                  "platform": platform.system(),
                  "platform_version": platform.version(),
                  "cpu_count": psutil.cpu_count(),
                  "memory_total": psutil.virtual_memory().total,
                  "memory_available": psutil.virtual_memory().available,
                  "disk_free": psutil.disk_usage('/').free,
              },
              "application": {
                  "version": get_version(),
                  "build_number": get_build_number(),
              }
          }
          
          return context
  ```
- **Usage**: Push context before operations, pop after
- **Benefits**: Helps identify what user was doing when crash occurred

### Task 6.3.2: Implement Crash Report Generation

**What to Build**
- Crash report format
- Crash report generation
- Crash report storage
- Crash report metadata

**Implementation Details**

**6.3.2.1 Crash Report Format**
- **Purpose**: Standardized format for crash reports
- **Format**: JSON with structured information
- **Fields**:
  - Timestamp
  - Exception type and message
  - Full traceback
  - System information
  - Application version
  - Context information
  - Recent log entries
  - User actions (if available)
- **Implementation**:
  ```python
  import json
  from datetime import datetime
  
  class CrashReport:
      """Generate structured crash reports."""
      
      @staticmethod
      def generate_report(
          exception: Exception,
          traceback_str: str,
          context: Optional[Dict] = None
      ) -> Dict[str, Any]:
          """Generate crash report.
          
          Args:
              exception: Exception that caused crash
              traceback_str: Full traceback
              context: Additional context information
              
          Returns:
              Crash report dictionary
          """
          from cuepoint.utils.exception_context import ExceptionContext
          from cuepoint.utils.path_diagnostics import PathDiagnostics
          from cuepoint.version import get_build_info
          import platform
          
          report = {
              "timestamp": datetime.now().isoformat(),
              "exception": {
                  "type": type(exception).__name__,
                  "message": str(exception),
                  "traceback": traceback_str,
              },
              "application": get_build_info(),
              "system": {
                  "platform": platform.system(),
                  "platform_version": platform.version(),
                  "python_version": platform.python_version(),
              },
              "context": context or ExceptionContext.get_context(),
              "paths": PathDiagnostics.collect_diagnostics(),
              "recent_logs": CrashLogger._get_recent_logs(200),
          }
          
          return report
      
      @staticmethod
      def save_report(report: Dict[str, Any], file_path: Path) -> None:
          """Save crash report to file.
          
          Args:
              report: Crash report dictionary
              file_path: Path to save report
          """
          with open(file_path, 'w', encoding='utf-8') as f:
              json.dump(report, f, indent=2, ensure_ascii=False)
  ```
- **Storage**: Saved alongside crash log
- **Format**: JSON for easy parsing and analysis

**6.3.2.2 Crash Report Metadata**
- **Purpose**: Add metadata to crash reports for analysis
- **Metadata Fields**:
  - Report ID (unique identifier)
  - User ID (if available, anonymized)
  - Session ID
  - Crash frequency (how many times this crash occurred)
  - Previous crashes (related crash IDs)
- **Implementation**:
  ```python
  import uuid
  import hashlib
  
  class CrashReportMetadata:
      """Add metadata to crash reports."""
      
      @staticmethod
      def generate_report_id(exception_type: str, traceback_str: str) -> str:
          """Generate unique report ID based on exception.
          
          Args:
              exception_type: Exception type name
              traceback_str: Traceback string
              
          Returns:
              Unique report ID
          """
          # Create hash from exception type and first few lines of traceback
          hash_input = f"{exception_type}\n{traceback_str[:500]}"
          hash_obj = hashlib.sha256(hash_input.encode())
          return hash_obj.hexdigest()[:16]
      
      @staticmethod
      def add_metadata(report: Dict[str, Any]) -> Dict[str, Any]:
          """Add metadata to crash report.
          
          Args:
              report: Crash report dictionary
              
          Returns:
              Report with metadata added
          """
          exception_type = report["exception"]["type"]
          traceback_str = report["exception"]["traceback"]
          
          report["metadata"] = {
              "report_id": CrashReportMetadata.generate_report_id(
                  exception_type,
                  traceback_str
              ),
              "session_id": str(uuid.uuid4()),
              "timestamp": report["timestamp"],
          }
          
          return report
  ```
- **Benefits**: Enables crash grouping and analysis
- **Privacy**: Should not include personally identifiable information

### Task 6.3.3: Implement Support Bundle Creation

**What to Build**
- Support bundle format
- Support bundle generation
- File collection logic
- Bundle compression
- Bundle validation

**Implementation Details**

**6.3.3.1 Support Bundle Format**
- **Purpose**: Standardized format for support bundles
- **Format**: ZIP file containing diagnostic information
- **Contents**:
  - `diagnostics.json`: System and application diagnostics
  - `crash_report.json`: Latest crash report (if crash occurred)
  - `logs/cuepoint.log*`: Recent log files
  - `logs/crashes/crash-*.log`: Crash logs
  - `config/config.yaml`: Configuration file (sanitized)
  - `paths.json`: Path information
- **Implementation**:
  ```python
  import zipfile
  from pathlib import Path
  from typing import List
  
  class SupportBundle:
      """Generate support bundles for troubleshooting."""
      
      @staticmethod
      def create_bundle(output_path: Optional[Path] = None) -> Path:
          """Create support bundle.
          
          Args:
              output_path: Output path for bundle (default: exports_dir)
              
          Returns:
              Path to created bundle
          """
          if output_path is None:
              output_path = AppPaths.exports_dir() / f"cuepoint-support-{datetime.now().strftime('%Y%m%d-%H%M%S')}.zip"
          
          with zipfile.ZipFile(output_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
              # Add diagnostics
              SupportBundle._add_diagnostics(zipf)
              
              # Add crash reports
              SupportBundle._add_crash_reports(zipf)
              
              # Add logs
              SupportBundle._add_logs(zipf)
              
              # Add configuration (sanitized)
              SupportBundle._add_config(zipf)
              
              # Add path information
              SupportBundle._add_paths(zipf)
          
          return output_path
      
      @staticmethod
      def _add_diagnostics(zipf: zipfile.ZipFile):
          """Add diagnostics to bundle."""
          from cuepoint.utils.diagnostics import collect_diagnostics
          
          diagnostics = collect_diagnostics()
          
          zipf.writestr(
              "diagnostics.json",
              json.dumps(diagnostics, indent=2, ensure_ascii=False)
          )
      
      @staticmethod
      def _add_crash_reports(zipf: zipfile.ZipFile):
          """Add crash reports to bundle."""
          crashes_dir = AppPaths.logs_dir() / "crashes"
          
          if crashes_dir.exists():
              for crash_file in crashes_dir.glob("crash-*.log"):
                  zipf.write(
                      crash_file,
                      f"logs/crashes/{crash_file.name}"
                  )
              
              # Add latest crash report JSON if exists
              crash_reports = list(crashes_dir.glob("crash-*.json"))
              if crash_reports:
                  latest = max(crash_reports, key=lambda p: p.stat().st_mtime)
                  zipf.write(latest, "crash_report.json")
      
      @staticmethod
      def _add_logs(zipf: zipfile.ZipFile):
          """Add log files to bundle."""
          logs_dir = AppPaths.logs_dir()
          log_file = CuePointLogger.get_log_file()
          
          # Add main log and rotated logs
          for log_file_path in [log_file] + list(logs_dir.glob(f"{log_file.stem}.log.*")):
              if log_file_path.exists():
                  zipf.write(
                      log_file_path,
                      f"logs/{log_file_path.name}"
                  )
      
      @staticmethod
      def _add_config(zipf: zipfile.ZipFile):
          """Add configuration to bundle (sanitized)."""
          config_file = AppPaths.config_file()
          
          if config_file.exists():
              # Read and sanitize config
              with open(config_file, 'r', encoding='utf-8') as f:
                  config_content = f.read()
              
              # Sanitize sensitive information
              sanitized = SupportBundle._sanitize_config(config_content)
              
              zipf.writestr("config/config.yaml", sanitized)
      
      @staticmethod
      def _sanitize_config(config_content: str) -> str:
          """Remove sensitive information from config.
          
          Args:
              config_content: Original config content
              
          Returns:
              Sanitized config content
          """
          import re
          
          # Patterns to redact
          patterns = [
              (r'password\s*:\s*["\']?([^"\'\n]+)', 'password: "***REDACTED***"'),
              (r'api[_-]?key\s*:\s*["\']?([^"\'\n]+)', 'api_key: "***REDACTED***"'),
              (r'token\s*:\s*["\']?([^"\'\n]+)', 'token: "***REDACTED***"'),
          ]
          
          sanitized = config_content
          for pattern, replacement in patterns:
              sanitized = re.sub(pattern, replacement, sanitized, flags=re.IGNORECASE)
          
          return sanitized
      
      @staticmethod
      def _add_paths(zipf: zipfile.ZipFile):
          """Add path information to bundle."""
          from cuepoint.utils.path_diagnostics import PathDiagnostics
          
          paths = PathDiagnostics.collect_diagnostics()
          
          zipf.writestr(
              "paths.json",
              json.dumps(paths, indent=2, ensure_ascii=False)
          )
  ```
- **Size Limits**: Should warn if bundle is very large
- **Compression**: Use ZIP compression to reduce size
- **Privacy**: Sanitize sensitive information

**6.3.3.2 Bundle Generation UI**
- **Purpose**: Allow users to generate support bundles
- **Implementation Location**: Settings dialog or crash dialog
- **UI Flow**:
  1. User clicks "Export Support Bundle"
  2. Show progress dialog
  3. Generate bundle
  4. Show completion message with file location
  5. Option to open file location
- **Implementation**:
  ```python
  from PySide6.QtWidgets import QProgressDialog, QMessageBox
  from PySide6.QtCore import QThread, Signal
  
  class BundleGenerationThread(QThread):
      """Thread for generating support bundle."""
      
      finished = Signal(Path)
      error = Signal(str)
      
      def run(self):
          try:
              bundle_path = SupportBundle.create_bundle()
              self.finished.emit(bundle_path)
          except Exception as e:
              self.error.emit(str(e))
  
  def generate_support_bundle(parent_widget):
      """Generate support bundle with progress dialog."""
      progress = QProgressDialog(
          "Generating support bundle...",
          "Cancel",
          0,
          0,
          parent_widget
      )
      progress.setWindowModality(Qt.WindowModal)
      progress.show()
      
      thread = BundleGenerationThread()
      
      def on_finished(bundle_path):
          progress.close()
          QMessageBox.information(
              parent_widget,
              "Support Bundle Created",
              f"Support bundle created:\n{bundle_path}\n\n"
              f"You can share this file with support."
          )
      
      def on_error(error_msg):
          progress.close()
          QMessageBox.critical(
              parent_widget,
              "Error",
              f"Failed to create support bundle:\n{error_msg}"
          )
      
      thread.finished.connect(on_finished)
      thread.error.connect(on_error)
      thread.start()
  ```
- **User Experience**: Should be fast (< 5 seconds for typical bundle)
- **Error Handling**: Clear error messages if generation fails

### Task 6.3.4: Implement Crash Dialog UI

**What to Build**
- User-friendly crash dialog
- Error message display
- Action buttons (Report, Ignore, Restart)
- Support bundle generation option
- Crash report viewing

**Implementation Details**

**6.3.4.1 Crash Dialog Design**
- **Purpose**: Show user-friendly crash dialog instead of raw exception
- **Design Principles**:
  - Non-technical language
  - Clear explanation of what happened
  - Actionable options
  - Option to continue or restart
- **File to Create**: `SRC/cuepoint/ui/dialogs/crash_dialog.py`
- **Implementation**:
  ```python
  from PySide6.QtWidgets import (
      QDialog, QVBoxLayout, QHBoxLayout, QLabel,
      QPushButton, QTextEdit, QCheckBox, QMessageBox
  )
  from PySide6.QtCore import Qt
  
  class CrashDialog(QDialog):
      """User-friendly crash dialog."""
      
      def __init__(self, exception: Exception, traceback_str: str, crash_log: Path):
          super().__init__()
          self.exception = exception
          self.traceback_str = traceback_str
          self.crash_log = crash_log
          
          self._setup_ui()
      
      def _setup_ui(self):
          """Setup dialog UI."""
          self.setWindowTitle("Application Error")
          self.setMinimumWidth(600)
          self.setMinimumHeight(400)
          
          layout = QVBoxLayout(self)
          
          # Title
          title = QLabel("CuePoint Encountered an Error")
          title_font = title.font()
          title_font.setPointSize(14)
          title_font.setBold(True)
          title.setFont(title_font)
          layout.addWidget(title)
          
          # Error message
          error_msg = QLabel(
              f"An unexpected error occurred:\n\n"
              f"{type(self.exception).__name__}: {str(self.exception)}\n\n"
              f"The error has been logged. You can continue using the application, "
              f"or restart to ensure everything is working correctly."
          )
          error_msg.setWordWrap(True)
          layout.addWidget(error_msg)
          
          # Technical details (collapsible)
          self.details_shown = False
          self.details_text = QTextEdit()
          self.details_text.setPlainText(self.traceback_str)
          self.details_text.setReadOnly(True)
          self.details_text.setMaximumHeight(200)
          self.details_text.hide()
          
          show_details_btn = QPushButton("Show Technical Details")
          show_details_btn.clicked.connect(self._toggle_details)
          layout.addWidget(show_details_btn)
          layout.addWidget(self.details_text)
          
          # Options
          self.send_report = QCheckBox("Send crash report to help improve CuePoint")
          self.send_report.setChecked(True)
          layout.addWidget(self.send_report)
          
          # Buttons
          buttons = QHBoxLayout()
          
          generate_bundle_btn = QPushButton("Generate Support Bundle")
          generate_bundle_btn.clicked.connect(self._generate_bundle)
          buttons.addWidget(generate_bundle_btn)
          
          buttons.addStretch()
          
          continue_btn = QPushButton("Continue")
          continue_btn.setDefault(True)
          continue_btn.clicked.connect(self.accept)
          buttons.addWidget(continue_btn)
          
          restart_btn = QPushButton("Restart Application")
          restart_btn.clicked.connect(self._restart_app)
          buttons.addWidget(restart_btn)
          
          layout.addLayout(buttons)
      
      def _toggle_details(self):
          """Toggle technical details display."""
          self.details_shown = not self.details_shown
          self.details_text.setVisible(self.details_shown)
          sender = self.sender()
          sender.setText("Hide Technical Details" if self.details_shown else "Show Technical Details")
      
      def _generate_bundle(self):
          """Generate support bundle."""
          from cuepoint.utils.support_bundle import generate_support_bundle
          generate_support_bundle(self)
      
      def _restart_app(self):
          """Restart application."""
          reply = QMessageBox.question(
              self,
              "Restart Application",
              "Are you sure you want to restart CuePoint?",
              QMessageBox.Yes | QMessageBox.No
          )
          
          if reply == QMessageBox.Yes:
              # Restart logic
              QApplication.instance().quit()
              # Restart would be handled by external script or launcher
              sys.exit(0)
  ```
- **User Experience**: Should be clear and non-intimidating
- **Actions**: Provide clear options for user
- **Privacy**: Ask permission before sending reports

## Implementation Checklist

### Documentation Tasks
- [ ] Document crash handling behavior
- [ ] Document support bundle contents
- [ ] Document crash report format
- [ ] Create user guide for crash reporting

### Code Analysis Tasks
- [ ] Review all exception handling
- [ ] Identify common crash scenarios
- [ ] Review error messages for clarity
- [ ] Check for exception swallowing

### Implementation Tasks (Code)
- [ ] Create crash_handler.py
- [ ] Create crash_dialog.py
- [ ] Enhance support_bundle.py
- [ ] Implement exception context collection
- [ ] Add crash handler to app startup
- [ ] Add thread exception handling
- [ ] Create crash report generation
- [ ] Add support bundle UI

### Testing Tasks
- [ ] Test crash handler with various exceptions
- [ ] Test crash dialog display
- [ ] Test support bundle generation
- [ ] Test crash log creation
- [ ] Test thread exception handling
- [ ] Test exception context collection

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/utils/crash_handler.py` - Global crash handler
2. `SRC/cuepoint/utils/exception_context.py` - Exception context collection
3. `SRC/cuepoint/ui/dialogs/crash_dialog.py` - Crash dialog UI

### Files to Modify
1. `SRC/cuepoint/utils/crash_logger.py` - Enhance crash logging (if exists)
2. `SRC/cuepoint/utils/support_bundle.py` - Enhance support bundle (if exists)
3. `SRC/gui_app.py` - Install crash handler at startup
4. `SRC/cuepoint/ui/dialogs/settings_dialog.py` - Add support bundle generation

## Implementation Dependencies

### Prerequisites
- Step 6.1: File System Locations (needs paths for crash logs)
- Step 6.2: Logging (uses logging for crash reports)
- Qt/PySide6 installed

### Enables
- Better error recovery
- Easier debugging
- User support
- Crash analysis

## Success Criteria

### Functional
- ✅ All unhandled exceptions caught
- ✅ User-friendly crash dialogs shown
- ✅ Crash logs created
- ✅ Support bundles generated
- ✅ Crash reports include context
- ✅ Thread exceptions handled

### Technical
- ✅ Crash handler installed at startup
- ✅ Exception context collected
- ✅ Crash reports in standard format
- ✅ Support bundles complete
- ✅ No sensitive information in reports

### User Experience
- ✅ Clear error messages
- ✅ Actionable options
- ✅ Easy support bundle generation
- ✅ Option to continue or restart
- ✅ Non-intimidating crash dialogs

## Next Implementation Steps

After completing Step 6.3:
1. **Step 6.4**: Networking Reliability (handles network errors)
2. **Step 6.6**: Performance (monitors for performance issues)
3. **Step 6.7**: Backups and Safety (prevents data loss)

## Detailed Implementation Guidance

### Crash Handling Best Practices

**Exception Handling**:
- Catch exceptions at appropriate levels
- Provide context when catching
- Log all exceptions
- Don't swallow exceptions silently

**User Communication**:
- Use non-technical language
- Explain what happened
- Provide clear next steps
- Don't blame the user

**Crash Reporting**:
- Collect useful context
- Include system information
- Include recent actions
- Protect user privacy

### Performance Considerations

**Crash Handler Overhead**:
- Minimal overhead when no crashes
- Fast crash detection
- Efficient context collection
- Async support bundle generation

**Crash Log Management**:
- Rotate crash logs
- Clean up old crash logs
- Limit crash log size
- Compress old crash logs

### Security and Privacy

**Sensitive Information**:
- Never include passwords or tokens
- Sanitize configuration files
- Anonymize user information
- Review before sharing

**Crash Report Privacy**:
- Ask permission before sending
- Explain what's included
- Provide option to review
- Allow manual editing

## References

- Main document: `../06_Runtime_Operational_Design.md`
- Step 6.1: File System Locations (provides paths)
- Step 6.2: Logging (provides logging infrastructure)
- Python Exception Handling: https://docs.python.org/3/tutorial/errors.html

