# Implementation Step 2.5: CI Structure (GitHub Actions)

## Implementation Overview
**What We're Building**: Complete GitHub Actions CI/CD pipeline with test, build, and release workflows for macOS and Windows.

## Implementation Tasks

### Task 2.5.1: Create Test Workflow

**What to Build**
- Test job for both platforms
- Lint and type checking
- Large file gate
- Test reporting

**Implementation Details**

**2.5.1.1 Test Workflow File**
- **File to Create**: `.github/workflows/test.yml`
- **Implementation**:
  ```yaml
  name: Test
  on:
    push:
      branches: [main, phase_*]
    pull_request:
      branches: [main]
  
  jobs:
    test:
      strategy:
        matrix:
          os: [macos-latest, windows-latest]
          python-version: ['3.11']
      runs-on: ${{ matrix.os }}
      
      steps:
        - uses: actions/checkout@v4
        
        - name: Set up Python
          uses: actions/setup-python@v5
          with:
            python-version: ${{ matrix.python-version }}
        
        - name: Install dependencies
          run: |
            python -m pip install --upgrade pip
            pip install -r requirements.txt
            pip install -r requirements-dev.txt
        
        - name: Run linter
          run: |
            pylint SRC/
            mypy SRC/
        
        - name: Run tests
          run: |
            pytest tests/ -v --cov=SRC --cov-report=xml
        
        - name: Upload coverage
          uses: codecov/codecov-action@v3
          with:
            files: ./coverage.xml
        
        - name: Check for large files
          run: |
            find . -type f -size +50M ! -path "./.git/*" ! -path "./.venv/*" | while read file; do
              echo "ERROR: Large file detected: $file"
              exit 1
            done
  ```
- **Purpose**: Automated testing on both platforms
- **Location**: `.github/workflows/` directory

**2.5.1.2 Large File Gate**
- **File to Create**: `.github/workflows/large-file-check.yml`
- **Implementation**:
  ```yaml
  name: Large File Check
  on: [push, pull_request]
  jobs:
    check:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        - name: Check for large files
          run: |
            MAX_SIZE=52428800  # 50MB
            find . -type f ! -path "./.git/*" ! -path "./.venv/*" ! -path "./node_modules/*" | while read file; do
              size=$(stat -f%z "$file" 2>/dev/null || stat -c%s "$file" 2>/dev/null || echo 0)
              if [ "$size" -gt "$MAX_SIZE" ]; then
                echo "ERROR: Large file detected: $file ($size bytes)"
                exit 1
              fi
            done
  ```
- **Purpose**: Prevent large file commits
- **Integration**: Required check for PRs

### Task 2.5.2: Create macOS Build Workflow

**What to Build**
- macOS build job
- PyInstaller build
- Code signing
- Notarization
- DMG creation

**Implementation Details**

**2.5.2.1 macOS Build Workflow**
- **File to Create**: `.github/workflows/build-macos.yml`
- **Implementation**:
  ```yaml
  name: Build macOS
  on:
    push:
      tags:
        - 'v*'
    workflow_dispatch:
  
  jobs:
    build:
      runs-on: macos-latest
      steps:
        - uses: actions/checkout@v4
        
        - name: Set up Python
          uses: actions/setup-python@v5
          with:
            python-version: '3.11'
        
        - name: Install dependencies
          run: |
            python -m pip install --upgrade pip
            pip install -r requirements.txt
            pip install pyinstaller
        
        - name: Set build info
          run: python scripts/set_build_info.py
        
        - name: Build with PyInstaller
          run: |
            pyinstaller build/pyinstaller.spec
        
        - name: Import signing certificate
          env:
            MACOS_CERT_P12: ${{ secrets.MACOS_SIGNING_CERT_P12 }}
            MACOS_CERT_PASSWORD: ${{ secrets.MACOS_SIGNING_CERT_PASSWORD }}
          run: |
            # Create keychain
            security create-keychain -p "" build.keychain
            security default-keychain -s build.keychain
            security unlock-keychain -p "" build.keychain
            
            # Import certificate
            echo "$MACOS_CERT_P12" | base64 --decode > cert.p12
            security import cert.p12 -k build.keychain -P "$MACOS_CERT_PASSWORD" -T /usr/bin/codesign
            security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain
            
            # Sign app
            bash scripts/sign_macos.sh dist/CuePoint.app
        
        - name: Notarize
          env:
            APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
            APPLE_NOTARYTOOL_ISSUER_ID: ${{ secrets.APPLE_NOTARYTOOL_ISSUER_ID }}
            APPLE_NOTARYTOOL_KEY_ID: ${{ secrets.APPLE_NOTARYTOOL_KEY_ID }}
            APPLE_NOTARYTOOL_KEY: ${{ secrets.APPLE_NOTARYTOOL_KEY }}
          run: |
            # Configure notarytool
            xcrun notarytool store-credentials --apple-id "$APPLE_NOTARYTOOL_ISSUER_ID" \
              --team-id "$APPLE_TEAM_ID" \
              --key-id "$APPLE_NOTARYTOOL_KEY_ID" \
              --key "$APPLE_NOTARYTOOL_KEY" \
              --password "$APPLE_NOTARYTOOL_KEY" \
              notarytool-profile
            
            # Create DMG
            bash scripts/create_dmg.sh
            
            # Notarize DMG
            bash scripts/notarize_macos.sh dist/CuePoint-v*.dmg
        
        - name: Upload artifact
          uses: actions/upload-artifact@v4
          with:
            name: macos-dmg
            path: dist/*.dmg
  ```
- **Purpose**: Automated macOS build and signing
- **Dependencies**: Apple Developer certificates

### Task 2.5.3: Create Windows Build Workflow

**What to Build**
- Windows build job
- PyInstaller build
- Code signing
- NSIS installer creation

**Implementation Details**

**2.5.3.1 Windows Build Workflow**
- **File to Create**: `.github/workflows/build-windows.yml`
- **Implementation**:
  ```yaml
  name: Build Windows
  on:
    push:
      tags:
        - 'v*'
    workflow_dispatch:
  
  jobs:
    build:
      runs-on: windows-latest
      steps:
        - uses: actions/checkout@v4
        
        - name: Set up Python
          uses: actions/setup-python@v5
          with:
            python-version: '3.11'
        
        - name: Install dependencies
          run: |
            python -m pip install --upgrade pip
            pip install -r requirements.txt
            pip install pyinstaller
        
        - name: Install NSIS
          run: |
            choco install nsis -y
        
        - name: Set build info
          run: python scripts/set_build_info.py
        
        - name: Build with PyInstaller
          run: |
            pyinstaller build/pyinstaller.spec
        
        - name: Sign executable
          env:
            WINDOWS_CERT_PFX: ${{ secrets.WINDOWS_CERT_PFX }}
            WINDOWS_CERT_PASSWORD: ${{ secrets.WINDOWS_CERT_PASSWORD }}
          run: |
            # Import certificate
            $certPath = "cert.pfx"
            [System.Convert]::FromBase64String("$env:WINDOWS_CERT_PFX") | Set-Content -Path $certPath -Encoding Byte
            
            # Sign executable
            signtool sign /f $certPath /p "$env:WINDOWS_CERT_PASSWORD" /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 dist/CuePoint.exe
            
            # Verify
            signtool verify /pa /v dist/CuePoint.exe
        
        - name: Build installer
          run: |
            makensis scripts/installer.nsi
        
        - name: Sign installer
          run: |
            signtool sign /f $certPath /p "$env:WINDOWS_CERT_PASSWORD" /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 dist/CuePoint-v*-setup.exe
        
        - name: Upload artifact
          uses: actions/upload-artifact@v4
          with:
            name: windows-installer
            path: dist/*-setup.exe
  ```
- **Purpose**: Automated Windows build and signing
- **Dependencies**: Windows code signing certificate

### Task 2.5.4: Create Release Workflow

**What to Build**
- Release job
- GitHub Release creation
- Artifact upload
- Update feed generation

**Implementation Details**

**2.5.4.1 Release Workflow**
- **File to Create**: `.github/workflows/release.yml`
- **Implementation**:
  ```yaml
  name: Release
  on:
    push:
      tags:
        - 'v*'
  
  jobs:
    release:
      needs: [build-macos, build-windows]
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        
        - name: Download macOS artifact
          uses: actions/download-artifact@v4
          with:
            name: macos-dmg
            path: artifacts/macos
        
        - name: Download Windows artifact
          uses: actions/download-artifact@v4
          with:
            name: windows-installer
            path: artifacts/windows
        
        - name: Generate appcast
          run: |
            python scripts/generate_appcast.py
        
        - name: Create GitHub Release
          uses: softprops/action-gh-release@v1
          with:
            files: |
              artifacts/macos/*.dmg
              artifacts/windows/*.exe
            body_path: RELEASE_NOTES.md
          env:
            GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
        - name: Publish appcast
          run: |
            # Deploy appcast to GitHub Pages
            git config user.name "github-actions"
            git config user.email "github-actions@github.com"
            git checkout gh-pages
            cp appcast/* updates/
            git add updates/
            git commit -m "Update appcast for ${{ github.ref_name }}"
            git push
  ```
- **Purpose**: Automated release publishing
- **Dependencies**: Build jobs, GitHub token

## Implementation Checklist

### Test Workflow
- [ ] Create test workflow
- [ ] Add lint and type checks
- [ ] Add large file gate
- [ ] Configure test matrix

### macOS Build
- [ ] Create macOS build workflow
- [ ] Configure PyInstaller build
- [ ] Set up code signing
- [ ] Set up notarization
- [ ] Create DMG

### Windows Build
- [ ] Create Windows build workflow
- [ ] Configure PyInstaller build
- [ ] Set up code signing
- [ ] Create NSIS installer

### Release
- [ ] Create release workflow
- [ ] Configure artifact download
- [ ] Generate appcast
- [ ] Publish to GitHub Releases
- [ ] Deploy appcast to GitHub Pages

## Files to Create/Modify

### New Files
1. `.github/workflows/test.yml` - Test workflow
2. `.github/workflows/build-macos.yml` - macOS build
3. `.github/workflows/build-windows.yml` - Windows build
4. `.github/workflows/release.yml` - Release workflow
5. `.github/workflows/large-file-check.yml` - File size gate

### Files to Modify
1. `.gitignore` - Repository hygiene
2. `scripts/set_build_info.py` - Build info (Step 2.4)
3. `scripts/generate_appcast.py` - Appcast generation (Step 5)

## Implementation Dependencies

### Prerequisites
- Step 1: Product requirements
- Step 1.4: Distribution formats
- Step 1.7: Versioning

### Enables
- Step 3: macOS packaging (uses build workflow)
- Step 4: Windows packaging (uses build workflow)
- Step 5: Auto-update (uses release workflow)

## Success Criteria

### CI/CD
- ✅ All tests pass on both platforms
- ✅ Builds produce signed artifacts
- ✅ Releases published successfully
- ✅ Update feeds generated

## Next Implementation Steps

After completing Step 2.5:
1. **Step 2.6**: Artifact structure
2. **Step 2.7**: Secrets and certificates
3. **Step 3**: macOS packaging (uses build system)
4. **Step 4**: Windows packaging (uses build system)

## Detailed Implementation Guidance

### Test Workflow Details

#### Matrix Strategy
The test workflow uses a matrix strategy to test on multiple platforms:
```yaml
strategy:
  matrix:
    os: [macos-latest, windows-latest]
    python-version: ['3.11']
```

**Benefits**:
- Tests on both platforms in parallel
- Easy to add more Python versions
- Consistent test environment

**Considerations**:
- Each matrix job runs independently
- Artifacts from matrix jobs need separate handling
- Time increases with more matrix combinations

#### Dependency Caching
Use GitHub Actions caching to speed up builds:
```yaml
- name: Cache pip packages
  uses: actions/cache@v3
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('requirements*.txt') }}
    restore-keys: |
      ${{ runner.os }}-pip-
```

**Benefits**:
- Faster builds (especially on repeated runs)
- Reduced network usage
- More reliable builds

#### Test Reporting
Upload test results for better visibility:
```yaml
- name: Upload test results
  uses: actions/upload-artifact@v3
  if: always()
  with:
    name: test-results-${{ matrix.os }}
    path: test-results/
    retention-days: 30
```

#### Linting Configuration
Configure linters to fail on errors but allow warnings:
```yaml
- name: Run linter
  run: |
    pylint SRC/ --errors-only || true  # Warnings don't fail
    mypy SRC/ --ignore-missing-imports || exit 1  # Errors fail
```

### macOS Build Workflow Details

#### Build Environment
macOS builds run on `macos-latest`:
- **Runner**: GitHub-hosted macOS runner
- **Python**: 3.11 (via setup-python action)
- **Tools**: Xcode command line tools included
- **Limitations**: 2000 minutes/month free tier

#### Certificate Import Process
The certificate import is critical for signing:
```bash
# Create temporary keychain
security create-keychain -p "" build.keychain
security default-keychain -s build.keychain
security unlock-keychain -p "" build.keychain
security set-keychain-settings -t 3600 -u build.keychain

# Import certificate
echo "$MACOS_CERT_P12" | base64 --decode > cert.p12
security import cert.p12 -k build.keychain -P "$MACOS_CERT_PASSWORD" -T /usr/bin/codesign
security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "" build.keychain

# Clean up certificate file
rm -f cert.p12
```

**Security Considerations**:
- Certificate stored in GitHub Secrets (base64 encoded)
- Temporary keychain created for build
- Certificate file deleted after import
- Keychain deleted after build (if possible)

#### Code Signing Process
Signing must happen in correct order:
1. Sign all nested binaries
2. Sign frameworks
3. Sign the app bundle
4. Verify signing

**Hardened Runtime**:
- Required for notarization
- Set via `--options runtime` flag
- May require entitlements file

#### Notarization Process
Notarization is Apple's malware scanning:
```bash
# Configure notarytool
xcrun notarytool store-credentials \
  --apple-id "$APPLE_NOTARYTOOL_ISSUER_ID" \
  --team-id "$APPLE_TEAM_ID" \
  --key-id "$APPLE_NOTARYTOOL_KEY_ID" \
  --key "$APPLE_NOTARYTOOL_KEY" \
  notarytool-profile

# Submit for notarization
xcrun notarytool submit "$DMG_PATH" \
  --keychain-profile "notarytool-profile" \
  --wait

# Staple (embed approval)
xcrun stapler staple "$DMG_PATH"
xcrun stapler validate "$DMG_PATH"
```

**Timing**:
- Notarization takes 5-30 minutes
- Use `--wait` flag to wait for completion
- Staple immediately after approval

#### DMG Creation
DMG creation happens after notarization:
```bash
# Create DMG with hdiutil
hdiutil create -volname "CuePoint" \
  -srcfolder "$APP_PATH" \
  -ov -format UDZO \
  "$DMG_PATH"
```

**DMG Format**:
- UDZO: Compressed, read-only (recommended)
- UDRO: Uncompressed, read-only
- UDBZ: Better compression, read-only

### Windows Build Workflow Details

#### Build Environment
Windows builds run on `windows-latest`:
- **Runner**: GitHub-hosted Windows runner
- **Python**: 3.11 (via setup-python action)
- **Tools**: Chocolatey available for package installation
- **Limitations**: 2000 minutes/month free tier

#### NSIS Installation
NSIS is installed via Chocolatey:
```yaml
- name: Install NSIS
  run: |
    choco install nsis -y
```

**Alternative**: Pre-install NSIS in custom runner image

#### Certificate Import (PowerShell)
Windows certificate import:
```powershell
# Decode base64 certificate
$certBytes = [System.Convert]::FromBase64String($env:WINDOWS_CERT_PFX)
$certPath = "cert.pfx"
[System.IO.File]::WriteAllBytes($certPath, $certBytes)

# Certificate is ready for signing
```

**Security**:
- Certificate stored in GitHub Secrets
- Decoded to temporary file
- File should be deleted after use

#### Code Signing (Windows)
Windows signing uses signtool:
```powershell
# Sign executable
signtool sign /f cert.pfx /p "$env:WINDOWS_CERT_PASSWORD" `
  /fd SHA256 /tr http://timestamp.digicert.com /td SHA256 `
  dist/CuePoint.exe

# Verify signing
signtool verify /pa /v dist/CuePoint.exe
```

**Timestamping**:
- Always use timestamping (`/tr` flag)
- Ensures signature valid after cert expiry
- Multiple timestamp servers available

#### NSIS Installer Build
Build installer with makensis:
```yaml
- name: Build installer
  run: |
    makensis scripts/installer.nsi
```

**NSIS Script Requirements**:
- Define installer metadata
- Include all application files
- Create uninstaller
- Set registry keys (if needed)

### Release Workflow Details

#### Artifact Download
Download artifacts from build jobs:
```yaml
- name: Download macOS artifact
  uses: actions/download-artifact@v4
  with:
    name: macos-dmg
    path: artifacts/macos
    github-token: ${{ secrets.GITHUB_TOKEN }}
```

**Artifact Retention**:
- Artifacts stored for 90 days (default)
- Can configure retention in upload step
- Large artifacts may have shorter retention

#### Appcast Generation
Generate update feed (appcast):
```yaml
- name: Generate appcast
  run: |
    python scripts/generate_appcast.py \
      --version ${{ github.ref_name }} \
      --macos artifacts/macos/*.dmg \
      --windows artifacts/windows/*.exe
```

**Appcast Format**:
- macOS: Sparkle XML format
- Windows: WinSparkle JSON format
- Includes: version, URL, release notes, signatures

#### GitHub Release Creation
Create release using action:
```yaml
- name: Create GitHub Release
  uses: softprops/action-gh-release@v1
  with:
    tag_name: ${{ github.ref_name }}
    name: Release ${{ github.ref_name }}
    body_path: RELEASE_NOTES.md
    files: |
      artifacts/macos/*.dmg
      artifacts/windows/*.exe
    draft: false
    prerelease: false
  env:
    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
```

**Release Notes**:
- Can be from file (`body_path`)
- Can be inline (`body`)
- Supports Markdown
- Should include version, changes, installation instructions

#### Appcast Publishing
Publish appcast to GitHub Pages:
```yaml
- name: Publish appcast
  run: |
    git config user.name "github-actions[bot]"
    git config user.email "github-actions[bot]@users.noreply.github.com"
    git checkout gh-pages || git checkout -b gh-pages
    mkdir -p updates
    cp appcast/* updates/
    git add updates/
    git commit -m "Update appcast for ${{ github.ref_name }}"
    git push origin gh-pages
```

**GitHub Pages Setup**:
- Enable in repository settings
- Source: `gh-pages` branch
- Path: `/updates/` directory
- URL: `https://username.github.io/repo/updates/`

### Workflow Optimization

#### Parallel Execution
Run independent jobs in parallel:
```yaml
jobs:
  test:
    # ... test job
  build-macos:
    # ... macOS build
  build-windows:
    # ... Windows build
  # All run in parallel
```

#### Conditional Execution
Skip jobs when not needed:
```yaml
jobs:
  build:
    if: startsWith(github.ref, 'refs/tags/v')
    # Only runs on version tags
```

#### Caching Strategies
Cache dependencies and build artifacts:
```yaml
- name: Cache Python packages
  uses: actions/cache@v3
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('requirements.txt') }}
```

#### Timeout Configuration
Set timeouts to prevent hanging builds:
```yaml
jobs:
  build:
    timeout-minutes: 60
    steps:
      # ... build steps
```

### Error Handling

#### Step-Level Error Handling
Handle errors at step level:
```yaml
- name: Build
  run: |
    pyinstaller build/pyinstaller.spec || exit 1
  continue-on-error: false  # Default: fail on error
```

#### Job-Level Error Handling
Handle errors at job level:
```yaml
jobs:
  build:
    steps:
      - name: Build
        id: build
        run: |
          # ... build commands
      - name: Upload on success
        if: steps.build.outcome == 'success'
        uses: actions/upload-artifact@v4
        # ...
      - name: Notify on failure
        if: failure()
        run: |
          # ... notification
```

#### Artifact Cleanup
Clean up artifacts on failure:
```yaml
- name: Cleanup on failure
  if: failure()
  run: |
    rm -rf dist/ build/
```

### Troubleshooting

#### Common macOS Build Issues

**Issue**: Certificate import fails
- **Cause**: Invalid certificate or password
- **Solution**: Verify certificate format and password in secrets

**Issue**: Notarization times out
- **Cause**: Apple servers slow or busy
- **Solution**: Increase timeout, retry logic

**Issue**: DMG creation fails
- **Cause**: App not signed or missing
- **Solution**: Verify signing completed, check app path

#### Common Windows Build Issues

**Issue**: NSIS not found
- **Cause**: Chocolatey installation failed
- **Solution**: Check Chocolatey availability, use alternative installation

**Issue**: Signing fails
- **Cause**: Invalid certificate or password
- **Solution**: Verify certificate format and password

**Issue**: Installer build fails
- **Cause**: NSIS script errors
- **Solution**: Test NSIS script locally, check syntax

#### Common Release Issues

**Issue**: Artifact download fails
- **Cause**: Artifact not found or expired
- **Solution**: Check artifact names, verify build jobs completed

**Issue**: GitHub Release creation fails
- **Cause**: Tag already exists or permissions issue
- **Solution**: Delete existing release, check GITHUB_TOKEN permissions

**Issue**: Appcast publish fails
- **Cause**: gh-pages branch issues or permissions
- **Solution**: Check branch exists, verify write permissions

### Security Considerations

#### Secret Management
- Store all secrets in GitHub Secrets
- Never commit secrets to repository
- Rotate secrets regularly
- Use least privilege principle

#### Certificate Security
- Certificates stored as base64 in secrets
- Decode only when needed
- Delete certificate files after use
- Use temporary keychains (macOS)

#### Artifact Security
- Sign all artifacts
- Verify signatures before publishing
- Use checksums for integrity
- Host on secure CDN

### Monitoring and Notifications

#### Build Status Notifications
Notify on build status:
```yaml
- name: Notify on failure
  if: failure()
  uses: 8398a7/action-slack@v3
  with:
    status: ${{ job.status }}
    text: 'Build failed!'
  env:
    SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK }}
```

#### Build Metrics
Track build metrics:
```yaml
- name: Track build time
  if: always()
  run: |
    echo "BUILD_TIME=$(date +%s)" >> $GITHUB_ENV
```

### Workflow Maintenance

#### Regular Updates
- Update action versions regularly
- Test workflow changes in separate branch
- Monitor GitHub Actions changelog
- Update dependencies in workflows

#### Documentation
- Document all workflow steps
- Explain secret requirements
- Document troubleshooting steps
- Keep workflow comments updated

## References

- Main document: `../02_Build_System_and_Release_Pipeline.md`
- Related: Step 3-4 (Packaging), Step 5 (Updates)
- GitHub Actions: https://docs.github.com/en/actions
- PyInstaller: https://pyinstaller.org/
- Apple Code Signing: https://developer.apple.com/documentation/security
- Windows Code Signing: https://docs.microsoft.com/en-us/windows/win32/seccrypto/cryptography

