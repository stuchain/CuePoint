# Implementation Step 2.1: Goals and Principles

## Implementation Overview
**What We're Building**: A comprehensive build system foundation that establishes clear goals, guiding principles, success criteria, and architectural decisions for the CuePoint build and release pipeline. This document serves as the philosophical and strategic foundation for all subsequent build system implementation steps.

## Implementation Tasks

### Task 2.1.1: Define Primary Goals

**What to Build**
- Documented primary goals for the build system
- Clear success criteria for each goal
- Measurable outcomes
- Goal prioritization

**Implementation Details**

**2.1.1.1 Reproducible Builds Goal**
- **Goal Statement**: Every build must be reproducible - the same git tag/commit must produce identical artifacts (modulo signing timestamps and build metadata)
- **Success Criteria**:
  - ✅ Same git tag produces same binary checksums (excluding signatures)
  - ✅ Build process is deterministic
  - ✅ Dependencies are pinned and versioned
  - ✅ Build environment is containerized or standardized
- **Measurement**: Compare SHA256 hashes of build artifacts from two separate builds of the same tag
- **Implementation Impact**: Requires dependency pinning, deterministic build scripts, and standardized CI environments

**2.1.1.2 Automated Packaging Goal**
- **Goal Statement**: All packaging, signing, and release publishing must be fully automated with zero manual intervention
- **Success Criteria**:
  - ✅ Tag push triggers complete release pipeline
  - ✅ No manual steps required for release
  - ✅ All artifacts automatically signed and notarized
  - ✅ Release notes automatically generated
  - ✅ Update feeds automatically updated
- **Measurement**: Time from tag push to release publication (target: < 30 minutes)
- **Implementation Impact**: Requires complete CI/CD workflow automation, secret management, and artifact handling

**2.1.1.3 Single Source of Truth for Versioning**
- **Goal Statement**: Version information must come from a single source that is authoritative and cannot be inconsistent
- **Success Criteria**:
  - ✅ One version file defines all version information
  - ✅ All build artifacts embed same version
  - ✅ Version validation prevents inconsistencies
  - ✅ Version is readable from built artifacts
- **Measurement**: Version consistency check across all artifacts
- **Implementation Impact**: Requires version.py file, build-time version injection, and validation scripts

**2.1.1.4 Update Metadata Generation**
- **Goal Statement**: Every release must automatically generate update metadata (appcast/feed files) for the auto-update system
- **Success Criteria**:
  - ✅ Appcast XML generated for macOS (Sparkle format)
  - ✅ Update feed generated for Windows (WinSparkle format)
  - ✅ Feed includes all required metadata (version, URL, release notes, signatures)
  - ✅ Feed is published to accessible location
- **Measurement**: Feed validation and accessibility checks
- **Implementation Impact**: Requires appcast generation scripts and feed publishing workflow

### Task 2.1.2: Establish Guiding Principles

**What to Build**
- Documented principles that guide all build system decisions
- Principle-to-implementation mapping
- Decision framework based on principles
- Principle validation criteria

**Implementation Details**

**2.1.2.1 Reproducibility Principle**
- **Principle Statement**: Same tag produces same versioned artifacts (modulo signing timestamps)
- **Implementation Requirements**:
  - Pin all Python dependencies with exact versions
  - Use deterministic build processes (no timestamps in code)
  - Standardize build environment (Python version, OS version)
  - Document all build dependencies
- **Validation**: Build same tag twice, compare artifact checksums
- **Trade-offs**: Reproducibility may require more maintenance (dependency updates)
- **Files Affected**: `requirements.txt`, `pyproject.toml`, CI workflows, build scripts

**2.1.2.2 Auditability Principle**
- **Principle Statement**: Every artifact is traceable to a git tag + CI run + commit SHA
- **Implementation Requirements**:
  - Embed commit SHA in all artifacts
  - Embed build number/timestamp in artifacts
  - Link artifacts to CI run IDs
  - Store build logs for all releases
  - Include build metadata in artifact metadata
- **Validation**: Can trace any artifact back to exact source code
- **Trade-offs**: Requires metadata storage and logging
- **Files Affected**: Build scripts, version.py, CI workflows, artifact metadata

**2.1.2.3 Least Privilege Principle**
- **Principle Statement**: Signing/notarization secrets are scoped to release workflows only
- **Implementation Requirements**:
  - Secrets only available in release workflows (tag-triggered)
  - No secrets in test/development workflows
  - Secrets scoped to specific jobs
  - Secrets rotated regularly
  - Secret access logged
- **Validation**: Secrets not accessible in non-release workflows
- **Trade-offs**: More complex secret management
- **Files Affected**: CI workflow files, secret configuration

**2.1.2.4 Fail-Safe Principle**
- **Principle Statement**: If signing/notarization fails, the release job fails and publishes nothing
- **Implementation Requirements**:
  - Fail-fast on signing errors
  - No partial releases (all-or-nothing)
  - Validation before publishing
  - Rollback capability
  - Clear error reporting
- **Validation**: Failed signing prevents release publication
- **Trade-offs**: May require re-running entire pipeline on failure
- **Files Affected**: CI workflows, validation scripts

### Task 2.1.3: Define Success Metrics

**What to Build**
- Quantifiable success metrics for the build system
- Measurement methods
- Target values
- Monitoring approach

**Implementation Details**

**2.1.3.1 Build Success Rate Metric**
- **Metric**: Percentage of builds that complete successfully
- **Target**: > 95% success rate
- **Measurement**: Track build outcomes in CI
- **Implementation**: Log build results, calculate success rate over time
- **Files**: CI workflows, monitoring scripts

**2.1.3.2 Build Time Metric**
- **Metric**: Time from tag push to release publication
- **Target**: < 30 minutes for complete release
- **Measurement**: Track CI workflow duration
- **Implementation**: Use CI workflow timing, log timestamps
- **Files**: CI workflows, monitoring scripts

**2.1.3.3 Artifact Consistency Metric**
- **Metric**: Version consistency across all artifacts
- **Target**: 100% consistency (all artifacts have same version)
- **Measurement**: Validate version in all artifacts
- **Implementation**: Version validation script
- **Files**: `scripts/validate_version.py`, validation workflows

**2.1.3.4 Reproducibility Metric**
- **Metric**: Artifact checksum consistency across builds
- **Target**: 100% match (excluding signatures)
- **Measurement**: Compare SHA256 hashes
- **Implementation**: Checksum comparison script
- **Files**: Validation scripts, CI workflows

### Task 2.1.4: Document Architectural Decisions

**What to Build**
- Key architectural decisions for the build system
- Decision rationale
- Alternatives considered
- Decision log

**Implementation Details**

**2.1.4.1 CI/CD Platform Decision**
- **Decision**: Use GitHub Actions for CI/CD
- **Rationale**:
  - Native GitHub integration
  - Free for open source
  - Good macOS and Windows support
  - Active development and community
- **Alternatives Considered**:
  - GitLab CI: Good but requires GitLab
  - Jenkins: More complex setup
  - CircleCI: More expensive
  - Azure DevOps: More complex
- **Impact**: All CI workflows use GitHub Actions syntax
- **Files**: `.github/workflows/*.yml`

**2.1.4.2 Packaging Tool Decision**
- **Decision**: Use PyInstaller for both platforms
- **Rationale**:
  - Single codebase for both platforms
  - Mature and stable
  - Good Python support
  - Active development
  - Good documentation
- **Alternatives Considered**:
  - cx_Freeze: Less active development
  - py2app (macOS) + py2exe (Windows): Platform-specific, more maintenance
  - Nuitka: More complex, longer build times
- **Impact**: Single PyInstaller spec file, platform-specific options
- **Files**: `build/pyinstaller.spec`, build scripts

**2.1.4.3 Version Management Decision**
- **Decision**: Single version.py file as source of truth
- **Rationale**:
  - Simple and clear
  - Easy to read and modify
  - Can be imported by Python code
  - Can be read by build scripts
- **Alternatives Considered**:
  - Git tags only: Harder to read in code
  - pyproject.toml: Less flexible
  - Separate version files: More complex
- **Impact**: All version reading goes through version.py
- **Files**: `SRC/cuepoint/version.py`, build scripts

**2.1.4.4 Artifact Storage Decision**
- **Decision**: GitHub Releases for artifacts, GitHub Pages for update feeds
- **Rationale**:
  - Free for open source
  - Integrated with GitHub
  - Reliable CDN
  - Easy to manage
- **Alternatives Considered**:
  - S3: Requires AWS account
  - Custom CDN: More complex
  - Git LFS: Not suitable for releases
- **Impact**: Release workflow publishes to GitHub, feeds on gh-pages
- **Files**: CI workflows, appcast generation scripts

### Task 2.1.5: Create Decision Framework

**What to Build**
- Framework for making build system decisions
- Decision criteria
- Evaluation process
- Documentation requirements

**Implementation Details**

**2.1.5.1 Decision Criteria**
- **Criteria for Tool Selection**:
  1. Cross-platform support (macOS + Windows)
  2. Maintenance status (actively maintained)
  3. Documentation quality
  4. Community support
  5. License compatibility
  6. Ease of integration
  7. Performance impact
- **Usage**: Evaluate all tools against these criteria
- **Documentation**: Document evaluation in decision log

**2.1.5.2 Evaluation Process**
- **Process Steps**:
  1. Identify requirement
  2. Research alternatives
  3. Evaluate against criteria
  4. Make decision
  5. Document decision
  6. Implement decision
  7. Validate decision
- **Documentation**: All decisions documented with rationale
- **Review**: Decisions reviewed periodically

**2.1.5.3 Documentation Requirements**
- **Required Information**:
  - Decision statement
  - Rationale
  - Alternatives considered
  - Trade-offs
  - Impact assessment
  - Review date
- **Location**: Decision log in documentation
- **Format**: Markdown with clear structure

## Implementation Checklist

### Documentation Tasks
- [ ] Document all primary goals
- [ ] Document all guiding principles
- [ ] Define success metrics
- [ ] Document architectural decisions
- [ ] Create decision framework
- [ ] Create decision log template

### Validation Tasks
- [ ] Validate goals are measurable
- [ ] Validate principles are actionable
- [ ] Validate metrics are trackable
- [ ] Validate decisions are documented

### Integration Tasks
- [ ] Ensure goals align with product requirements
- [ ] Ensure principles align with security requirements
- [ ] Ensure metrics align with success criteria
- [ ] Ensure decisions align with constraints

## Files to Create/Modify

### New Files
1. `DOCS/DESIGNS/SHIP v1.0/Step_2_Build_System/2.1_Goals_and_Principles.md` - This document
2. `DOCS/DESIGNS/SHIP v1.0/Step_2_Build_System/DECISION_LOG.md` - Decision log for build system decisions

### Files to Modify
1. `DOCS/DESIGNS/SHIP v1.0/02_Build_System_and_Release_Pipeline.md` - Reference this document
2. `DOCS/DESIGNS/SHIP v1.0/Step_2_Build_System/README.md` - Add reference to this document

## Implementation Dependencies

### Prerequisites
- Step 1: Product Requirements (defines what we're building)
- Understanding of release requirements
- Understanding of platform requirements

### Enables
- Step 2.2: Tooling Choices (uses goals and principles)
- Step 2.3: Repository Hygiene (uses principles)
- Step 2.4: Version Management (uses goals)
- Step 2.5: CI Structure (uses goals and principles)
- All subsequent build system steps

## Success Criteria

### Goals
- ✅ All primary goals clearly defined
- ✅ All goals have measurable success criteria
- ✅ Goals are prioritized and documented

### Principles
- ✅ All guiding principles documented
- ✅ Principles are actionable and testable
- ✅ Principles guide all build system decisions

### Metrics
- ✅ All success metrics defined
- ✅ Metrics are measurable and trackable
- ✅ Target values are realistic

### Decisions
- ✅ All architectural decisions documented
- ✅ Decision rationale is clear
- ✅ Alternatives were considered

## Next Implementation Steps

After completing Step 2.1:
1. **Step 2.2**: Tooling Choices (uses goals and principles from this step)
2. **Step 2.3**: Repository Hygiene (applies principles)
3. **Step 2.4**: Version Management (implements versioning goal)
4. **Step 2.5**: CI Structure (implements automation goal)

## Detailed Implementation Guidance

### Section 2.1.1: Primary Goals Implementation

#### Goal 1: Reproducible Builds

**Implementation Approach**:
1. **Dependency Pinning**:
   - Pin all dependencies in `requirements.txt` with exact versions
   - Use `pip freeze` to generate exact versions
   - Document why each dependency is needed
   - Example: `requests==2.31.0` not `requests>=2.31.0`

2. **Build Environment Standardization**:
   - Use specific Python version (3.11)
   - Use specific OS versions in CI (macos-latest, windows-latest)
   - Document all build tools and versions
   - Use containerization if possible

3. **Deterministic Build Process**:
   - Remove timestamps from build artifacts
   - Use deterministic file ordering
   - Avoid random values in builds
   - Use fixed seed for any randomization

4. **Validation**:
   - Build same tag twice
   - Compare artifact checksums
   - Document any expected differences (signatures)

**Code Example - Dependency Pinning**:
```python
# requirements.txt - All dependencies pinned
requests==2.31.0
PySide6==6.5.0
# ... etc
```

**Code Example - Build Script Determinism**:
```python
# scripts/build.py
import os
import sys

# Set deterministic environment
os.environ['PYTHONHASHSEED'] = '0'
os.environ['SOURCE_DATE_EPOCH'] = '0'

# Build process...
```

#### Goal 2: Automated Packaging

**Implementation Approach**:
1. **CI/CD Workflow**:
   - Tag push triggers release workflow
   - All steps automated
   - No manual intervention required
   - Clear error reporting

2. **Signing Automation**:
   - Secrets stored in GitHub Secrets
   - Automatic certificate import
   - Automatic signing
   - Automatic notarization (macOS)

3. **Artifact Publishing**:
   - Automatic artifact upload
   - Automatic release creation
   - Automatic feed generation
   - Automatic feed publishing

4. **Validation**:
   - All steps must succeed
   - Fail-fast on errors
   - Clear error messages
   - Rollback capability

**Code Example - Release Workflow Trigger**:
```yaml
# .github/workflows/release.yml
on:
  push:
    tags:
      - 'v*'  # Triggers on version tags
```

#### Goal 3: Single Source of Truth for Versioning

**Implementation Approach**:
1. **Version File**:
   - Single `version.py` file
   - Contains `__version__` constant
   - Can be imported by code
   - Can be read by scripts

2. **Version Usage**:
   - All builds read from version.py
   - Version embedded in all artifacts
   - Version in Info.plist (macOS)
   - Version in Windows metadata

3. **Validation**:
   - Version consistency check
   - Version format validation
   - Version in all artifacts

**Code Example - Version File**:
```python
# SRC/cuepoint/version.py
__version__ = "1.0.0"
```

**Code Example - Version Reading in Build**:
```python
# scripts/build.py
import sys
sys.path.insert(0, 'SRC')
from cuepoint.version import __version__

# Use __version__ in build process
```

#### Goal 4: Update Metadata Generation

**Implementation Approach**:
1. **Appcast Generation**:
   - Generate Sparkle appcast (macOS)
   - Generate WinSparkle feed (Windows)
   - Include all required metadata
   - Include signatures

2. **Feed Publishing**:
   - Publish to GitHub Pages
   - Update feed on each release
   - Maintain feed history
   - Validate feed format

3. **Metadata Requirements**:
   - Version number
   - Download URL
   - Release notes
   - File size
   - Checksums
   - Signatures

**Code Example - Appcast Generation**:
```python
# scripts/generate_appcast.py
def generate_appcast(version, dmg_path, release_notes):
    appcast = {
        "version": version,
        "url": f"https://github.com/user/repo/releases/download/v{version}/app.dmg",
        "releaseNotes": release_notes,
        "length": os.path.getsize(dmg_path),
        "dsaSignature": generate_signature(dmg_path)
    }
    # Generate XML...
```

### Section 2.1.2: Guiding Principles Implementation

#### Principle 1: Reproducibility

**Implementation Checklist**:
- [ ] All dependencies pinned
- [ ] Build environment standardized
- [ ] Build process deterministic
- [ ] Validation script created
- [ ] Documentation updated

**Validation Script**:
```python
# scripts/validate_reproducibility.py
def validate_reproducibility(tag):
    """Build same tag twice and compare artifacts"""
    # Build 1
    build_1 = build_artifact(tag)
    checksum_1 = calculate_checksum(build_1)
    
    # Build 2
    build_2 = build_artifact(tag)
    checksum_2 = calculate_checksum(build_2)
    
    # Compare (excluding signatures)
    assert checksum_1 == checksum_2, "Builds not reproducible"
```

#### Principle 2: Auditability

**Implementation Checklist**:
- [ ] Commit SHA embedded in artifacts
- [ ] Build number embedded in artifacts
- [ ] CI run ID logged
- [ ] Build logs stored
- [ ] Metadata in artifacts

**Build Info Embedding**:
```python
# scripts/set_build_info.py
def set_build_info():
    """Set build info in version.py"""
    commit_sha = subprocess.check_output(['git', 'rev-parse', 'HEAD']).decode().strip()
    build_number = os.environ.get('GITHUB_RUN_NUMBER', 'dev')
    build_date = datetime.now().isoformat()
    
    # Update version.py with build info
    # ...
```

#### Principle 3: Least Privilege

**Implementation Checklist**:
- [ ] Secrets only in release workflows
- [ ] Secrets scoped to specific jobs
- [ ] No secrets in test workflows
- [ ] Secret access logged
- [ ] Secrets rotated regularly

**Workflow Secret Usage**:
```yaml
# .github/workflows/release.yml
jobs:
  build:
    if: startsWith(github.ref, 'refs/tags/v')  # Only on tags
    steps:
      - name: Sign
        env:
          SIGNING_CERT: ${{ secrets.SIGNING_CERT }}  # Only available here
```

#### Principle 4: Fail-Safe

**Implementation Checklist**:
- [ ] Fail-fast on errors
- [ ] No partial releases
- [ ] Validation before publishing
- [ ] Rollback capability
- [ ] Clear error reporting

**Validation Before Release**:
```python
# scripts/validate_release.py
def validate_release():
    """Validate release before publishing"""
    checks = [
        validate_signing(),
        validate_notarization(),
        validate_version_consistency(),
        validate_artifact_integrity()
    ]
    
    if not all(checks):
        raise ValueError("Release validation failed")
```

### Section 2.1.3: Success Metrics Implementation

#### Metric 1: Build Success Rate

**Tracking Implementation**:
```python
# scripts/track_build_metrics.py
def track_build_success(build_id, success):
    """Track build success rate"""
    # Store in database or file
    # Calculate success rate over time
    # Alert if below threshold
```

**CI Integration**:
```yaml
# .github/workflows/build.yml
- name: Track build metrics
  if: always()
  run: |
    python scripts/track_build_metrics.py ${{ github.run_id }} ${{ job.status }}
```

#### Metric 2: Build Time

**Tracking Implementation**:
```python
# scripts/track_build_time.py
def track_build_time(start_time, end_time):
    """Track build duration"""
    duration = end_time - start_time
    # Store and analyze
    # Alert if exceeds threshold
```

**CI Integration**:
```yaml
# .github/workflows/build.yml
- name: Track build time
  if: always()
  run: |
    python scripts/track_build_time.py ${{ github.run_started_at }} ${{ github.run_id }}
```

#### Metric 3: Artifact Consistency

**Validation Implementation**:
```python
# scripts/validate_artifact_consistency.py
def validate_artifact_consistency():
    """Validate version consistency across artifacts"""
    artifacts = get_all_artifacts()
    versions = [get_version(a) for a in artifacts]
    
    if len(set(versions)) != 1:
        raise ValueError("Version inconsistency detected")
```

#### Metric 4: Reproducibility

**Validation Implementation**:
```python
# scripts/validate_reproducibility.py
def validate_reproducibility():
    """Validate build reproducibility"""
    # Build twice and compare
    # Exclude signatures from comparison
    # Report any differences
```

### Section 2.1.4: Architectural Decisions Documentation

**Decision Log Template**:
```markdown
# Build System Decision Log

## Decision: [Decision Name]
**Date**: [Date]
**Status**: [Proposed/Approved/Implemented/Deprecated]

### Context
[Why this decision is needed]

### Decision
[What was decided]

### Rationale
[Why this decision was made]

### Alternatives Considered
1. [Alternative 1] - [Why rejected]
2. [Alternative 2] - [Why rejected]

### Consequences
- Positive: [Positive consequences]
- Negative: [Negative consequences]
- Risks: [Risks and mitigation]

### Implementation
[How this decision is implemented]

### Review Date
[When to review this decision]
```

## References

- Main document: `../02_Build_System_and_Release_Pipeline.md`
- Product Requirements: `../01_Product_Requirements_and_Definition.md`
- Index: `../00_SHIP_V1_Index.md`
