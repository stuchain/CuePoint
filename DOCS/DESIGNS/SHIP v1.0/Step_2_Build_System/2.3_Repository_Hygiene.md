# Implementation Step 2.3: Repository Hygiene

## Implementation Overview
**What We're Building**: Complete repository hygiene system including .gitignore configuration, large file detection, CI gates, and repository maintenance scripts. This ensures the repository remains clean, manageable, and prevents accidental commits of build artifacts, dependencies, and large files.

## Implementation Tasks

### Task 2.3.1: .gitignore Configuration

**What to Build**
- Comprehensive .gitignore file
- Platform-specific ignore patterns
- Build artifact exclusions
- Development environment exclusions
- IDE-specific exclusions

**Implementation Details**

**2.3.1.1 Core .gitignore File**
- **File to Modify**: `.gitignore`
- **Purpose**: Exclude build artifacts, dependencies, and temporary files
- **Implementation**:
  ```gitignore
  # CuePoint .gitignore
  
  # Python
  __pycache__/
  *.py[cod]
  *$py.class
  *.so
  .Python
  build/
  develop-eggs/
  dist/
  downloads/
  eggs/
  .eggs/
  lib/
  lib64/
  parts/
  sdist/
  var/
  wheels/
  share/python-wheels/
  *.egg-info/
  .installed.cfg
  *.egg
  MANIFEST
  
  # Virtual environments
  .venv/
  venv/
  ENV/
  env/
  .env
  
  # PyInstaller
  *.manifest
  *.spec.bak
  
  # Unit test / coverage reports
  htmlcov/
  .tox/
  .coverage
  .coverage.*
  .cache
  nosetests.xml
  coverage.xml
  *.cover
  *.py,cover
  .hypothesis/
  .pytest_cache/
  .mypy_cache/
  .dmypy.json
  dmypy.json
  
  # IDEs
  .idea/
  .vscode/
  *.swp
  *.swo
  *~
  .DS_Store
  Thumbs.db
  
  # Build artifacts
  dist/
  build/
  *.dmg
  *.pkg
  *.exe
  *.msi
  *.app/
  *.deb
  *.rpm
  
  # Signing certificates and keys (NEVER COMMIT)
  *.p12
  *.pfx
  *.pem
  *.key
  *.cer
  *.crt
  cert.p12
  cert.pfx
  *.mobileprovision
  
  # macOS
  .DS_Store
  .AppleDouble
  .LSOverride
  Icon
  ._*
  .DocumentRevisions-V100
  .fseventsd
  .Spotlight-V100
  .TemporaryItems
  .Trashes
  .VolumeIcon.icns
  .com.apple.timemachine.donotpresent
  .AppleDB
  .AppleDesktop
  Network Trash Folder
  Temporary Items
  .apdisk
  
  # Windows
  Thumbs.db
  Thumbs.db:encryptable
  ehthumbs.db
  ehthumbs_vista.db
  *.stackdump
  [Dd]esktop.ini
  $RECYCLE.BIN/
  *.cab
  *.msi
  *.msix
  *.msm
  *.msp
  *.lnk
  
  # Logs
  *.log
  logs/
  *.log.*
  
  # Temporary files
  *.tmp
  *.temp
  *.bak
  *.swp
  *~
  
  # Cache directories
  .cache/
  cache/
  *.cache
  
  # Output files (user-generated)
  output/
  *.csv
  *.json
  *.xlsx
  *.xls
  
  # Test files
  test_output/
  test_results/
  
  # Playwright
  .playwright/
  playwright-report/
  test-results/
  
  # Selenium
  geckodriver.log
  chromedriver.log
  
  # Environment variables
  .env
  .env.local
  .env.*.local
  
  # Secrets (extra safety)
  secrets/
  *.secret
  config/secrets.yaml
  config/secrets.yml
  
  # Large files (should use Git LFS if needed)
  *.zip
  *.tar
  *.tar.gz
  *.tgz
  *.rar
  *.7z
  
  # Documentation builds
  docs/_build/
  docs/.doctrees/
  
  # Jupyter Notebook
  .ipynb_checkpoints
  
  # pyenv
  .python-version
  
  # Celery
  celerybeat-schedule
  celerybeat.pid
  
  # SageMath
  *.sage.py
  
  # Spyder
  .spyderproject
  .spyproject
  
  # Rope
  .ropeproject
  
  # mkdocs
  /site
  
  # mypy
  .mypy_cache/
  .dmypy.json
  dmypy.json
  
  # Pyre
  .pyre/
  
  # pytype
  .pytype/
  
  # Cython
  Cython/
  *.c
  
  # Coverage
  .coverage
  .coverage.*
  coverage.xml
  *.cover
  htmlcov/
  .tox/
  .pytest_cache/
  
  # Translations
  *.mo
  *.pot
  
  # Django
  *.log
  local_settings.py
  db.sqlite3
  db.sqlite3-journal
  
  # Flask
  instance/
  .webassets-cache
  
  # Scrapy
  .scrapy
  
  # Sphinx
  docs/_build/
  
  # PyBuilder
  target/
  
  # Jupyter Notebook
  .ipynb_checkpoints
  
  # IPython
  profile_default/
  ipython_config.py
  
  # pyenv
  .python-version
  
  # pipenv
  Pipfile.lock
  
  # PEP 582
  __pypackages__/
  
  # Celery
  celerybeat-schedule
  celerybeat.pid
  
  # SageMath
  *.sage.py
  
  # Environments
  .env
  .venv
  env/
  venv/
  ENV/
  env.bak/
  venv.bak/
  
  # Spyder
  .spyderproject
  .spyproject
  
  # Rope
  .ropeproject
  
  # mkdocs
  /site
  
  # mypy
  .mypy_cache/
  .dmypy.json
  dmypy.json
  
  # Pyre
  .pyre/
  
  # pytype
  .pytype/
  
  # Cython
  Cython/
  *.c
  
  # IDEs - VSCode
  .vscode/
  *.code-workspace
  
  # IDEs - PyCharm
  .idea/
  *.iml
  *.iws
  *.ipr
  
  # IDEs - Sublime Text
  *.sublime-project
  *.sublime-workspace
  
  # IDEs - Vim
  *.swp
  *.swo
  *~
  .vim/
  
  # IDEs - Emacs
  *~
  \#*\#
  /.emacs.desktop
  /.emacs.desktop.lock
  *.elc
  auto-save-list
  tramp
  .\#*
  
  # macOS - Xcode
  *.xcodeproj/*
  !*.xcodeproj/project.pbxproj
  !*.xcodeproj/xcshareddata/
  !*.xcworkspace/contents.xcworkspacedata
  **/xcshareddata/WorkspaceSettings.xcsettings
  *.xcuserstate
  project.xcworkspace/
  
  # macOS - Icon must be on a device
  .DS_Store
  .AppleDouble
  .LSOverride
  
  # Windows - Image file caches
  Thumbs.db
  ehthumbs.db
  
  # Windows - Folder config file
  Desktop.ini
  
  # Windows - Recycle Bin
  $RECYCLE.BIN/
  
  # Windows - Windows shortcuts
  *.lnk
  
  # Linux
  *~
  .directory
  .Trash-*
  
  # Project-specific
  collection.xml
  *.xml.backup
  test_collection.xml
  
  # Build-specific (keep templates)
  !build/*.template
  !build/*.spec
  build/Info.plist
  build/version_info.txt
  
  # CI/CD
  .github/workflows/*.yml.bak
  .github/workflows/*.yaml.bak
  ```
- **Integration**: Used by git to exclude files from version control
- **Validation**: Test that ignored files are not tracked

**2.3.1.2 .gitignore Validation Script**
- **File to Create**: `scripts/validate_gitignore.py`
- **Purpose**: Validate .gitignore is working correctly
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Validate .gitignore configuration"""
  import subprocess
  import sys
  from pathlib import Path
  
  def check_ignored_files():
      """Check that critical files are ignored"""
      critical_patterns = [
          '.venv/',
          'dist/',
          'build/',
          '*.p12',
          '*.pfx',
          '*.log',
          '.env',
      ]
      
      errors = []
      for pattern in critical_patterns:
          # Check if any files matching pattern are tracked
          result = subprocess.run(
              ['git', 'ls-files', pattern],
              capture_output=True,
              text=True
          )
          if result.stdout.strip():
              errors.append(f"Files matching '{pattern}' are tracked: {result.stdout.strip()}")
      
      if errors:
          print("ERROR: .gitignore validation failed:")
          for error in errors:
              print(f"  {error}")
          sys.exit(1)
      
      print(".gitignore validation passed")
  
  if __name__ == '__main__':
      check_ignored_files()
  ```

### Task 2.3.2: Large File Detection

**What to Build**
- Large file detection script
- CI gate for large files
- File size reporting
- Large file handling guidelines

**Implementation Details**

**2.3.2.1 Large File Check Script**
- **File to Create**: `scripts/check_large_files.py`
- **Purpose**: Detect files exceeding size limits
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Check for large files in repository"""
  import os
  import sys
  from pathlib import Path
  
  # Maximum file size (50MB)
  MAX_FILE_SIZE = 50 * 1024 * 1024
  
  # Directories to exclude
  EXCLUDE_DIRS = {
      '.git',
      '.venv',
      'venv',
      'env',
      'ENV',
      'node_modules',
      '.mypy_cache',
      '.pytest_cache',
      '__pycache__',
      'dist',
      'build',
      '.playwright',
      'playwright-report',
      'test-results',
  }
  
  # File patterns to exclude
  EXCLUDE_PATTERNS = {
      '.pyc',
      '.pyo',
      '.egg',
      '.whl',
      '.cache',
  }
  
  def format_size(size_bytes):
      """Format file size in human-readable format"""
      for unit in ['B', 'KB', 'MB', 'GB']:
          if size_bytes < 1024.0:
              return f"{size_bytes:.2f} {unit}"
          size_bytes /= 1024.0
      return f"{size_bytes:.2f} TB"
  
  def should_exclude(path):
      """Check if path should be excluded from checking"""
      # Check directory exclusions
      parts = Path(path).parts
      for part in parts:
          if part in EXCLUDE_DIRS:
              return True
      
      # Check file pattern exclusions
      if any(path.endswith(pattern) for pattern in EXCLUDE_PATTERNS):
          return True
      
      return False
  
  def check_large_files(root_dir='.'):
      """Check for large files in repository"""
      large_files = []
      total_size = 0
      
      root_path = Path(root_dir).resolve()
      
      for root, dirs, files in os.walk(root_path):
          # Filter out excluded directories
          dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
          
          for file in files:
              file_path = Path(root) / file
              
              # Skip excluded paths
              if should_exclude(str(file_path)):
                  continue
              
              try:
                  size = file_path.stat().st_size
                  total_size += size
                  
                  if size > MAX_FILE_SIZE:
                      rel_path = file_path.relative_to(root_path)
                      large_files.append((rel_path, size))
              except (OSError, PermissionError) as e:
                  print(f"Warning: Could not check {file_path}: {e}", file=sys.stderr)
                  continue
      
      return large_files, total_size
  
  def main():
      """Main function"""
      large_files, total_size = check_large_files()
      
      if large_files:
          print(f"ERROR: Found {len(large_files)} file(s) exceeding {format_size(MAX_FILE_SIZE)}:")
          print()
          for file_path, size in sorted(large_files, key=lambda x: x[1], reverse=True):
              print(f"  {file_path}: {format_size(size)}")
          print()
          print("Large files should not be committed to git.")
          print("Consider using Git LFS for large files, or exclude them in .gitignore")
          sys.exit(1)
      
      print(f"✓ No large files detected (total repository size: {format_size(total_size)})")
  
  if __name__ == '__main__':
      main()
  ```
- **Usage**: `python scripts/check_large_files.py`
- **Integration**: Called by CI workflow

**2.3.2.2 CI Large File Gate**
- **File to Modify**: `.github/workflows/large-file-check.yml` (may already exist)
- **Purpose**: Prevent large files from being committed
- **Implementation**:
  ```yaml
  name: Large File Check
  
  on:
    push:
      branches: [main, 'phase_*']
    pull_request:
      branches: [main]
  
  jobs:
    check:
      runs-on: ubuntu-latest
      steps:
        - name: Checkout code
          uses: actions/checkout@v4
          
        - name: Set up Python
          uses: actions/setup-python@v5
          with:
            python-version: '3.11'
          
        - name: Check for large files
          run: |
            python scripts/check_large_files.py
          
        - name: Check git-tracked large files
          run: |
            # Check files already tracked by git
            git ls-files -z | xargs -0 -I {} sh -c 'test -f "{}" && stat -f%z "{}" 2>/dev/null || stat -c%s "{}" 2>/dev/null || echo 0' | \
            awk '{if ($1 > 52428800) print "Large tracked file detected"}'
  ```
- **Integration**: Required check for PRs

**2.3.2.3 Large File Handling Guidelines**
- **File to Create**: `DOCS/POLICY/Large_Files.md`
- **Purpose**: Document how to handle large files
- **Content**:
  ```markdown
  # Large File Handling Policy
  
  ## Size Limits
  - Maximum file size: 50MB
  - Files exceeding this limit will be rejected by CI
  
  ## Handling Large Files
  
  ### Option 1: Git LFS
  For files that must be versioned:
  ```bash
  git lfs install
  git lfs track "*.large"
  git add .gitattributes
  git add file.large
  ```
  
  ### Option 2: External Storage
  Store large files externally and reference them:
  - Cloud storage (S3, Google Cloud)
  - CDN
  - Release artifacts
  
  ### Option 3: Exclude from Repository
  Add to .gitignore if not needed in repository
  
  ## Common Large Files to Exclude
  - Build artifacts (dist/, build/)
  - Virtual environments (.venv/)
  - Test data files
  - Binary assets
  - Database files
  ```

### Task 2.3.3: CI Gates and Validation

**What to Build**
- Pre-commit hooks
- CI validation checks
- Repository health checks
- Automated cleanup suggestions

**Implementation Details**

**2.3.3.1 Pre-commit Configuration**
- **File to Create**: `.pre-commit-config.yaml` (may already exist)
- **Purpose**: Run checks before commits
- **Implementation**:
  ```yaml
  repos:
    - repo: https://github.com/pre-commit/pre-commit-hooks
      rev: v4.5.0
      hooks:
        - id: trailing-whitespace
        - id: end-of-file-fixer
        - id: check-yaml
        - id: check-added-large-files
          args: ['--maxkb=51200']  # 50MB
        - id: check-json
        - id: check-toml
        - id: check-merge-conflict
        - id: check-case-conflict
        - id: check-executables-have-shebangs
        - id: check-shebang-scripts-are-executable
        - id: detect-private-key
        - id: mixed-line-ending
        - id: no-commit-to-branch
          args: ['--branch', 'main']
    
    - repo: https://github.com/psf/black
      rev: 23.12.1
      hooks:
        - id: black
          language_version: python3.11
    
    - repo: https://github.com/pycqa/isort
      rev: 5.13.2
      hooks:
        - id: isort
    
    - repo: https://github.com/pycqa/flake8
      rev: 7.0.0
      hooks:
        - id: flake8
          args: ['--max-line-length=100', '--extend-ignore=E203']
    
    - repo: local
      hooks:
        - id: check-large-files
          name: Check for large files
          entry: python scripts/check_large_files.py
          language: system
          pass_filenames: false
          always_run: true
        
        - id: validate-gitignore
          name: Validate .gitignore
          entry: python scripts/validate_gitignore.py
          language: system
          pass_filenames: false
          always_run: true
  ```
- **Installation**: `pre-commit install`
- **Usage**: Runs automatically on `git commit`

**2.3.3.2 Repository Health Check Script**
- **File to Create**: `scripts/check_repo_health.py`
- **Purpose**: Comprehensive repository health check
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Repository health check"""
  import subprocess
  import sys
  from pathlib import Path
  
  def check_git_status():
      """Check git repository status"""
      result = subprocess.run(['git', 'status', '--porcelain'], capture_output=True, text=True)
      if result.stdout.strip():
          print("Warning: Uncommitted changes detected")
          return False
      return True
  
  def check_branch():
      """Check current branch"""
      result = subprocess.run(['git', 'rev-parse', '--abbrev-ref', 'HEAD'], 
                            capture_output=True, text=True)
      branch = result.stdout.strip()
      print(f"Current branch: {branch}")
      return branch
  
  def check_large_files():
      """Check for large files"""
      result = subprocess.run(['python', 'scripts/check_large_files.py'], 
                            capture_output=True, text=True)
      if result.returncode != 0:
          print("ERROR: Large files detected")
          print(result.stdout)
          return False
      return True
  
  def check_gitignore():
      """Check .gitignore"""
      gitignore = Path('.gitignore')
      if not gitignore.exists():
          print("Warning: .gitignore not found")
          return False
      return True
  
  def check_secrets():
      """Check for accidentally committed secrets"""
      # Check for common secret patterns
      patterns = [
          'password',
          'secret',
          'api_key',
          'private_key',
          'certificate',
      ]
      
      result = subprocess.run(['git', 'grep', '-i', '|'.join(patterns)], 
                            capture_output=True, text=True)
      if result.stdout.strip():
          print("Warning: Potential secrets detected in tracked files")
          print("Review the following:")
          print(result.stdout)
          return False
      return True
  
  def main():
      """Main health check"""
      print("Repository Health Check")
      print("=" * 50)
      
      checks = [
          ("Git status", check_git_status),
          ("Current branch", lambda: check_branch() is not None),
          ("Large files", check_large_files),
          (".gitignore", check_gitignore),
          ("Secrets", check_secrets),
      ]
      
      all_passed = True
      for name, check_func in checks:
          print(f"\nChecking {name}...")
          if not check_func():
              all_passed = False
      
      print("\n" + "=" * 50)
      if all_passed:
          print("✓ All checks passed")
          sys.exit(0)
      else:
          print("✗ Some checks failed")
          sys.exit(1)
  
  if __name__ == '__main__':
      main()
  ```

**2.3.3.3 CI Repository Validation Workflow**
- **File to Create**: `.github/workflows/repo-validation.yml`
- **Purpose**: Comprehensive repository validation
- **Implementation**:
  ```yaml
  name: Repository Validation
  
  on:
    push:
      branches: [main, 'phase_*']
    pull_request:
      branches: [main]
    schedule:
      - cron: '0 0 * * 0'  # Weekly
  
  jobs:
    validate:
      runs-on: ubuntu-latest
      steps:
        - name: Checkout code
          uses: actions/checkout@v4
          
        - name: Set up Python
          uses: actions/setup-python@v5
          with:
            python-version: '3.11'
          
        - name: Install dependencies
          run: |
            pip install pre-commit
        
        - name: Run pre-commit
          run: |
            pre-commit run --all-files
        
        - name: Check large files
          run: |
            python scripts/check_large_files.py
        
        - name: Validate .gitignore
          run: |
            python scripts/validate_gitignore.py
        
        - name: Repository health check
          run: |
            python scripts/check_repo_health.py
  ```

### Task 2.3.4: Repository Maintenance

**What to Build**
- Cleanup scripts
- Repository size monitoring
- Orphaned file detection
- Dependency cleanup

**Implementation Details**

**2.3.4.1 Repository Cleanup Script**
- **File to Create**: `scripts/cleanup_repo.py`
- **Purpose**: Clean up repository artifacts
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Clean up repository artifacts"""
  import shutil
  import sys
  from pathlib import Path
  
  def cleanup_build_artifacts():
      """Remove build artifacts"""
      dirs_to_remove = ['dist', 'build', '__pycache__']
      files_to_remove = ['*.pyc', '*.pyo', '*.egg-info']
      
      for dir_name in dirs_to_remove:
          dir_path = Path(dir_name)
          if dir_path.exists():
              print(f"Removing {dir_path}...")
              shutil.rmtree(dir_path)
  
  def cleanup_test_artifacts():
      """Remove test artifacts"""
      dirs_to_remove = ['.pytest_cache', '.coverage', 'htmlcov']
      
      for dir_name in dirs_to_remove:
          dir_path = Path(dir_name)
          if dir_path.exists():
              print(f"Removing {dir_path}...")
              shutil.rmtree(dir_path)
  
  def cleanup_ide_artifacts():
      """Remove IDE artifacts"""
      dirs_to_remove = ['.idea', '.vscode', '.mypy_cache']
      
      for dir_name in dirs_to_remove:
          dir_path = Path(dir_name)
          if dir_path.exists():
              print(f"Removing {dir_path}...")
              shutil.rmtree(dir_path)
  
  def main():
      """Main cleanup function"""
      print("Cleaning up repository...")
      cleanup_build_artifacts()
      cleanup_test_artifacts()
      cleanup_ide_artifacts()
      print("Cleanup complete")
  
  if __name__ == '__main__':
      main()
  ```

**2.3.4.2 Repository Size Monitor**
- **File to Create**: `scripts/monitor_repo_size.py`
- **Purpose**: Monitor repository size over time
- **Implementation**:
  ```python
  #!/usr/bin/env python3
  """Monitor repository size"""
  import subprocess
  import json
  from pathlib import Path
  from datetime import datetime
  
  def get_repo_size():
      """Get repository size"""
      result = subprocess.run(['git', 'count-objects', '-vH'], 
                            capture_output=True, text=True)
      return result.stdout
  
  def get_largest_files():
      """Get largest files in repository"""
      result = subprocess.run(['git', 'ls-files', '-z'], 
                            capture_output=True, text=True)
      files = result.stdout.strip().split('\0')
      
      file_sizes = []
      for file in files:
          if file:
              path = Path(file)
              if path.exists():
                  size = path.stat().st_size
                  file_sizes.append((file, size))
      
      return sorted(file_sizes, key=lambda x: x[1], reverse=True)[:10]
  
  def main():
      """Main monitoring function"""
      print("Repository Size Monitor")
      print("=" * 50)
      print(get_repo_size())
      print("\nLargest files:")
      for file, size in get_largest_files():
          print(f"  {file}: {size / 1024:.2f} KB")
  
  if __name__ == '__main__':
      main()
  ```

## Implementation Checklist

### .gitignore Configuration
- [ ] Create comprehensive .gitignore
- [ ] Test .gitignore with common files
- [ ] Validate ignored files are not tracked
- [ ] Document .gitignore patterns

### Large File Detection
- [ ] Create large file check script
- [ ] Configure CI gate for large files
- [ ] Test large file detection
- [ ] Document large file handling

### CI Gates
- [ ] Configure pre-commit hooks
- [ ] Create repository health check
- [ ] Set up CI validation workflow
- [ ] Test all gates

### Repository Maintenance
- [ ] Create cleanup scripts
- [ ] Create size monitoring script
- [ ] Document maintenance procedures
- [ ] Schedule regular maintenance

## Files to Create/Modify

### New Files
1. `scripts/check_large_files.py` - Large file detection
2. `scripts/validate_gitignore.py` - .gitignore validation
3. `scripts/check_repo_health.py` - Repository health check
4. `scripts/cleanup_repo.py` - Repository cleanup
5. `scripts/monitor_repo_size.py` - Repository size monitoring
6. `.github/workflows/repo-validation.yml` - Repository validation workflow
7. `DOCS/POLICY/Large_Files.md` - Large file handling policy

### Files to Modify
1. `.gitignore` - Comprehensive ignore patterns
2. `.pre-commit-config.yaml` - Pre-commit hooks
3. `.github/workflows/large-file-check.yml` - Large file CI gate

## Implementation Dependencies

### Prerequisites
- Step 2.1: Goals and Principles (defines requirements)
- Step 2.2: Tooling Choices (uses build scripts)
- Git repository initialized
- Python 3.11 installed

### Enables
- Step 2.4: Version Management (clean repository)
- Step 2.5: CI Structure (uses validation)
- All subsequent steps (clean repository)

## Success Criteria

### .gitignore
- ✅ All build artifacts ignored
- ✅ All dependencies ignored
- ✅ All temporary files ignored
- ✅ No sensitive files tracked

### Large File Detection
- ✅ Large files detected
- ✅ CI gate prevents large file commits
- ✅ Clear error messages
- ✅ Handling guidelines documented

### CI Gates
- ✅ Pre-commit hooks working
- ✅ Repository health checks passing
- ✅ Validation workflow running
- ✅ All gates enforced

### Repository Maintenance
- ✅ Cleanup scripts working
- ✅ Size monitoring active
- ✅ Maintenance procedures documented
- ✅ Repository remains clean

## Next Implementation Steps

After completing Step 2.3:
1. **Step 2.4**: Version Management (uses clean repository)
2. **Step 2.5**: CI Structure (uses validation gates)
3. **Step 2.6**: Artifact Structure (uses repository hygiene)

## Detailed Implementation Guidance

### .gitignore Best Practices

#### Pattern Organization
Organize .gitignore by category:
1. Language-specific (Python)
2. Platform-specific (macOS, Windows, Linux)
3. IDE-specific
4. Build artifacts
5. Project-specific

#### Testing .gitignore
Test that ignored files are actually ignored:
```bash
# Create test file
touch test_ignored.txt

# Add to .gitignore
echo "test_ignored.txt" >> .gitignore

# Check if ignored
git status  # Should not show test_ignored.txt

# Clean up
rm test_ignored.txt
```

#### Common Mistakes
1. **Trailing slashes**: Use `/` for directories, no slash for files
2. **Negation patterns**: Use `!` to un-ignore
3. **Pattern specificity**: More specific patterns first
4. **Platform differences**: Use platform-specific sections

### Large File Detection Details

#### Size Limits
- **Maximum file size**: 50MB
- **Rationale**: GitHub has 100MB limit, 50MB provides buffer
- **Configurable**: Can be adjusted in script

#### Detection Methods
1. **File system scan**: Walk directory tree
2. **Git tracking check**: Check tracked files
3. **CI validation**: Automated check in CI

#### Handling Large Files
1. **Git LFS**: For files that must be versioned
2. **External storage**: For files not needed in repo
3. **Exclusion**: Add to .gitignore

### CI Gates Implementation

#### Pre-commit Hooks
Install and configure:
```bash
pip install pre-commit
pre-commit install
pre-commit run --all-files
```

#### CI Validation
Set as required check in GitHub:
1. Go to repository settings
2. Branches → Branch protection rules
3. Add required check: "Repository Validation"

#### Gate Failure Handling
- **Fail fast**: Stop on first failure
- **Clear messages**: Explain what failed
- **Actionable**: Tell user how to fix

### Repository Maintenance

#### Regular Maintenance Tasks
1. **Weekly**: Run health check
2. **Monthly**: Review large files
3. **Quarterly**: Clean up old branches
4. **As needed**: Clean build artifacts

#### Automation
- **CI schedule**: Weekly validation
- **Pre-commit**: Automatic cleanup
- **Scripts**: One-command maintenance

## References

- Main document: `../02_Build_System_and_Release_Pipeline.md`
- Git documentation: https://git-scm.com/docs
- Pre-commit: https://pre-commit.com/
- Git LFS: https://git-lfs.github.com/
