# Implementation Step 3.8: Common Pitfalls and Prevention

## Implementation Overview
**What We're Building**: A comprehensive guide to common pitfalls, errors, and issues encountered during macOS packaging, signing, and notarization, along with prevention strategies, detection methods, troubleshooting procedures, and best practices to avoid these issues. This document serves as a reference for developers and a checklist for quality assurance.

## Implementation Tasks

### Task 3.8.1: Document Technical Pitfalls

**What to Build**
- Comprehensive list of technical pitfalls
- Pitfall descriptions and symptoms
- Root cause analysis
- Prevention strategies
- Resolution procedures

**Implementation Details**

**3.8.1.1 Hardened Runtime Pitfalls**
- **Pitfall**: Hardened runtime not enabled
  - **Symptoms**: Notarization fails with "hardened runtime" error
  - **Root Cause**: Missing `--options runtime` flag in codesign
  - **Prevention**: Always use `--options runtime` when signing
  - **Detection**: Check code signature: `codesign -dvv` should show "runtime"
  - **Resolution**: Re-sign with `--options runtime` flag
  - **Script Check**: `scripts/validate_signing.py` should check for hardened runtime
- **Pitfall**: Hardened runtime enabled but missing entitlements
  - **Symptoms**: App crashes or fails to function
  - **Root Cause**: App needs entitlements but they're missing
  - **Prevention**: Test app with hardened runtime, add entitlements only if needed
  - **Detection**: App testing, crash logs
  - **Resolution**: Add required entitlements to entitlements.plist
  - **Note**: Minimal entitlements principle - add only what's absolutely needed

**3.8.1.2 Signing Order Pitfalls**
- **Pitfall**: Signing nested items after app bundle
  - **Symptoms**: Signatures invalid, notarization fails
  - **Root Cause**: Wrong signing order (parent before children)
  - **Prevention**: Always sign nested items before parent
  - **Detection**: Signature verification fails
  - **Resolution**: Re-sign in correct order (nested items first, app bundle last)
  - **Script Fix**: Ensure `scripts/sign_macos.sh` signs in correct order
- **Pitfall**: Using --deep without explicit signing
  - **Symptoms**: Some items not signed, notarization fails
  - **Root Cause**: --deep may miss some items
  - **Prevention**: Sign nested items explicitly, use --deep only for app bundle
  - **Detection**: Comprehensive signature verification
  - **Resolution**: Explicitly sign all nested items
  - **Best Practice**: Hybrid approach (explicit + --deep)

**3.8.1.3 Unsigned Nested Items Pitfalls**
- **Pitfall**: Unsigned frameworks or libraries
  - **Symptoms**: Notarization fails with "unsigned code" error
  - **Root Cause**: Missing signing step for nested items
  - **Prevention**: Sign all frameworks, libraries, and nested binaries
  - **Detection**: `codesign --verify --deep` fails, notarization log shows unsigned items
  - **Resolution**: Sign all nested items before app bundle
  - **Script Enhancement**: Ensure signing script finds and signs all items
- **Pitfall**: Qt frameworks not signed
  - **Symptoms**: Notarization fails, Qt-related errors
  - **Root Cause**: Qt frameworks in Frameworks/ not signed
  - **Prevention**: Explicitly sign all Qt frameworks
  - **Detection**: Framework signature verification
  - **Resolution**: Sign Qt frameworks individually
  - **Common Issue**: PyInstaller bundles Qt, must sign each framework

**3.8.1.4 Notarization Stapling Pitfalls**
- **Pitfall**: Notarization approved but not stapled
  - **Symptoms**: Gatekeeper warnings, offline verification fails
  - **Root Cause**: Forgot to staple notarization ticket
  - **Prevention**: Always staple after notarization approval
  - **Detection**: `xcrun stapler validate` fails
  - **Resolution**: Staple notarization ticket: `xcrun stapler staple`
  - **Script Fix**: Ensure `scripts/notarize_macos.sh` staples after approval
- **Pitfall**: Stapling before notarization approval
  - **Symptoms**: Stapling fails, "no ticket" error
  - **Root Cause**: Attempted stapling before approval
  - **Prevention**: Wait for notarization approval before stapling
  - **Detection**: Stapling command fails
  - **Resolution**: Wait for approval, then staple
  - **Script Fix**: Use --wait flag or poll for approval status

**3.8.1.5 Architecture Mismatch Pitfalls**
- **Pitfall**: Mixed architectures in bundle
  - **Symptoms**: App fails to launch, architecture errors
  - **Root Cause**: App and frameworks have different architectures
  - **Prevention**: Ensure all components are Universal2 or same architecture
  - **Detection**: `lipo -info` shows architecture mismatches
  - **Resolution**: Rebuild with consistent architecture
  - **Validation**: `scripts/validate_architecture.py` should check consistency
- **Pitfall**: Universal2 build but frameworks are single architecture
  - **Symptoms**: App works on one architecture but not the other
  - **Root Cause**: Frameworks not Universal2
  - **Prevention**: Use Universal2 frameworks
  - **Detection**: Architecture validation
  - **Resolution**: Rebuild with Universal2 frameworks

**3.8.1.6 Bundle Structure Pitfalls**
- **Pitfall**: Incorrect app bundle structure
  - **Symptoms**: App doesn't launch, notarization fails
  - **Root Cause**: Missing required directories or files
  - **Prevention**: Validate bundle structure before signing
  - **Detection**: Structure validation script
  - **Resolution**: Fix bundle structure, rebuild
  - **Common Issues**: Missing Contents/, MacOS/, Resources/, Info.plist
- **Pitfall**: Executable name mismatch
  - **Symptoms**: App doesn't launch, "executable not found" error
  - **Root Cause**: Executable name doesn't match Info.plist
  - **Prevention**: Ensure executable name matches CFBundleExecutable
  - **Detection**: Compare executable name with Info.plist
  - **Resolution**: Fix executable name or Info.plist

**3.8.1.7 Metadata Inconsistency Pitfalls**
- **Pitfall**: Version mismatch between files
  - **Symptoms**: Wrong version displayed, update failures
  - **Root Cause**: Version not updated consistently
  - **Prevention**: Use single source of truth (version.py), automated injection
  - **Detection**: Version validation script
  - **Resolution**: Update version consistently, revalidate
  - **Script**: `scripts/validate_version.py` should catch this
- **Pitfall**: Bundle ID mismatch
  - **Symptoms**: Update failures, app conflicts
  - **Root Cause**: Bundle ID changed or inconsistent
  - **Prevention**: Bundle ID must never change, validate consistency
  - **Detection**: Bundle ID validation script
  - **Resolution**: Fix bundle ID consistency (but never change value)
  - **Script**: `scripts/validate_bundle_id.py` should catch this

### Task 3.8.2: Document Operational Pitfalls

**What to Build**
- Operational "gotchas" and issues
- Workflow problems
- CI/CD issues
- Release process issues
- User experience issues

**Implementation Details**

**3.8.2.1 DMG Installation Pitfalls**
- **Pitfall**: Running app from DMG without installing
  - **Symptoms**: Update mechanism may not work, file access issues
  - **Root Cause**: App expects to be in Applications folder
  - **Prevention**: Clear installation instructions, DMG layout guides user
  - **Detection**: User reports, support tickets
  - **Resolution**: User education, improve DMG layout
  - **Best Practice**: App should work from DMG but recommend installation
- **Pitfall**: App writes to bundle instead of Application Support
  - **Symptoms**: Data lost on update, permission errors
  - **Root Cause**: App writes to app bundle (read-only after installation)
  - **Prevention**: Always write to Application Support, never to bundle
  - **Detection**: Code review, testing
  - **Resolution**: Fix app to use Application Support
  - **Best Practice**: Use `~/Library/Application Support/CuePoint/` for data

**3.8.2.2 Certificate and Secret Pitfalls**
- **Pitfall**: Certificate expired
  - **Symptoms**: Signing fails, "certificate expired" error
  - **Root Cause**: Certificate not renewed before expiry
  - **Prevention**: Monitor certificate expiry, renew 30 days before
  - **Detection**: Certificate validation script
  - **Resolution**: Renew certificate, update secrets
  - **Monitoring**: Automated expiry monitoring
- **Pitfall**: Wrong certificate type
  - **Symptoms**: Signing works but notarization fails
  - **Root Cause**: Using Apple Development instead of Developer ID
  - **Prevention**: Verify certificate type is "Developer ID Application"
  - **Detection**: Certificate validation
  - **Resolution**: Use correct certificate type
- **Pitfall**: Secrets not configured in GitHub
  - **Symptoms**: CI build fails, "secret not found" error
  - **Root Cause**: Secrets not added to GitHub repository
  - **Prevention**: Document required secrets, validate in CI
  - **Detection**: Secret validation script
  - **Resolution**: Add missing secrets to GitHub
  - **Documentation**: `DOCS/GUIDES/GitHub_Secrets_Setup.md`

**3.8.2.3 CI/CD Workflow Pitfalls**
- **Pitfall**: Workflow runs on wrong trigger
  - **Symptoms**: Builds run when not needed, or don't run when needed
  - **Root Cause**: Incorrect workflow trigger configuration
  - **Prevention**: Test workflow triggers, document trigger behavior
  - **Detection**: Workflow run history
  - **Resolution**: Fix workflow trigger configuration
- **Pitfall**: Artifact download fails in release workflow
  - **Symptoms**: Release workflow fails, artifacts not found
  - **Root Cause**: Artifact names don't match, artifacts expired
  - **Prevention**: Use consistent artifact names, download immediately
  - **Detection**: Workflow logs show download failure
  - **Resolution**: Fix artifact names, ensure artifacts available
- **Pitfall**: Notarization timeout in CI
  - **Symptoms**: CI build times out waiting for notarization
  - **Root Cause**: Notarization takes longer than CI timeout
  - **Prevention**: Set appropriate timeout (1 hour), use --wait flag
  - **Detection**: CI timeout errors
  - **Resolution**: Increase timeout, monitor notarization times

**3.8.2.4 Release Process Pitfalls**
- **Pitfall**: Release published before notarization complete
  - **Symptoms**: Users get un-notarized app, Gatekeeper warnings
  - **Root Cause**: Release workflow doesn't wait for notarization
  - **Prevention**: Release workflow depends on notarization completion
  - **Detection**: Release artifacts not notarized
  - **Resolution**: Fix workflow dependencies, re-release
- **Pitfall**: Wrong version in release
  - **Symptoms**: Version mismatch, update failures
  - **Root Cause**: Version not updated before release
  - **Prevention**: Version validation before release
  - **Detection**: Version validation script
  - **Resolution**: Fix version, re-release

### Task 3.8.3: Implement Pitfall Prevention

**What to Build**
- Automated pitfall detection
- Prevention scripts and checks
- Pre-commit validation
- CI validation gates
- Documentation and checklists

**Implementation Details**

**3.8.3.1 Automated Pitfall Detection**
- **Detection Scripts**:
  - `scripts/validate_signing.py`: Detects signing issues
  - `scripts/validate_notarization.py`: Detects notarization issues
  - `scripts/validate_architecture.py`: Detects architecture issues
  - `scripts/validate_bundle_id.py`: Detects bundle ID issues
  - `scripts/validate_version.py`: Detects version issues
  - `scripts/validate_release.py`: Master validation (all checks)
- **Detection Timing**:
  - Pre-build: Validate configuration
  - Post-build: Validate artifacts
  - Pre-release: Final validation
  - Post-release: Verify release
- **Detection Automation**: Automated in CI/CD pipeline
- **Detection Reporting**: Clear error messages with solutions

**3.8.3.2 Prevention Scripts**
- **Pre-Build Prevention**:
  - Validate certificate not expired
  - Validate bundle ID consistent
  - Validate version consistent
  - Validate configuration correct
- **Post-Build Prevention**:
  - Validate all signatures
  - Validate hardened runtime
  - Validate architecture consistency
  - Validate metadata consistency
- **Pre-Release Prevention**:
  - Comprehensive validation
  - Compare with previous release
  - Verify all requirements met
- **Prevention Integration**: Integrated in CI/CD workflows

**3.8.3.3 Pre-Commit Validation** (Optional)
- **Pre-Commit Hooks**: Validate before commit
  - **Purpose**: Catch issues early
  - **Checks**: Bundle ID, version format, configuration
  - **Implementation**: Git hooks or pre-commit framework
  - **Optional**: Not required, but helpful
- **Pre-Commit Checks**:
  - Bundle ID not changed
  - Version format valid
  - Configuration valid
  - No secrets committed

**3.8.3.4 CI Validation Gates**
- **Validation Gates**: Required checks before release
  - **Purpose**: Prevent bad releases
  - **Checks**: All validation scripts must pass
  - **Integration**: Required status checks in GitHub
  - **Failure**: Blocks release if validation fails
- **Gate Configuration**:
  - Signing validation: Required
  - Notarization validation: Required
  - Version validation: Required
  - Bundle ID validation: Required
  - Architecture validation: Required

**3.8.3.5 Documentation and Checklists**
- **Pitfall Documentation**: `DOCS/TROUBLESHOOTING/Common_Pitfalls.md`
- **Pre-Release Checklist**: Comprehensive checklist
- **Troubleshooting Guides**: Step-by-step solutions
- **Best Practices**: Documented best practices
- **Examples**: Real examples of pitfalls and solutions

### Task 3.8.4: Implement Troubleshooting Procedures

**What to Build**
- Troubleshooting procedures for each pitfall
- Diagnostic commands and scripts
- Resolution procedures
- Escalation procedures
- Support documentation

**Implementation Details**

**3.8.4.1 Troubleshooting Procedures**
- **Procedure Structure**:
  1. Identify symptoms
  2. Run diagnostic commands
  3. Identify root cause
  4. Apply resolution
  5. Verify fix
  6. Document solution
- **Procedure Documentation**: Step-by-step for each pitfall
- **Procedure Automation**: Automated diagnostics where possible
- **Procedure Testing**: Test procedures work correctly

**3.8.4.2 Diagnostic Commands**
- **Signing Diagnostics**:
  - `codesign -dvv`: Signature details
  - `codesign --verify --deep --strict`: Verify signatures
  - `spctl -a -vv`: Gatekeeper assessment
  - `security find-identity`: Available identities
- **Notarization Diagnostics**:
  - `xcrun notarytool log`: Notarization log
  - `xcrun stapler validate`: Stapling validation
  - `spctl -a -vv`: Gatekeeper assessment
- **Architecture Diagnostics**:
  - `file`: Binary format
  - `lipo -info`: Architecture information
  - `arch`: Current architecture
- **Metadata Diagnostics**:
  - `defaults read`: Info.plist contents
  - `plutil -p`: Property list display

**3.8.4.3 Resolution Procedures**
- **Resolution Steps**: Clear, actionable steps
- **Resolution Validation**: Verify resolution works
- **Resolution Documentation**: Document resolution
- **Resolution Automation**: Automated where possible
- **Resolution Testing**: Test resolution procedures

**3.8.4.4 Escalation Procedures**
- **Escalation Triggers**: When to escalate
- **Escalation Path**: Who to contact
- **Escalation Information**: What information to provide
- **Escalation Documentation**: Document escalation process

### Task 3.8.5: Implement Best Practices Enforcement

**What to Build**
- Best practices documentation
- Best practices validation
- Best practices checklists
- Best practices automation
- Best practices training

**Implementation Details**

**3.8.5.1 Best Practices Documentation**
- **Documentation Location**: `DOCS/BEST_PRACTICES/macOS_Packaging.md`
- **Documentation Content**:
  - Signing best practices
  - Notarization best practices
  - Bundle structure best practices
  - Update compatibility best practices
  - Security best practices
- **Documentation Updates**: Update as practices evolve
- **Documentation Usage**: Reference for developers, QA, operations

**3.8.5.2 Best Practices Validation**
- **Validation Scripts**: Check for best practices
- **Validation Checks**:
  - Hardened runtime enabled
  - Timestamps present
  - Entitlements minimal
  - Bundle structure correct
  - Metadata consistent
- **Validation Automation**: Automated in CI/CD
- **Validation Reporting**: Report violations

**3.8.5.3 Best Practices Checklists**
- **Pre-Build Checklist**: Best practices before build
- **Post-Build Checklist**: Best practices after build
- **Pre-Release Checklist**: Best practices before release
- **Checklist Automation**: Automated checklist validation
- **Checklist Documentation**: Document all checklists

**3.8.5.4 Best Practices Automation**
- **Automated Checks**: Automate best practice validation
- **Automated Enforcement**: Fail build if best practices violated
- **Automated Reporting**: Report best practice status
- **Automated Documentation**: Generate best practice reports

## Implementation Checklist

### Technical Pitfalls
- [ ] Document all technical pitfalls
- [ ] Create prevention strategies
- [ ] Create detection methods
- [ ] Create resolution procedures

### Operational Pitfalls
- [ ] Document operational pitfalls
- [ ] Create prevention strategies
- [ ] Create detection methods
- [ ] Create resolution procedures

### Prevention
- [ ] Create automated detection
- [ ] Create prevention scripts
- [ ] Create validation gates
- [ ] Create documentation

### Troubleshooting
- [ ] Create troubleshooting procedures
- [ ] Create diagnostic commands
- [ ] Create resolution procedures
- [ ] Create escalation procedures

### Best Practices
- [ ] Document best practices
- [ ] Create validation
- [ ] Create checklists
- [ ] Automate enforcement

## Files to Create/Modify

### New Files
1. `DOCS/DESIGNS/SHIP v1.0/Step_3_macOS_Packaging/3.8_Common_Pitfalls.md` - This document
2. `DOCS/TROUBLESHOOTING/Common_Pitfalls.md` - Troubleshooting guide
3. `DOCS/BEST_PRACTICES/macOS_Packaging.md` - Best practices guide

### Files to Modify
1. All validation scripts - Add pitfall detection
2. `DOCS/DESIGNS/SHIP v1.0/Step_3_macOS_Packaging/README.md` - Add reference

## Implementation Dependencies

### Prerequisites
- All Step 3 substeps (to understand pitfalls)
- Experience with macOS packaging (to identify pitfalls)

### Enables
- Quality assurance (prevents issues)
- Developer guidance (avoids pitfalls)
- Troubleshooting (resolves issues)

## Success Criteria

### Pitfall Documentation
- ✅ All common pitfalls documented
- ✅ Prevention strategies defined
- ✅ Detection methods implemented
- ✅ Resolution procedures documented

### Prevention
- ✅ Automated detection working
- ✅ Validation gates effective
- ✅ Best practices enforced
- ✅ Issues prevented

### Troubleshooting
- ✅ Procedures documented
- ✅ Diagnostic tools available
- ✅ Resolution procedures work
- ✅ Support documentation complete

## Next Implementation Steps

After completing Step 3.8:
1. **Step 4**: Windows Packaging (parallel implementation)
2. **Step 5**: Auto-Update System (uses macOS packaging)

## Detailed Pitfall Analysis

### Signing Pitfall Deep Dive

**Pitfall: Incomplete Nested Item Signing**

**Detailed Analysis**:
- **Root Cause**: PyInstaller bundles many nested items (frameworks, libraries, helpers) that must be signed individually. Using only `--deep` on the app bundle may miss some items or sign them in wrong order.
- **Impact**: Notarization fails with "unsigned code" errors, Gatekeeper warnings, app may not launch.
- **Detection Methods**:
  - `codesign --verify --deep --strict` fails
  - Notarization log shows unsigned items
  - `codesign -dvv` shows missing signatures
  - `spctl -a -vv` fails
- **Prevention Strategy**:
  1. Sign all frameworks explicitly before app bundle
  2. Sign all nested binaries explicitly
  3. Sign all .dylib files explicitly
  4. Then sign app bundle with --deep
  5. Verify all signatures after signing
- **Resolution Procedure**:
  1. Identify unsigned items from notarization log
  2. Sign each unsigned item individually
  3. Re-sign app bundle
  4. Verify all signatures
  5. Re-submit for notarization
- **Script Enhancement**: Enhance `scripts/sign_macos.sh` to:
  - Find all executable files recursively
  - Find all frameworks recursively
  - Sign each item with proper options
  - Verify each signature
  - Report signing status

**Enhanced Signing Script Pattern**:
```bash
#!/bin/bash
# Enhanced signing with comprehensive nested item handling

APP_PATH="$1"
IDENTITY="${APPLE_DEVELOPER_ID}"

# Function to sign item
sign_item() {
    local item="$1"
    echo "Signing: $item"
    codesign --force --sign "$IDENTITY" \
        --options runtime \
        --timestamp \
        "$item"
    
    # Verify immediately
    codesign --verify "$item" || {
        echo "ERROR: Failed to sign $item"
        return 1
    }
}

# Step 1: Sign all .dylib files
find "$APP_PATH" -name "*.dylib" -type f | while read dylib; do
    sign_item "$dylib"
done

# Step 2: Sign all frameworks
find "$APP_PATH" -name "*.framework" -type d | while read framework; do
    # Sign framework executable
    framework_exe="$framework/Versions/Current/$(basename "$framework" .framework)"
    if [ -f "$framework_exe" ]; then
        sign_item "$framework_exe"
    fi
    # Sign framework bundle
    sign_item "$framework"
done

# Step 3: Sign all helper executables
find "$APP_PATH/Contents/Helpers" -type f -perm +111 2>/dev/null | while read helper; do
    sign_item "$helper"
done

# Step 4: Sign main executable
sign_item "$APP_PATH/Contents/MacOS/CuePoint"

# Step 5: Sign app bundle (with --deep for final verification)
codesign --force --deep --sign "$IDENTITY" \
    --options runtime \
    --timestamp \
    "$APP_PATH"

# Final verification
codesign --verify --deep --strict --verbose "$APP_PATH"
```

### Notarization Pitfall Deep Dive

**Pitfall: Notarization Rejection Due to Entitlements**

**Detailed Analysis**:
- **Root Cause**: App requests entitlements that Apple doesn't allow for notarized apps, or entitlements are incorrectly configured.
- **Common Disallowed Entitlements**:
  - `com.apple.security.cs.allow-jit` (may be allowed with justification)
  - `com.apple.security.cs.allow-unsigned-executable-memory` (restricted)
  - `com.apple.security.cs.disable-library-validation` (restricted)
  - Custom entitlements not approved by Apple
- **Impact**: Notarization rejected, app cannot be distributed, Gatekeeper blocks app.
- **Detection Methods**:
  - Notarization log shows entitlement errors
  - `codesign -d --entitlements` shows problematic entitlements
  - Notarization status is "Invalid"
- **Prevention Strategy**:
  1. Use minimal entitlements (none if possible)
  2. Test app without entitlements first
  3. Add entitlements only if absolutely required
  4. Review Apple's entitlement documentation
  5. Test notarization with entitlements before release
- **Resolution Procedure**:
  1. Retrieve notarization log: `xcrun notarytool log <submission-id>`
  2. Identify problematic entitlements
  3. Remove or fix entitlements
  4. Re-sign app with corrected entitlements
  5. Re-submit for notarization
- **Best Practice**: Start with no entitlements, add only what's absolutely necessary, document why each entitlement is needed.

**Entitlements Review Process**:
```python
#!/usr/bin/env python3
"""Review and validate entitlements"""

import plistlib
import subprocess
import sys
from pathlib import Path

ALLOWED_ENTITLEMENTS = [
    # Network (usually implicit, no entitlement needed)
    # File access (user-selected, no entitlement needed)
    # Add only if absolutely required
]

DISALLOWED_ENTITLEMENTS = [
    'com.apple.security.cs.disable-library-validation',
    # Add other disallowed entitlements
]

def get_entitlements(app_path):
    """Extract entitlements from app"""
    result = subprocess.run(
        ['codesign', '-d', '--entitlements', ':-', str(app_path)],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        return None
    
    # Parse entitlements XML
    import xml.etree.ElementTree as ET
    root = ET.fromstring(result.stdout)
    
    entitlements = {}
    for key in root.findall('.//key'):
        key_name = key.text
        # Get corresponding value
        value_elem = key.getnext()
        if value_elem is not None:
            entitlements[key_name] = value_elem.text
    
    return entitlements

def validate_entitlements(entitlements):
    """Validate entitlements are minimal and allowed"""
    warnings = []
    errors = []
    
    if not entitlements:
        return True, [], "No entitlements (optimal)"
    
    for key, value in entitlements.items():
        if key in DISALLOWED_ENTITLEMENTS:
            errors.append(f"Disallowed entitlement: {key}")
        elif key not in ALLOWED_ENTITLEMENTS:
            warnings.append(f"Unreviewed entitlement: {key} (may cause notarization issues)")
    
    return len(errors) == 0, errors, warnings

if __name__ == '__main__':
    app_path = sys.argv[1] if len(sys.argv) > 1 else 'dist/CuePoint.app'
    entitlements = get_entitlements(app_path)
    
    if entitlements is None:
        print("Could not extract entitlements")
        sys.exit(1)
    
    valid, errors, warnings = validate_entitlements(entitlements)
    
    if errors:
        print("Entitlement errors:")
        for error in errors:
            print(f"  ✗ {error}")
    
    if warnings:
        print("Entitlement warnings:")
        for warning in warnings:
            print(f"  ⚠ {warning}")
    
    if valid and not warnings:
        print("✓ Entitlements validated (minimal and allowed)")
        sys.exit(0)
    else:
        sys.exit(1)
```

### Architecture Pitfall Deep Dive

**Pitfall: Universal2 Build but Single-Architecture Frameworks**

**Detailed Analysis**:
- **Root Cause**: App built as Universal2, but Qt frameworks or other dependencies are single-architecture (either x86_64 or arm64 only).
- **Impact**: App works on one architecture but crashes or fails on the other. User experience is broken on unsupported architecture.
- **Detection Methods**:
  - `lipo -info` on app shows Universal2
  - `lipo -info` on frameworks shows single architecture
  - App crashes on unsupported architecture
  - Architecture validation script detects mismatch
- **Prevention Strategy**:
  1. Verify Python is Universal2
  2. Verify Qt frameworks are Universal2
  3. Verify all dependencies are Universal2
  4. Validate architecture consistency before signing
  5. Test on both architectures
- **Resolution Procedure**:
  1. Identify single-architecture frameworks
  2. Replace with Universal2 versions
  3. Rebuild app
  4. Validate all components are Universal2
  5. Re-sign and re-notarize

**Architecture Consistency Validation**:
```python
#!/usr/bin/env python3
"""Validate architecture consistency"""

import subprocess
import sys
from pathlib import Path

def get_architectures(binary_path):
    """Get architectures in binary"""
    result = subprocess.run(
        ['lipo', '-info', str(binary_path)],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        return []
    
    # Parse output: "Architectures in the fat file: ... are: x86_64 arm64"
    if 'are:' in result.stdout:
        archs = result.stdout.split('are:')[1].strip().split()
        return archs
    elif 'Non-fat file' in result.stdout:
        # Single architecture
        if 'x86_64' in result.stdout:
            return ['x86_64']
        elif 'arm64' in result.stdout:
            return ['arm64']
    
    return []

def validate_architecture_consistency(app_path):
    """Validate all components have consistent architecture"""
    app = Path(app_path)
    errors = []
    
    # Get app executable architectures
    exe = app / 'Contents' / 'MacOS' / 'CuePoint'
    if exe.exists():
        exe_archs = set(get_architectures(exe))
        print(f"Main executable architectures: {exe_archs}")
        
        # Check frameworks match
        frameworks = app / 'Contents' / 'Frameworks'
        if frameworks.exists():
            for framework in frameworks.glob('*.framework'):
                framework_exe = framework / 'Versions' / 'Current' / framework.stem
                if framework_exe.exists():
                    framework_archs = set(get_architectures(framework_exe))
                    if framework_archs != exe_archs:
                        errors.append(
                            f"Framework {framework.name}: {framework_archs} "
                            f"does not match app: {exe_archs}"
                        )
    
    return len(errors) == 0, errors

if __name__ == '__main__':
    app_path = sys.argv[1] if len(sys.argv) > 1 else 'dist/CuePoint.app'
    valid, errors = validate_architecture_consistency(app_path)
    
    if valid:
        print("Architecture consistency validated")
        sys.exit(0)
    else:
        print("Architecture consistency errors:")
        for error in errors:
            print(f"  {error}")
        sys.exit(1)
```

### Metadata Pitfall Deep Dive

**Pitfall: Version Mismatch Causing Update Failures**

**Detailed Analysis**:
- **Root Cause**: Version information inconsistent between version.py, Info.plist, git tags, and release artifacts. Update system cannot determine if update is available or which version is newer.
- **Impact**: Update mechanism fails, users cannot update, version confusion, support issues.
- **Detection Methods**:
  - Version validation script detects mismatches
  - Update system reports version errors
  - User reports update failures
  - Manual inspection shows version differences
- **Prevention Strategy**:
  1. Single source of truth (version.py)
  2. Automated version injection
  3. Version validation in CI
  4. Version consistency checks
  5. Clear version update procedures
- **Resolution Procedure**:
  1. Identify all version locations
  2. Update version.py (source of truth)
  3. Run version injection scripts
  4. Validate version consistency
  5. Rebuild and re-release if needed

### Troubleshooting Workflow

**Complete Troubleshooting Procedure**:
1. **Identify Symptoms**: What error or issue is occurring?
2. **Gather Information**: 
   - Error messages
   - Build logs
   - Notarization logs (if applicable)
   - System information
3. **Run Diagnostics**: 
   - Run validation scripts
   - Run diagnostic commands
   - Check logs
4. **Identify Root Cause**: 
   - Match symptoms to known pitfalls
   - Analyze diagnostic output
   - Review documentation
5. **Apply Resolution**: 
   - Follow resolution procedure
   - Test fix
   - Verify resolution
6. **Document Solution**: 
   - Document issue and resolution
   - Update troubleshooting guide
   - Share knowledge

## Comprehensive Pitfall Prevention System

### Automated Pitfall Detection System

**Detection Architecture**:
- **Pre-Build Detection**: Validate before build starts
  - Certificate validity
  - Configuration correctness
  - Dependencies availability
- **Post-Build Detection**: Validate after build completes
  - Bundle structure
  - Signing status
  - Metadata consistency
- **Pre-Release Detection**: Final validation before release
  - Comprehensive checks
  - Comparison with previous release
  - All requirements met

**Detection Script Integration**:
```python
#!/usr/bin/env python3
"""Master pitfall detection system"""

import subprocess
import sys
from pathlib import Path

DETECTIONS = [
    ('signing', 'scripts/validate_signing.py'),
    ('notarization', 'scripts/validate_notarization.py'),
    ('architecture', 'scripts/validate_architecture.py'),
    ('bundle_id', 'scripts/validate_bundle_id.py'),
    ('version', 'scripts/validate_version.py'),
    ('metadata', 'scripts/validate_metadata.py'),
]

def run_detection(name, script):
    """Run a detection script"""
    script_path = Path(script)
    if not script_path.exists():
        return True, f"Script not found: {script}"
    
    result = subprocess.run(
        [sys.executable, str(script_path)],
        capture_output=True,
        text=True
    )
    
    return result.returncode == 0, result.stdout + result.stderr

def detect_pitfalls():
    """Run all pitfall detections"""
    issues = []
    
    for name, script in DETECTIONS:
        print(f"Checking {name}...")
        passed, output = run_detection(name, script)
        
        if not passed:
            issues.append((name, output))
            print(f"  ✗ {name}: Issues detected")
        else:
            print(f"  ✓ {name}: OK")
    
    return len(issues) == 0, issues

if __name__ == '__main__':
    print("Pitfall Detection System")
    print("=" * 50)
    
    all_passed, issues = detect_pitfalls()
    
    print("\n" + "=" * 50)
    if all_passed:
        print("✓ No pitfalls detected")
        sys.exit(0)
    else:
        print("✗ Pitfalls detected:")
        for name, output in issues:
            print(f"\n{name}:")
            print(output)
        sys.exit(1)
```

### Pitfall Prevention Checklist

**Pre-Build Checklist**:
- [ ] Certificate valid and not expired
- [ ] Certificate type correct (Developer ID Application)
- [ ] Bundle ID defined and consistent
- [ ] Version defined and consistent
- [ ] All dependencies available
- [ ] Build environment clean
- [ ] Configuration files correct

**Build Checklist**:
- [ ] App bundle structure correct
- [ ] All required files present
- [ ] Executable permissions correct
- [ ] Info.plist valid and complete
- [ ] Version information embedded
- [ ] Bundle ID embedded correctly

**Signing Checklist**:
- [ ] All nested items signed
- [ ] All frameworks signed
- [ ] App bundle signed
- [ ] Hardened runtime enabled
- [ ] Timestamps present
- [ ] All signatures verified
- [ ] Gatekeeper assessment passes

**Notarization Checklist**:
- [ ] App/DMG signed correctly
- [ ] Hardened runtime enabled
- [ ] Entitlements minimal
- [ ] Notarization submitted
- [ ] Notarization approved
- [ ] Ticket stapled
- [ ] Stapling validated
- [ ] Gatekeeper assessment passes

**Pre-Release Checklist**:
- [ ] All validations passed
- [ ] Version consistent
- [ ] Bundle ID consistent
- [ ] Signing identity consistent
- [ ] Notarization complete
- [ ] Artifacts validated
- [ ] Release notes prepared
- [ ] Documentation updated

### Pitfall Response Procedures

**Immediate Response** (Critical Pitfalls):
- **Signing Failure**: Stop build, investigate, fix, retry
- **Notarization Failure**: Stop release, analyze log, fix, resubmit
- **Bundle ID Change**: Stop release, revert change, investigate
- **Version Regression**: Stop release, fix version, rebuild

**Escalated Response** (Complex Issues):
- **Architecture Issues**: May require rebuild, consult architecture expert
- **Entitlements Issues**: May require Apple review, consult security expert
- **Update Compatibility Issues**: May require update system changes, consult update expert

**Documented Response** (All Issues):
- Document issue and resolution
- Update troubleshooting guide
- Share knowledge with team
- Update prevention measures

## References

- Main document: `../03_macOS_Packaging_Signing_Notarization.md`
- Related: All Step 3 substeps
- Apple Developer Forums: Common issues and solutions
- Stack Overflow: macOS packaging questions
- Apple Code Signing Troubleshooting: https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution/troubleshooting
- Apple Notarization Troubleshooting: https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution/troubleshooting
