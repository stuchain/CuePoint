# Implementation Step 3.6: Runtime Requirements and Architecture Support

## Implementation Overview
**What We're Building**: A comprehensive runtime requirements and architecture support system that ensures CuePoint runs correctly on all supported macOS versions and architectures, including Intel (x86_64) and Apple Silicon (arm64) processors. This includes architecture detection, compatibility validation, system requirements enforcement, and comprehensive testing across different hardware and macOS versions.

## Implementation Tasks

### Task 3.6.1: Define Architecture Support Strategy

**What to Build**
- Architecture support definition
- Universal2 vs. separate builds analysis
- Architecture detection and validation
- Architecture-specific optimizations
- Architecture testing procedures

**Implementation Details**

**3.6.1.1 Architecture Support Options**
- **Option 1: Universal2 Binary (Recommended)**
  - **Description**: Single binary supporting both Intel and Apple Silicon
  - **Format**: Universal2 (fat binary with both architectures)
  - **Advantages**:
    - Single DMG for all users
    - Better user experience (no architecture selection)
    - Simpler distribution
    - Future-proof (works on all Macs)
  - **Disadvantages**:
    - Larger file size (2x binary size)
    - More complex build process
    - All dependencies must be Universal2
  - **Recommendation**: Use Universal2 for v1.0
- **Option 2: Separate Architecture Builds**
  - **Description**: Separate builds for arm64 and x86_64
  - **Format**: Architecture-specific binaries
  - **Advantages**:
    - Smaller file sizes
    - Simpler build process (per architecture)
    - Can optimize per architecture
  - **Disadvantages**:
    - Two DMGs to maintain
    - User must choose correct version
    - More complex distribution
    - Worse user experience
  - **Recommendation**: Not recommended for v1.0
- **Option 3: Intel Only (Legacy)**
  - **Description**: x86_64 only, relies on Rosetta 2
  - **Format**: x86_64 binary only
  - **Advantages**:
    - Simplest build process
    - Works on all Macs (via Rosetta)
  - **Disadvantages**:
    - Slower on Apple Silicon
    - Not native performance
    - Future compatibility concerns
  - **Recommendation**: Not recommended
- **Option 4: Apple Silicon Only (Future)**
  - **Description**: arm64 only, native Apple Silicon
  - **Format**: arm64 binary only
  - **Advantages**:
    - Best performance on Apple Silicon
    - Smaller file size
    - Modern architecture
  - **Disadvantages**:
    - Doesn't work on Intel Macs
    - Excludes Intel users
  - **Recommendation**: Future consideration (when Intel support not needed)

**3.6.1.2 Universal2 Implementation**
- **Build Process**:
  - PyInstaller can build Universal2 binaries
  - Requires Universal2 Python (or cross-compilation)
  - Requires Universal2 Qt frameworks
  - All dependencies must be Universal2
- **Build Configuration**:
  - PyInstaller spec: No special configuration needed
  - Python: Use Universal2 Python build
  - Qt: Use Universal2 Qt frameworks
  - Dependencies: Ensure all are Universal2
- **Validation**:
  - Check binary architecture: `file CuePoint.app/Contents/MacOS/CuePoint`
  - Should show: `Mach-O universal binary with 2 architectures`
  - Verify both architectures: `lipo -info`
- **Testing**:
  - Test on Intel Mac
  - Test on Apple Silicon Mac
  - Verify native execution on both

**3.6.1.3 Architecture Detection**
- **Runtime Detection**: Detect architecture at runtime
  - **Python**: `platform.machine()` or `platform.processor()`
  - **macOS**: `uname -m` or system calls
  - **Usage**: Architecture-specific optimizations (if needed)
- **Build-Time Detection**: Detect during build
  - **Purpose**: Architecture-specific build steps
  - **Method**: `platform.machine()` in build scripts
  - **Usage**: Conditional compilation (if needed)
- **Distribution Detection**: Detect in distribution
  - **Purpose**: Architecture-specific distributions
  - **Method**: Build-time architecture tagging
  - **Usage**: Separate downloads (if using separate builds)

**3.6.1.4 Architecture Validation**
- **Validation Requirements**:
  - Binary contains expected architectures
  - All frameworks match architecture
  - All dependencies match architecture
  - No architecture mismatches
- **Validation Commands**:
  - `file`: Check binary format
  - `lipo -info`: List architectures
  - `otool -hv`: Check architecture headers
  - `arch`: Check current architecture
- **Validation Script**: `scripts/validate_architecture.py`
- **Validation Timing**: After build, before signing

### Task 3.6.2: Define macOS Version Support

**What to Build**
- Minimum macOS version definition
- Version compatibility matrix
- Version-specific feature detection
- Version testing procedures
- Version documentation

**Implementation Details**

**3.6.2.1 Minimum macOS Version**
- **Current Minimum**: macOS 10.15 (Catalina)
- **Rationale**:
  - Released October 2019
  - Still widely used
  - Good balance of compatibility and features
  - Supports both Intel and Apple Silicon (via Rosetta 2)
  - Security updates still available
- **Version Requirements**:
  - **LSMinimumSystemVersion**: `10.15` in Info.plist
  - **API Usage**: No APIs from newer versions
  - **Testing**: Test on minimum version
  - **Documentation**: Document system requirements
- **Future Considerations**:
  - May increase to 11.0+ for Apple Silicon native
  - Consider user base and compatibility
  - Monitor macOS adoption rates
  - Plan version increases carefully

**3.6.2.2 Version Compatibility Matrix**
- **Supported Versions**:
  - **macOS 10.15 (Catalina)**: Fully supported
  - **macOS 11 (Big Sur)**: Fully supported
  - **macOS 12 (Monterey)**: Fully supported
  - **macOS 13 (Ventura)**: Fully supported
  - **macOS 14 (Sonoma)**: Fully supported
  - **macOS 15+ (Future)**: Test and support as released
- **Testing Requirements**:
  - Test on minimum version (10.15)
  - Test on latest version (14+)
  - Test on intermediate versions (spot check)
  - Test on both architectures
- **Compatibility Guarantee**: Works on all versions >= minimum

**3.6.2.3 Version-Specific Features**
- **Feature Detection**: Detect macOS version at runtime
  - **Python**: `platform.mac_ver()`
  - **Usage**: Conditional feature enablement
  - **Example**: Dark mode, new APIs
- **API Availability**: Check API availability
  - **Method**: Try/except or availability checks
  - **Usage**: Use new APIs only if available
  - **Fallback**: Provide fallback for older versions
- **Version-Specific Code**: Minimal version-specific code
  - **Principle**: Support minimum version primarily
  - **Enhancements**: Optional enhancements for newer versions
  - **Compatibility**: Always maintain compatibility

**3.6.2.4 Version Testing Procedures**
- **Test Matrix**:
  - macOS 10.15 on Intel
  - macOS 10.15 on Apple Silicon (Rosetta)
  - macOS 11+ on Intel
  - macOS 11+ on Apple Silicon
  - Latest macOS on both architectures
- **Test Scenarios**:
  - Installation
  - Launch
  - Core functionality
  - Update mechanism
  - System integration
- **Test Automation**: Automated testing where possible
- **Manual Testing**: Manual testing on physical hardware

### Task 3.6.3: Define System Requirements

**What to Build**
- Hardware requirements specification
- Software requirements specification
- System capability requirements
- Requirements documentation
- Requirements validation

**Implementation Details**

**3.6.3.1 Hardware Requirements**
- **Processor**:
  - **Intel**: x86_64 (64-bit)
  - **Apple Silicon**: arm64
  - **Minimum**: Any Mac from 2012+ (Intel) or 2020+ (Apple Silicon)
- **Memory (RAM)**:
  - **Minimum**: 4 GB
  - **Recommended**: 8 GB or more
  - **Usage**: Application memory + system overhead
- **Storage**:
  - **Application Size**: ~100-200 MB
  - **User Data**: Varies (typically < 1 GB)
  - **Minimum Free Space**: 500 MB recommended
- **Display**:
  - **Minimum**: 1280x800 resolution
  - **Recommended**: 1920x1080 or higher
  - **Retina**: Supported (high DPI)
- **Network** (for updates):
  - **Required**: Internet connection for updates
  - **Bandwidth**: Minimal (update downloads)
  - **Firewall**: Works behind firewalls/proxies

**3.6.3.2 Software Requirements**
- **macOS Version**: 10.15 (Catalina) or later
- **System Frameworks**: Included in macOS
  - Cocoa, Foundation, AppKit (standard)
  - No additional installation required
- **Python Runtime**: Embedded in app bundle
  - **Version**: Python 3.11 (embedded)
  - **Location**: App bundle (no separate installation)
- **Qt Frameworks**: Embedded in app bundle
  - **Version**: PySide6/Qt 6.x (embedded)
  - **Location**: App bundle Frameworks/
- **External Dependencies**: None required
  - All dependencies bundled
  - No user installation needed

**3.6.3.3 System Capability Requirements**
- **File System Access**: User-selected files only
  - **Method**: User file dialogs
  - **Entitlement**: Not required (user-selected)
  - **Scope**: Files user explicitly selects
- **Network Access**: For updates and web features
  - **Method**: Standard network APIs
  - **Entitlement**: Not required (implicit)
  - **Scope**: HTTPS connections
- **Hardware Access**: None required
  - **Camera**: Not used
  - **Microphone**: Not used
  - **Location**: Not used
- **System Integration**: Standard macOS integration
  - **File Associations**: Rekordbox XML files (optional)
  - **URL Schemes**: None (optional for future)
  - **Services**: None

**3.6.3.4 Requirements Documentation**
- **User Documentation**: Clear system requirements
  - **Location**: README, website, release notes
  - **Content**: Hardware, software, macOS version
  - **Format**: Easy to read, version-specific
- **Developer Documentation**: Technical requirements
  - **Location**: Developer docs
  - **Content**: Build requirements, dependencies
  - **Format**: Technical, detailed
- **Requirements Validation**: Verify requirements are met
  - **Method**: Runtime checks
  - **Purpose**: Inform user if requirements not met
  - **Implementation**: Graceful degradation or clear errors

### Task 3.6.4: Implement Architecture Validation

**What to Build**
- Architecture detection scripts
- Architecture validation procedures
- Architecture compatibility checks
- Architecture testing automation
- Architecture reporting

**Implementation Details**

**3.6.4.1 Architecture Detection**
- **Detection Methods**:
  - **Build-Time**: `platform.machine()` in Python
  - **Runtime**: `platform.machine()` or system calls
  - **Binary Inspection**: `file` or `lipo` commands
- **Detection Script**: `scripts/detect_architecture.py`
- **Detection Output**: Architecture identifier (arm64, x86_64, universal)
- **Detection Usage**: Build configuration, runtime optimization

**3.6.4.2 Architecture Validation**
- **Validation Requirements**:
  - Binary architecture matches expected
  - All frameworks match architecture
  - No architecture mismatches
  - Universal2 contains both architectures
- **Validation Commands**:
  ```bash
  # Check binary architecture
  file CuePoint.app/Contents/MacOS/CuePoint
  
  # List architectures in binary
  lipo -info CuePoint.app/Contents/MacOS/CuePoint
  
  # Check framework architectures
  find CuePoint.app/Contents/Frameworks -name "*.framework" -exec lipo -info {} \;
  ```
- **Validation Script**: `scripts/validate_architecture.py`
- **Validation Timing**: After build, before signing

**3.6.4.3 Architecture Compatibility Checks**
- **Compatibility Requirements**:
  - All binaries same architecture (or Universal2)
  - All frameworks match app architecture
  - No mixed architecture issues
  - Dependencies architecture-compatible
- **Compatibility Validation**:
  - Check all binaries
  - Check all frameworks
  - Check all libraries
  - Verify consistency
- **Compatibility Reporting**: Report any mismatches

**3.6.4.4 Architecture Testing**
- **Test Environments**:
  - Intel Mac (x86_64 native)
  - Apple Silicon Mac (arm64 native)
  - Apple Silicon Mac (Rosetta 2 for x86_64)
- **Test Scenarios**:
  - Installation
  - Launch
  - Core functionality
  - Performance
  - System integration
- **Test Automation**: Automated tests where possible
- **Manual Testing**: Manual testing on physical hardware

### Task 3.6.5: Implement Version Compatibility

**What to Build**
- Version detection and validation
- Version compatibility checks
- Version-specific testing
- Version documentation
- Version support policies

**Implementation Details**

**3.6.5.1 Version Detection**
- **Detection Methods**:
  - **Python**: `platform.mac_ver()[0]`
  - **System**: `sw_vers -productVersion`
  - **Info.plist**: `LSMinimumSystemVersion`
- **Detection Script**: `scripts/detect_macos_version.py`
- **Detection Usage**: Runtime feature detection, compatibility checks

**3.6.5.2 Version Compatibility Checks**
- **Compatibility Validation**:
  - Check minimum version requirement
  - Verify no newer-version-only APIs
  - Test on minimum version
  - Verify backward compatibility
- **Compatibility Testing**:
  - Test on minimum version (10.15)
  - Test on latest version (14+)
  - Test on intermediate versions
  - Verify all features work
- **Compatibility Reporting**: Report compatibility status

**3.6.5.3 Version-Specific Testing**
- **Test Matrix**: All supported versions
- **Test Scenarios**: Core functionality on each version
- **Test Automation**: Automated where possible
- **Manual Testing**: Manual on physical hardware
- **Test Reporting**: Comprehensive test reports

**3.6.5.4 Version Support Policies**
- **Support Policy**: Support minimum version and later
- **Deprecation Policy**: Advance notice before dropping support
- **Update Policy**: Regular testing on new macOS versions
- **Documentation**: Clear version support information

### Task 3.6.6: Implement Runtime Validation

**What to Build**
- Runtime requirement validation
- Runtime compatibility checks
- Runtime testing procedures
- Runtime error handling
- Runtime documentation

**Implementation Details**

**3.6.6.1 Runtime Requirement Validation**
- **Validation Checks**:
  - macOS version >= minimum
  - Architecture supported
  - Memory available
  - Disk space available
  - Network available (if needed)
- **Validation Timing**: At app startup
- **Validation Implementation**: Runtime checks in application
- **Validation Reporting**: Clear error messages if requirements not met

**3.6.6.2 Runtime Compatibility Checks**
- **Compatibility Validation**:
  - Check macOS version compatibility
  - Check architecture compatibility
  - Check system capabilities
  - Verify dependencies available
- **Compatibility Handling**:
  - Graceful degradation if possible
  - Clear error messages if not compatible
  - Suggest solutions to user
- **Compatibility Testing**: Test on various configurations

**3.6.6.3 Runtime Testing Procedures**
- **Test Environments**: Various macOS versions and architectures
- **Test Scenarios**: Real-world usage scenarios
- **Test Automation**: Automated runtime tests
- **Manual Testing**: Manual testing on physical hardware
- **Test Reporting**: Comprehensive runtime test reports

**3.6.6.4 Runtime Error Handling**
- **Error Detection**: Detect compatibility issues
- **Error Messages**: Clear, actionable error messages
- **Error Recovery**: Suggest solutions
- **Error Reporting**: Log errors for analysis

## Implementation Checklist

### Architecture Support
- [ ] Define architecture strategy
- [ ] Implement Universal2 build
- [ ] Create architecture detection
- [ ] Create architecture validation
- [ ] Test on both architectures

### macOS Version Support
- [ ] Define minimum version
- [ ] Create compatibility matrix
- [ ] Implement version detection
- [ ] Create version testing
- [ ] Document version support

### System Requirements
- [ ] Define hardware requirements
- [ ] Define software requirements
- [ ] Define capability requirements
- [ ] Create requirements documentation
- [ ] Implement requirements validation

### Validation
- [ ] Create architecture validation
- [ ] Create version validation
- [ ] Create runtime validation
- [ ] Automate validation
- [ ] Create reporting

## Files to Create/Modify

### New Files
1. `DOCS/DESIGNS/SHIP v1.0/Step_3_macOS_Packaging/3.6_Runtime_Requirements.md` - This document
2. `scripts/validate_architecture.py` - Architecture validation
3. `scripts/detect_architecture.py` - Architecture detection
4. `scripts/detect_macos_version.py` - Version detection

### Files to Modify
1. `build/pyinstaller.spec` - Architecture configuration
2. `build/Info.plist.template` - Architecture and version info
3. `DOCS/DESIGNS/SHIP v1.0/Step_3_macOS_Packaging/README.md` - Add reference

## Implementation Dependencies

### Prerequisites
- Step 3.2: Build Output (app bundle structure)
- Step 3.3: Bundle Identity (metadata configuration)
- Universal2 Python and Qt (for Universal2 build)

### Enables
- Step 3.7: Update Compatibility (architecture-aware updates)
- User distribution (works on all supported Macs)

## Success Criteria

### Architecture
- ✅ Universal2 binary created
- ✅ Both architectures validated
- ✅ Works on Intel and Apple Silicon
- ✅ Native performance on both

### Version Support
- ✅ Works on minimum version (10.15)
- ✅ Works on latest version (14+)
- ✅ Tested on all supported versions
- ✅ Version requirements documented

### System Requirements
- ✅ Requirements defined
- ✅ Requirements validated
- ✅ Requirements documented
- ✅ Requirements met by app

## Next Implementation Steps

After completing Step 3.6:
1. **Step 3.7**: Update Compatibility (ensures updates work across architectures)
2. **Step 3.8**: Common Pitfalls (prevents known issues)

## Detailed Implementation Guidance

### Universal2 Build Process

**Complete Build Workflow**:
1. **Environment Setup**:
   - Install Universal2 Python (or use Rosetta 2)
   - Install Universal2 Qt frameworks
   - Verify all dependencies are Universal2
2. **PyInstaller Configuration**:
   - No special configuration needed for Universal2
   - PyInstaller automatically creates Universal2 if Python is Universal2
   - Verify spec file doesn't force single architecture
3. **Build Execution**:
   - Run PyInstaller build normally
   - PyInstaller detects architecture and builds accordingly
   - Verify output is Universal2
4. **Validation**:
   - Check binary: `file dist/CuePoint.app/Contents/MacOS/CuePoint`
   - Should show: `Mach-O universal binary with 2 architectures: [x86_64:arm64]`
   - Verify frameworks: Check each framework is Universal2
   - Test on both architectures

**Architecture Validation Script**:
```python
#!/usr/bin/env python3
"""Validate architecture support"""

import subprocess
import sys
from pathlib import Path

def check_binary_architecture(binary_path):
    """Check binary architecture"""
    result = subprocess.run(
        ['file', str(binary_path)],
        capture_output=True,
        text=True
    )
    
    if 'universal binary' in result.stdout:
        # Check for both architectures
        if 'x86_64' in result.stdout and 'arm64' in result.stdout:
            return True, "Universal2 (x86_64 + arm64)"
        else:
            return False, f"Universal but missing architectures: {result.stdout}"
    elif 'x86_64' in result.stdout:
        return True, "x86_64 only"
    elif 'arm64' in result.stdout:
        return True, "arm64 only"
    else:
        return False, f"Unknown architecture: {result.stdout}"

def validate_app_architecture(app_path):
    """Validate app bundle architecture"""
    app = Path(app_path)
    errors = []
    
    # Check main executable
    exe = app / 'Contents' / 'MacOS' / 'CuePoint'
    if exe.exists():
        valid, arch = check_binary_architecture(exe)
        if not valid:
            errors.append(f"Main executable: {arch}")
        print(f"Main executable: {arch}")
    
    # Check frameworks
    frameworks = app / 'Contents' / 'Frameworks'
    if frameworks.exists():
        for framework in frameworks.glob('*.framework'):
            framework_exe = framework / 'Versions' / 'Current' / framework.stem
            if framework_exe.exists():
                valid, arch = check_binary_architecture(framework_exe)
                if not valid:
                    errors.append(f"Framework {framework.name}: {arch}")
    
    return len(errors) == 0, errors

if __name__ == '__main__':
    app_path = sys.argv[1] if len(sys.argv) > 1 else 'dist/CuePoint.app'
    valid, errors = validate_app_architecture(app_path)
    
    if valid:
        print("Architecture validation passed")
        sys.exit(0)
    else:
        print("Architecture validation failed:")
        for error in errors:
            print(f"  {error}")
        sys.exit(1)
```

### macOS Version Compatibility Testing

**Version Testing Matrix**:
- **macOS 10.15 (Catalina)**: Minimum supported version
  - Test on Intel hardware
  - Test on Apple Silicon (via Rosetta 2)
  - Verify all features work
  - Verify performance acceptable
- **macOS 11 (Big Sur)**: First Apple Silicon native version
  - Test on Intel hardware
  - Test on Apple Silicon (native)
  - Verify Universal2 works
  - Verify performance optimal
- **macOS 12+ (Monterey, Ventura, Sonoma)**: Latest versions
  - Test on both architectures
  - Verify new features (if used)
  - Verify compatibility maintained
  - Verify performance optimal

**Version Detection Script**:
```python
#!/usr/bin/env python3
"""Detect and validate macOS version"""

import platform
import sys

def get_macos_version():
    """Get macOS version"""
    version_str = platform.mac_ver()[0]
    return version_str

def parse_version(version_str):
    """Parse version string to tuple"""
    parts = version_str.split('.')
    major = int(parts[0]) if len(parts) > 0 else 0
    minor = int(parts[1]) if len(parts) > 1 else 0
    patch = int(parts[2]) if len(parts) > 2 else 0
    return (major, minor, patch)

def check_minimum_version(minimum='10.15'):
    """Check if current macOS version meets minimum"""
    current = parse_version(get_macos_version())
    minimum_ver = parse_version(minimum)
    
    if current[0] > minimum_ver[0]:
        return True
    elif current[0] == minimum_ver[0]:
        if current[1] > minimum_ver[1]:
            return True
        elif current[1] == minimum_ver[1]:
            return current[2] >= minimum_ver[2]
    return False

if __name__ == '__main__':
    version = get_macos_version()
    print(f"macOS version: {version}")
    
    if check_minimum_version('10.15'):
        print("Version check passed (>= 10.15)")
        sys.exit(0)
    else:
        print("Version check failed (< 10.15)")
        sys.exit(1)
```

### System Requirements Validation

**Runtime Requirements Check**:
```python
#!/usr/bin/env python3
"""Check system requirements at runtime"""

import platform
import psutil
import shutil
import sys

def check_macos_version():
    """Check macOS version"""
    version = platform.mac_ver()[0]
    major, minor = map(int, version.split('.')[:2])
    
    if major < 10 or (major == 10 and minor < 15):
        return False, f"macOS {version} is below minimum (10.15)"
    return True, f"macOS {version} meets requirements"

def check_memory():
    """Check available memory"""
    mem = psutil.virtual_memory()
    min_memory_gb = 4
    available_gb = mem.total / (1024**3)
    
    if available_gb < min_memory_gb:
        return False, f"Only {available_gb:.1f} GB RAM available (minimum: {min_memory_gb} GB)"
    return True, f"{available_gb:.1f} GB RAM available"

def check_disk_space():
    """Check available disk space"""
    min_space_gb = 0.5
    disk = shutil.disk_usage('/')
    available_gb = disk.free / (1024**3)
    
    if available_gb < min_space_gb:
        return False, f"Only {available_gb:.1f} GB disk space (minimum: {min_space_gb} GB)"
    return True, f"{available_gb:.1f} GB disk space available"

def check_requirements():
    """Check all system requirements"""
    checks = [
        check_macos_version(),
        check_memory(),
        check_disk_space(),
    ]
    
    all_passed = all(passed for passed, _ in checks)
    messages = [msg for _, msg in checks]
    
    return all_passed, messages

if __name__ == '__main__':
    passed, messages = check_requirements()
    
    for msg in messages:
        print(msg)
    
    if passed:
        print("All system requirements met")
        sys.exit(0)
    else:
        print("System requirements not met")
        sys.exit(1)
```

### Architecture Performance Considerations

**Performance Optimization**:
- **Native Execution**: Always prefer native architecture
  - Intel Mac: Use x86_64 binary
  - Apple Silicon Mac: Use arm64 binary
  - Universal2: System selects appropriate architecture
- **Rosetta 2 Performance**: 
  - x86_64 on Apple Silicon: ~80% native performance
  - Acceptable for most apps
  - Not ideal for performance-critical apps
- **Universal2 Benefits**:
  - Best performance on both architectures
  - Single distribution
  - Future-proof
- **Performance Testing**:
  - Test startup time on both architectures
  - Test core functionality performance
  - Test memory usage
  - Test CPU usage

### Version-Specific Feature Handling

**Feature Detection Pattern**:
```python
import platform

def get_macos_version_tuple():
    """Get macOS version as tuple"""
    version_str = platform.mac_ver()[0]
    parts = version_str.split('.')
    major = int(parts[0]) if len(parts) > 0 else 0
    minor = int(parts[1]) if len(parts) > 1 else 0
    return (major, minor)

def supports_dark_mode():
    """Check if macOS version supports dark mode"""
    version = get_macos_version_tuple()
    # Dark mode introduced in macOS 10.14
    return version >= (10, 14)

def supports_notarization():
    """Check if macOS version supports notarization"""
    version = get_macos_version_tuple()
    # Notarization required starting macOS 10.15
    return version >= (10, 15)

# Usage in app
if supports_dark_mode():
    # Enable dark mode features
    pass
```

### Compatibility Testing Procedures

**Automated Compatibility Testing**:
- **Test Matrix**: All macOS versions × All architectures
- **Test Scenarios**: Core functionality on each combination
- **Test Automation**: Automated where possible
- **Manual Testing**: Manual on physical hardware for critical paths
- **Test Reporting**: Comprehensive compatibility matrix

**Compatibility Test Script**:
```python
#!/usr/bin/env python3
"""Compatibility test suite"""

import platform
import subprocess
import sys

def test_installation():
    """Test app installation"""
    # Simulate installation
    # Verify app bundle structure
    # Verify permissions
    pass

def test_launch():
    """Test app launch"""
    # Launch app
    # Verify launches successfully
    # Verify no errors
    pass

def test_functionality():
    """Test core functionality"""
    # Test main features
    # Verify all features work
    # Verify no crashes
    pass

def run_compatibility_tests():
    """Run all compatibility tests"""
    version = platform.mac_ver()[0]
    arch = platform.machine()
    
    print(f"Testing on macOS {version} ({arch})")
    
    tests = [
        ("Installation", test_installation),
        ("Launch", test_launch),
        ("Functionality", test_functionality),
    ]
    
    results = []
    for name, test_func in tests:
        try:
            test_func()
            results.append((name, True))
            print(f"  ✓ {name}")
        except Exception as e:
            results.append((name, False))
            print(f"  ✗ {name}: {e}")
    
    return all(passed for _, passed in results)

if __name__ == '__main__':
    if run_compatibility_tests():
        print("All compatibility tests passed")
        sys.exit(0)
    else:
        print("Some compatibility tests failed")
        sys.exit(1)
```

## References

- Main document: `../03_macOS_Packaging_Signing_Notarization.md`
- Related: Step 3.2 (Build Output), Step 3.7 (Update Compatibility)
- Apple Universal Binary Guide: https://developer.apple.com/documentation/apple-silicon/building-a-universal-macos-binary
- Apple Architecture Transition Guide: https://developer.apple.com/documentation/apple-silicon
