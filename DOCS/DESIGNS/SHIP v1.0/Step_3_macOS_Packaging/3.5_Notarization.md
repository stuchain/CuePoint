# Implementation Step 3.5: Notarization Workflow

## Implementation Overview
**What We're Building**: A comprehensive notarization system that submits CuePoint artifacts to Apple's notarization service, waits for approval, staples the notarization ticket to the DMG, and validates the notarization status. This ensures the app passes Apple's automated malware scanning and receives Apple's approval stamp, enabling seamless user installation without Gatekeeper warnings.

## Implementation Tasks

### Task 3.5.1: Define Notarization Architecture

**What to Build**
- Notarization process architecture
- Notarization service integration
- Notarization workflow design
- Notarization automation framework
- Notarization error handling

**Implementation Details**

**3.5.1.1 Notarization Process Architecture**
- **Process Flow**:
  1. **Pre-Notarization Validation**: Verify app is ready for notarization
  2. **Credential Configuration**: Configure notarytool credentials
  3. **Submission**: Submit DMG to Apple notarization service
  4. **Monitoring**: Wait for notarization approval
  5. **Stapling**: Staple notarization ticket to DMG
  6. **Validation**: Verify notarization and stapling
  7. **Verification**: Final Gatekeeper assessment
- **Notarization Target**: DMG file (preferred) or app bundle
  - **DMG Preferred**: Notarize DMG, ticket applies to entire distribution
  - **App Bundle Alternative**: Can notarize app bundle directly
  - **Recommendation**: Notarize DMG for cleaner workflow
- **Notarization Timing**: After signing, before release
- **Notarization Duration**: Typically 5-30 minutes
- **Notarization Automation**: Fully automated in CI/CD

**3.5.1.2 Notarization Service Integration**
- **Service**: Apple Notarization Service (notarytool)
- **Authentication**: App Store Connect API key
- **Tool**: `xcrun notarytool` (Xcode command line tools)
- **API**: REST API (via notarytool)
- **Rate Limits**: Reasonable limits for normal usage
- **Availability**: 24/7 (with occasional maintenance)
- **Response Time**: 5-30 minutes typically
- **Status Tracking**: Submission ID for tracking

**3.5.1.3 Notarization Workflow Design**
- **Workflow Steps**:
  1. Validate app/DMG is signed
  2. Configure notarytool credentials
  3. Submit for notarization
  4. Poll for status (or use --wait)
  5. Check approval status
  6. Staple ticket (if approved)
  7. Validate stapling
  8. Final verification
- **Error Handling**: Comprehensive error handling at each step
- **Retry Logic**: Retry transient failures
- **Timeout Handling**: Handle long-running notarization
- **Status Reporting**: Clear status updates

**3.5.1.4 Notarization Automation Framework**
- **Automation Level**: Fully automated
- **Trigger**: Automatic after DMG creation (on release builds)
- **Manual Override**: Workflow dispatch for testing
- **Error Handling**: Fail-fast with clear errors
- **Logging**: Comprehensive notarization logs
- **Verification**: Automatic verification after notarization
- **Integration**: Seamless CI/CD integration

### Task 3.5.2: Implement Notarization Credential Management

**What to Build**
- App Store Connect API key setup
- Credential storage and security
- Credential configuration automation
- Credential validation
- Credential rotation procedures

**Implementation Details**

**3.5.2.1 App Store Connect API Key Setup**
- **Key Components**:
  - **Issuer ID**: UUID format (e.g., `12345678-1234-1234-1234-123456789abc`)
  - **Key ID**: 10-character alphanumeric (e.g., `ABC123DEF4`)
  - **Private Key**: .p8 file (PEM format)
- **Key Generation**:
  1. Log in to App Store Connect
  2. Navigate to Users and Access → Keys
  3. Click "+" to create new key
  4. Select "App Manager" or "Admin" role
  5. Download .p8 key file (downloadable only once)
  6. Save Issuer ID and Key ID
  7. Store private key securely
- **Key Storage**: GitHub Secrets
  - `APPLE_NOTARYTOOL_ISSUER_ID`: Issuer ID
  - `APPLE_NOTARYTOOL_KEY_ID`: Key ID
  - `APPLE_NOTARYTOOL_KEY`: Private key content (PEM format)
  - `APPLE_TEAM_ID`: Team ID (for notarization)
- **Key Security**:
  - Never commit to repository
  - Store only in GitHub Secrets
  - Rotate regularly
  - Monitor for compromise
  - Limit access to release workflows

**3.5.2.2 Credential Configuration**
- **Configuration Method**: notarytool store-credentials
- **Configuration Command**:
  ```bash
  xcrun notarytool store-credentials \
    --apple-id "$APPLE_NOTARYTOOL_ISSUER_ID" \
    --team-id "$APPLE_TEAM_ID" \
    --key-id "$APPLE_NOTARYTOOL_KEY_ID" \
    --key "$APPLE_NOTARYTOOL_KEY" \
    notarytool-profile
  ```
- **Profile Name**: `notarytool-profile` (reusable)
- **Storage Location**: macOS keychain (temporary for CI)
- **Configuration Timing**: Before notarization submission
- **Configuration Validation**: Test credentials with dry-run

**3.5.2.3 Credential Validation**
- **Validation Checks**:
  - All credentials present
  - Credentials format correct
  - Credentials valid (test submission)
  - Keychain access works
- **Validation Command**:
  ```bash
  xcrun notarytool history --keychain-profile notarytool-profile
  ```
- **Validation Script**: `scripts/validate_notarization_credentials.py`
- **Validation Timing**: Before notarization, after configuration

**3.5.2.4 Credential Rotation**
- **Rotation Schedule**: Every 90 days (recommended)
- **Rotation Process**:
  1. Generate new API key
  2. Test new key in staging
  3. Update GitHub Secrets
  4. Verify notarization works
  5. Archive old key (30 days)
  6. Delete old key
- **Rotation Automation**: Manual process with documentation
- **Rotation Validation**: Test notarization with new key

### Task 3.5.3: Implement Notarization Submission

**What to Build**
- Notarization submission procedure
- Submission validation
- Submission monitoring
- Status polling
- Submission error handling

**Implementation Details**

**3.5.3.1 Notarization Submission Procedure**
- **Submission Command**:
  ```bash
  xcrun notarytool submit "$DMG_PATH" \
    --keychain-profile notarytool-profile \
    --wait
  ```
- **Submission Options**:
  - `submit "$DMG_PATH"`: File to notarize
  - `--keychain-profile`: Credential profile name
  - `--wait`: Wait for completion (blocks until done)
  - `--timeout`: Timeout in seconds (optional)
- **Submission Target**: DMG file (preferred) or app bundle
- **Submission Format**: Automatic (notarytool handles format)
- **Submission Size**: No practical limit (DMG typically < 200 MB)

**3.5.3.2 Pre-Submission Validation**
- **Validation Checks**:
  - File exists and is readable
  - File is signed (required for notarization)
  - Hardened runtime enabled (required)
  - Timestamp present (required)
  - File size reasonable
  - File format correct
- **Validation Script**: `scripts/validate_pre_notarization.py`
- **Validation Timing**: Before submission
- **Failure Handling**: Fail before submission if validation fails

**3.5.3.3 Submission Monitoring**
- **Monitoring Methods**:
  - **--wait Flag**: Blocks until completion (simplest)
  - **Polling**: Submit without --wait, poll status
  - **Webhook**: Notifications (if available)
- **Status Updates**: Regular status messages
- **Progress Reporting**: Show submission progress
- **Timeout Handling**: Handle long-running submissions

**3.5.3.4 Status Polling (Alternative to --wait)**
- **Submission Without Wait**:
  ```bash
  SUBMISSION_ID=$(xcrun notarytool submit "$DMG_PATH" \
    --keychain-profile notarytool-profile)
  ```
- **Status Check**:
  ```bash
  xcrun notarytool log "$SUBMISSION_ID" \
    --keychain-profile notarytool-profile
  ```
- **Polling Loop**: Check status every 30-60 seconds
- **Completion Detection**: Status changes to "Accepted" or "Invalid"
- **Timeout**: Maximum wait time (e.g., 1 hour)

**3.5.3.5 Submission Error Handling**
- **Error Types**:
  - **Network Errors**: Retry submission
  - **Authentication Errors**: Check credentials
  - **Format Errors**: Verify file format
  - **Signing Errors**: Verify signing
  - **Timeout Errors**: Increase timeout or retry
- **Error Recovery**:
  - Retry transient errors
  - Fix and resubmit for permanent errors
  - Log errors for analysis
  - Notify on failure

### Task 3.5.4: Implement Notarization Stapling

**What to Build**
- Stapling procedure
- Stapling validation
- Stapling error handling
- Stapling automation
- Stapling verification

**Implementation Details**

**3.5.4.1 Stapling Procedure**
- **Stapling Command**:
  ```bash
  xcrun stapler staple "$DMG_PATH"
  ```
- **Stapling Target**: DMG file (or app bundle)
- **Stapling Timing**: Immediately after notarization approval
- **Stapling Requirement**: Required for offline verification
- **Stapling Result**: Notarization ticket embedded in file
- **Stapling Validation**: Verify stapling succeeded

**3.5.4.2 Stapling Validation**
- **Validation Command**:
  ```bash
  xcrun stapler validate "$DMG_PATH"
  ```
- **Validation Checks**:
  - Stapling succeeded
  - Ticket present and valid
  - Ticket matches file
  - Ticket not expired
- **Validation Output**: Success or failure message
- **Validation Timing**: After stapling, before release

**3.5.4.3 Stapling Error Handling**
- **Error Types**:
  - **Not Approved**: Notarization not yet approved
  - **Ticket Missing**: Ticket not available
  - **Stapling Failed**: Stapling command failed
  - **Validation Failed**: Ticket invalid
- **Error Recovery**:
  - Wait for approval if not approved
  - Retry stapling if failed
  - Check notarization status
  - Verify file is correct

**3.5.4.4 Stapling Automation**
- **Automation**: Automatic after notarization approval
- **Script**: `scripts/notarize_macos.sh` (includes stapling)
- **Integration**: Part of notarization workflow
- **Error Handling**: Fail if stapling fails
- **Verification**: Automatic validation after stapling

**3.5.4.5 Stapling Verification**
- **Verification Steps**:
  1. Check stapling succeeded
  2. Validate ticket present
  3. Verify ticket validity
  4. Test Gatekeeper assessment
- **Verification Commands**:
  - `xcrun stapler validate`
  - `spctl -a -vv`
  - `codesign -dvv` (check for ticket)
- **Verification Script**: `scripts/validate_notarization.py`

### Task 3.5.5: Implement Notarization Validation

**What to Build**
- Comprehensive validation procedures
- Validation scripts
- Validation automation
- Validation reporting
- Failure diagnostics

**Implementation Details**

**3.5.5.1 Notarization Status Validation**
- **Status Check**:
  ```bash
  xcrun notarytool log "$SUBMISSION_ID" \
    --keychain-profile notarytool-profile
  ```
- **Status Values**:
  - **In Progress**: Still processing
  - **Accepted**: Approved, ready for stapling
  - **Invalid**: Rejected, check log for reasons
  - **Error**: Submission error, retry
- **Status Validation**: Verify status is "Accepted"
- **Status Timing**: After submission, before stapling

**3.5.5.2 Notarization Log Analysis**
- **Log Retrieval**:
  ```bash
  xcrun notarytool log "$SUBMISSION_ID" \
    --keychain-profile notarytool-profile
  ```
- **Log Content**:
  - Submission details
  - Processing status
  - Issues found (if any)
  - Approval/rejection reason
- **Log Analysis**: Parse log for issues
- **Log Storage**: Save logs for troubleshooting
- **Log Usage**: Debug notarization failures

**3.5.5.3 Stapling Validation**
- **Validation Command**:
  ```bash
  xcrun stapler validate "$DMG_PATH"
  ```
- **Validation Checks**:
  - Stapling succeeded
  - Ticket present
  - Ticket valid
  - Ticket matches file
- **Validation Output**: Success or detailed error
- **Validation Timing**: After stapling

**3.5.5.4 Gatekeeper Validation**
- **Validation Command**:
  ```bash
  spctl -a -vv "$DMG_PATH"
  ```
- **Validation Checks**:
  - Gatekeeper accepts DMG
  - Assessment source correct
  - No security warnings
  - Notarization recognized
- **Validation Output**: Acceptance or rejection
- **Validation Timing**: After stapling, final verification

**3.5.5.5 Comprehensive Validation**
- **Validation Script**: `scripts/validate_notarization.py`
- **Validation Steps**:
  1. Check notarization status
  2. Verify stapling
  3. Validate ticket
  4. Test Gatekeeper
  5. Generate report
- **Validation Output**: Comprehensive validation report
- **Validation Integration**: Automated in CI/CD

### Task 3.5.6: Implement Notarization Error Handling

**What to Build**
- Error detection and classification
- Error recovery procedures
- Error reporting and logging
- Error prevention measures
- Troubleshooting documentation

**Implementation Details**

**3.5.6.1 Notarization Failure Modes**
- **Failure Types**:
  - **Rejection**: Apple rejected (malware, policy violation)
  - **Timeout**: Submission timed out
  - **Authentication Error**: Credential issues
  - **Format Error**: File format issues
  - **Signing Error**: Signing issues detected
  - **Network Error**: Connection problems
- **Failure Detection**:
  - Check submission status
  - Parse error messages
  - Review notarization log
  - Verify file state
- **Failure Classification**:
  - **Critical**: Blocks release, must fix
  - **Transient**: Retry may succeed
  - **Configuration**: Credential or setup issue

**3.5.6.2 Common Notarization Issues**
- **Unsigned Code**:
  - **Symptom**: "unsigned code" error
  - **Cause**: Missing signatures on nested items
  - **Solution**: Sign all nested items before notarization
  - **Prevention**: Comprehensive signing verification
- **Hardened Runtime Missing**:
  - **Symptom**: "hardened runtime" error
  - **Cause**: Hardened runtime not enabled
  - **Solution**: Enable hardened runtime in signing
  - **Prevention**: Verify hardened runtime before submission
- **Invalid Entitlements**:
  - **Symptom**: "invalid entitlements" error
  - **Cause**: Disallowed entitlements
  - **Solution**: Remove or fix entitlements
  - **Prevention**: Minimal entitlements, review before submission
- **Bundle Structure Issues**:
  - **Symptom**: "invalid bundle" error
  - **Cause**: Incorrect bundle structure
  - **Solution**: Fix bundle structure
  - **Prevention**: Validate bundle structure before submission

**3.5.6.3 Error Recovery Procedures**
- **Rejection Recovery**:
  1. Retrieve notarization log
  2. Analyze rejection reason
  3. Fix identified issues
  4. Re-sign if needed
  5. Resubmit for notarization
  6. Monitor approval
- **Timeout Recovery**:
  1. Check submission status
  2. Increase timeout if needed
  3. Retry submission
  4. Monitor status
- **Authentication Recovery**:
  1. Verify credentials
  2. Reconfigure notarytool
  3. Test credentials
  4. Retry submission

**3.5.6.4 Error Reporting and Logging**
- **Logging Requirements**:
  - All notarization commands logged
  - All errors logged with context
  - Submission IDs logged
  - Status updates logged
  - Notarization logs saved
- **Error Messages**:
  - Clear and actionable
  - Include error context
  - Suggest solutions
  - Reference documentation
- **Error Reporting**:
  - Console output
  - Build logs
  - Error artifacts
  - Notification on failure

**3.5.6.5 Troubleshooting Documentation**
- **Troubleshooting Guide**: `DOCS/TROUBLESHOOTING/Notarization_Issues.md`
- **Common Issues**:
  - Notarization rejected
  - Stapling failed
  - Timeout issues
  - Authentication errors
- **Solutions**: Step-by-step solutions
- **Diagnostic Commands**: Commands to diagnose issues
- **Support**: Contact information

### Task 3.5.7: Implement CI/CD Integration

**What to Build**
- GitHub Actions workflow integration
- Notarization automation in CI
- Credential configuration in CI
- Status monitoring in CI
- Error handling in CI

**Implementation Details**

**3.5.7.1 Workflow Integration**
- **Workflow File**: `.github/workflows/build-macos.yml`
- **Notarization Steps**:
  1. Configure notarytool credentials
  2. Submit DMG for notarization
  3. Wait for approval (--wait flag)
  4. Staple notarization ticket
  5. Validate stapling
  6. Final verification
- **Conditional Execution**: Only on version tags
- **Error Handling**: Fail workflow on notarization failure
- **Artifact Upload**: Upload notarized DMG

**3.5.7.2 Credential Configuration in CI**
- **Configuration Step**: Before notarization
- **Credential Source**: GitHub Secrets
- **Configuration Script**: Inline in workflow or script
- **Environment Variables**:
  - `APPLE_NOTARYTOOL_ISSUER_ID`
  - `APPLE_TEAM_ID`
  - `APPLE_NOTARYTOOL_KEY_ID`
  - `APPLE_NOTARYTOOL_KEY`
- **Keychain Profile**: `notarytool-profile`

**3.5.7.3 Notarization Automation in CI**
- **Notarization Step**: After DMG creation
- **Notarization Script**: `scripts/notarize_macos.sh`
- **Submission**: Automatic with --wait flag
- **Monitoring**: Automatic (--wait blocks until done)
- **Stapling**: Automatic after approval
- **Verification**: Automatic after stapling

**3.5.7.4 Status Monitoring in CI**
- **Monitoring Method**: --wait flag (blocks until completion)
- **Alternative**: Polling with status checks
- **Status Updates**: Logged to build output
- **Timeout**: Maximum wait time (e.g., 1 hour)
- **Failure Handling**: Fail workflow on timeout or rejection

**3.5.7.5 Error Handling in CI**
- **Error Detection**: Check command exit codes
- **Error Reporting**: Clear error messages
- **Error Notification**: Notify on failure
- **Error Artifacts**: Save notarization logs
- **Retry Logic**: Retry transient errors
- **Failure Recovery**: Manual intervention procedures

### Task 3.5.8: Implement Notarization Best Practices

**What to Build**
- Notarization best practices documentation
- Notarization checklist
- Notarization optimization
- Notarization security
- Notarization monitoring

**Implementation Details**

**3.5.8.1 Notarization Best Practices**
- **Pre-Notarization**:
  - Sign all code properly
  - Enable hardened runtime
  - Add timestamps
  - Minimize entitlements
  - Validate bundle structure
- **Notarization**:
  - Notarize DMG (not just app)
  - Use --wait for automation
  - Monitor submission status
  - Save submission logs
- **Post-Notarization**:
  - Staple immediately after approval
  - Validate stapling
  - Test Gatekeeper
  - Verify final state

**3.5.8.2 Notarization Checklist**
- **Pre-Submission**:
  - [ ] App/DMG signed
  - [ ] Hardened runtime enabled
  - [ ] Timestamps present
  - [ ] Entitlements minimal
  - [ ] Bundle structure correct
- **Submission**:
  - [ ] Credentials configured
  - [ ] File submitted
  - [ ] Submission ID recorded
  - [ ] Status monitored
- **Post-Approval**:
  - [ ] Ticket stapled
  - [ ] Stapling validated
  - [ ] Gatekeeper tested
  - [ ] Final verification complete

**3.5.8.3 Notarization Optimization**
- **Submission Optimization**:
  - Submit DMG (not app) for efficiency
  - Use --wait for simplicity
  - Monitor status for early detection
- **Time Optimization**:
  - Submit early in build process
  - Parallel processing where possible
  - Optimize DMG size
- **Retry Optimization**:
  - Retry transient errors
  - Exponential backoff
  - Maximum retry limit

**3.5.8.4 Notarization Security**
- **Credential Security**: Secure storage and handling
- **Submission Security**: Secure transmission
- **Ticket Security**: Validate ticket authenticity
- **Audit Logging**: Log all notarization operations
- **Access Control**: Limit who can trigger notarization

**3.5.8.5 Notarization Monitoring**
- **Success Rate**: Track notarization success rate
- **Approval Time**: Monitor approval times
- **Failure Rate**: Track failure reasons
- **Trends**: Monitor trends over time
- **Alerts**: Alert on failures or delays

## Implementation Checklist

### Notarization Architecture
- [ ] Define notarization process
- [ ] Define service integration
- [ ] Create workflow design
- [ ] Create automation framework

### Credential Management
- [ ] Set up API key
- [ ] Implement credential storage
- [ ] Create credential configuration
- [ ] Create credential validation
- [ ] Document rotation procedures

### Submission
- [ ] Implement submission procedure
- [ ] Create submission validation
- [ ] Implement monitoring
- [ ] Create status polling
- [ ] Implement error handling

### Stapling
- [ ] Implement stapling procedure
- [ ] Create stapling validation
- [ ] Implement error handling
- [ ] Automate stapling
- [ ] Create verification

### Validation
- [ ] Create validation procedures
- [ ] Create validation scripts
- [ ] Automate validation
- [ ] Create reporting
- [ ] Create diagnostics

### Error Handling
- [ ] Implement error detection
- [ ] Create recovery procedures
- [ ] Implement reporting
- [ ] Create prevention measures
- [ ] Create troubleshooting docs

### CI/CD Integration
- [ ] Integrate with GitHub Actions
- [ ] Automate credential config
- [ ] Automate submission
- [ ] Automate monitoring
- [ ] Implement error handling

### Best Practices
- [ ] Document best practices
- [ ] Create checklist
- [ ] Optimize process
- [ ] Harden security
- [ ] Implement monitoring

## Files to Create/Modify

### New Files
1. `DOCS/DESIGNS/SHIP v1.0/Step_3_macOS_Packaging/3.5_Notarization.md` - This document
2. `scripts/validate_pre_notarization.py` - Pre-notarization validation
3. `scripts/validate_notarization_credentials.py` - Credential validation
4. `DOCS/TROUBLESHOOTING/Notarization_Issues.md` - Troubleshooting guide

### Files to Modify
1. `scripts/notarize_macos.sh` - Enhanced notarization script
2. `scripts/validate_notarization.py` - Enhanced validation
3. `.github/workflows/build-macos.yml` - Notarization integration
4. `DOCS/DESIGNS/SHIP v1.0/Step_3_macOS_Packaging/README.md` - Add reference

## Implementation Dependencies

### Prerequisites
- Step 3.4: Signing (requires signed app)
- Step 3.2: Build Output (DMG creation)
- App Store Connect API key
- Apple Developer account

### Enables
- Step 5: Auto-Update (requires notarized app)
- User distribution (enables Gatekeeper trust)

## Success Criteria

### Notarization
- ✅ DMG successfully notarized
- ✅ Notarization approved by Apple
- ✅ Ticket stapled to DMG
- ✅ Stapling validated
- ✅ Gatekeeper assessment passes

### Automation
- ✅ Fully automated notarization
- ✅ CI/CD integration complete
- ✅ Error handling robust
- ✅ Documentation complete

## Next Implementation Steps

After completing Step 3.5:
1. **Step 3.6**: Runtime Requirements (validates architecture)
2. **Step 3.7**: Update Compatibility (ensures update system works)

## Detailed Implementation Guidance

### Notarization Script Example

**Enhanced Notarization Script**:
```bash
#!/bin/bash
# Enhanced macOS notarization script

set -e

FILE_PATH="$1"
PROFILE="notarytool-profile"

# Validate inputs
if [ -z "$FILE_PATH" ]; then
    echo "Usage: $0 <path-to-dmg-or-app>"
    exit 1
fi

# Validate credentials
if [ -z "$APPLE_NOTARYTOOL_ISSUER_ID" ] || \
   [ -z "$APPLE_TEAM_ID" ] || \
   [ -z "$APPLE_NOTARYTOOL_KEY_ID" ] || \
   [ -z "$APPLE_NOTARYTOOL_KEY" ]; then
    echo "Error: Notarization credentials not set"
    exit 1
fi

# Configure credentials
echo "Configuring notarytool credentials..."
xcrun notarytool store-credentials \
    --apple-id "$APPLE_NOTARYTOOL_ISSUER_ID" \
    --team-id "$APPLE_TEAM_ID" \
    --key-id "$APPLE_NOTARYTOOL_KEY_ID" \
    --key "$APPLE_NOTARYTOOL_KEY" \
    "$PROFILE"

# Submit for notarization
echo "Submitting for notarization..."
SUBMISSION_ID=$(xcrun notarytool submit "$FILE_PATH" \
    --keychain-profile "$PROFILE" \
    --wait \
    --timeout 3600)

echo "Notarization approved: $SUBMISSION_ID"

# Staple (for DMG)
if [[ "$FILE_PATH" == *.dmg ]]; then
    echo "Stapling notarization ticket..."
    xcrun stapler staple "$FILE_PATH"
    
    # Validate stapling
    echo "Validating stapling..."
    xcrun stapler validate "$FILE_PATH"
    
    # Final Gatekeeper check
    echo "Final Gatekeeper assessment..."
    spctl -a -vv "$FILE_PATH"
fi

echo "Notarization complete"
```

## Advanced Notarization Implementation

### Notarization Log Analysis

**Comprehensive Log Analysis**:
```python
#!/usr/bin/env python3
"""Analyze notarization logs for issues"""

import json
import subprocess
import sys

def get_notarization_log(submission_id, profile='notarytool-profile'):
    """Get notarization log"""
    result = subprocess.run(
        ['xcrun', 'notarytool', 'log', submission_id,
         '--keychain-profile', profile],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        return None, result.stderr
    
    return result.stdout, None

def analyze_notarization_log(log_text):
    """Analyze notarization log for issues"""
    issues = []
    warnings = []
    
    # Common issue patterns
    if 'unsigned code' in log_text.lower():
        issues.append("Unsigned code detected - sign all nested items")
    
    if 'hardened runtime' in log_text.lower():
        issues.append("Hardened runtime issue - enable hardened runtime")
    
    if 'entitlements' in log_text.lower():
        issues.append("Entitlements issue - review entitlements")
    
    if 'invalid bundle' in log_text.lower():
        issues.append("Invalid bundle structure - check bundle structure")
    
    if 'malware' in log_text.lower():
        warnings.append("Malware detection - false positive possible")
    
    return issues, warnings

def troubleshoot_notarization(submission_id):
    """Troubleshoot notarization issues"""
    log, error = get_notarization_log(submission_id)
    
    if error:
        print(f"Error retrieving log: {error}")
        return
    
    issues, warnings = analyze_notarization_log(log)
    
    if issues:
        print("Notarization issues found:")
        for issue in issues:
            print(f"  ✗ {issue}")
    
    if warnings:
        print("Notarization warnings:")
        for warning in warnings:
            print(f"  ⚠ {warning}")
    
    if not issues and not warnings:
        print("No issues found in notarization log")
```

### Notarization Status Monitoring

**Status Monitoring Script**:
```python
#!/usr/bin/env python3
"""Monitor notarization status"""

import subprocess
import time
import sys

def get_notarization_status(submission_id, profile='notarytool-profile'):
    """Get notarization status"""
    result = subprocess.run(
        ['xcrun', 'notarytool', 'log', submission_id,
         '--keychain-profile', profile],
        capture_output=True,
        text=True
    )
    
    if result.returncode != 0:
        return None, result.stderr
    
    # Parse status from log
    # Status is typically in the log output
    if 'status: Accepted' in result.stdout:
        return 'Accepted', None
    elif 'status: Invalid' in result.stdout:
        return 'Invalid', result.stdout
    elif 'status: In Progress' in result.stdout:
        return 'In Progress', None
    else:
        return 'Unknown', result.stdout

def monitor_notarization(submission_id, timeout=3600, interval=60):
    """Monitor notarization until complete"""
    start_time = time.time()
    
    while time.time() - start_time < timeout:
        status, details = get_notarization_status(submission_id)
        
        if status == 'Accepted':
            print("Notarization approved!")
            return True, None
        
        if status == 'Invalid':
            print("Notarization rejected!")
            return False, details
        
        if status == 'In Progress':
            elapsed = int(time.time() - start_time)
            print(f"Notarization in progress... ({elapsed}s elapsed)")
        
        time.sleep(interval)
    
    return False, "Notarization timeout"

if __name__ == '__main__':
    submission_id = sys.argv[1] if len(sys.argv) > 1 else None
    if not submission_id:
        print("Usage: monitor_notarization.py <submission-id>")
        sys.exit(1)
    
    success, error = monitor_notarization(submission_id)
    
    if success:
        print("Notarization monitoring complete - approved")
        sys.exit(0)
    else:
        print(f"Notarization monitoring complete - failed: {error}")
        sys.exit(1)
```

### Notarization Troubleshooting Procedures

**Complete Troubleshooting Workflow**:
1. **Retrieve Notarization Log**:
   - Get submission ID from notarization output
   - Retrieve log: `xcrun notarytool log <submission-id>`
   - Save log for analysis
2. **Analyze Log**:
   - Read log carefully
   - Identify specific errors
   - Look for error codes
   - Check for common issues
3. **Identify Root Cause**:
   - Match errors to known issues
   - Review signing status
   - Check bundle structure
   - Verify entitlements
4. **Apply Fix**:
   - Fix identified issues
   - Re-sign if needed
   - Re-submit for notarization
5. **Verify Fix**:
   - Check new submission
   - Verify approval
   - Test final DMG

**Common Notarization Errors and Solutions**:

**Error: "The signature is invalid"**
- **Cause**: Signing issues, wrong certificate, incomplete signing
- **Solution**: Re-sign app completely, verify all signatures
- **Prevention**: Comprehensive signing verification

**Error: "The executable does not have the hardened runtime enabled"**
- **Cause**: Hardened runtime not enabled during signing
- **Solution**: Re-sign with `--options runtime`
- **Prevention**: Always use `--options runtime` when signing

**Error: "The executable requests an invalid entitlement"**
- **Cause**: Disallowed entitlements in entitlements.plist
- **Solution**: Remove or fix entitlements
- **Prevention**: Minimal entitlements, review before submission

**Error: "The executable contains unsigned code"**
- **Cause**: Nested items not signed
- **Solution**: Sign all nested items before app bundle
- **Prevention**: Comprehensive nested item signing

## References

- Main document: `../03_macOS_Packaging_Signing_Notarization.md`
- Related: Step 3.4 (Signing), Step 3.6 (Runtime Requirements)
- Apple Notarization Guide: https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution
- notarytool Manual: `man notarytool`
- stapler Manual: `man stapler`
- Apple Notarization Troubleshooting: https://developer.apple.com/documentation/security/notarizing_macos_software_before_distribution/troubleshooting
