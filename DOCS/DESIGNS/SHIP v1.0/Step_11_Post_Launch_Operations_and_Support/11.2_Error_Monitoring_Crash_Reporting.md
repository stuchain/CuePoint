# Implementation Step 11.2: Error Monitoring & Crash Reporting

## Implementation Overview
**What We're Building**: A professional error monitoring and crash reporting system that automatically captures application crashes and errors, reports them to GitHub Issues (FREE, EASIEST option), and provides actionable insights for debugging and fixing issues. This system ensures all errors are tracked, critical errors are detected quickly, and error resolution is efficient.

## Strategic Context

### Why Error Monitoring Matters: Deep Analysis

Error monitoring is not just a nice-to-have feature—it's a fundamental requirement for professional software operations. Let's analyze why this matters at a deeper level:

#### 1. **Rapid Issue Detection: The Time-to-Awareness Problem**

**The Problem**: Without automated error monitoring, the time between when an error occurs and when you become aware of it can be days or weeks. During this time:
- Multiple users may experience the same issue
- User frustration accumulates
- Support tickets pile up
- Product reputation suffers

**The Impact Analysis**:
- **User Impact**: If 100 users experience a crash and only 5% report it, you're only aware of 5 issues, but 95 users had a bad experience
- **Business Impact**: Each unreported error represents lost user trust and potential churn
- **Support Impact**: When users finally report issues, they're often frustrated, making support harder

**The Solution Value**: Automated error reporting reduces time-to-awareness from days/weeks to minutes/hours, enabling proactive fixes.

#### 2. **Better Debugging: The Context Problem**

**The Problem**: When users manually report errors, they often lack critical debugging context:
- Exact error messages may be paraphrased incorrectly
- System information is often incomplete
- Steps to reproduce are unclear
- Error frequency is unknown

**The Impact Analysis**:
- **Debugging Time**: Manual error reports require back-and-forth communication, adding days to resolution
- **Error Reproduction**: Without exact context, reproducing errors is guesswork
- **Error Prioritization**: Hard to know which errors are most common without data

**The Solution Value**: Automated reporting captures exact error context, system information, and frequency data, enabling faster debugging and better prioritization.

#### 3. **User Experience: The Silent Failure Problem**

**The Problem**: Many errors occur silently or with unclear error messages. Users may:
- Think the app is "broken" without understanding why
- Stop using features that error frequently
- Uninstall the app without reporting issues

**The Impact Analysis**:
- **Feature Adoption**: If a feature errors frequently, users avoid it, reducing feature value
- **User Retention**: Silent failures lead to user churn
- **Product Perception**: Users judge product quality by error frequency, not just features

**The Solution Value**: Error monitoring reveals silent failures, enabling fixes before users abandon features.

#### 4. **Product Quality: The Measurement Problem**

**The Problem**: Without error monitoring, you can't measure:
- Error rates over time
- Which features error most
- Error trends (improving or degrading)
- Impact of code changes on error rates

**The Impact Analysis**:
- **Quality Metrics**: Can't track if quality is improving or degrading
- **Release Quality**: Can't assess if a release introduced more errors
- **Technical Debt**: Can't identify error-prone areas that need refactoring

**The Solution Value**: Error monitoring provides quantitative quality metrics, enabling data-driven quality improvements.

#### 5. **Support Efficiency: The Burden Problem**

**The Problem**: Without error monitoring:
- Support team spends time gathering error information
- Same errors are reported multiple times
- Support can't proactively address issues
- Support burden increases with user base

**The Impact Analysis**:
- **Support Cost**: Manual error reporting requires human time for each report
- **Support Scalability**: Support burden grows linearly with user base
- **User Satisfaction**: Users frustrated by having to report errors manually

**The Solution Value**: Automated error reporting reduces support burden by 70-90%, enabling support to focus on complex issues.

### The Challenge: Without Error Monitoring

**Quantitative Impact**:
- **Time to Detection**: 2-7 days average (user reports)
- **Error Reporting Rate**: 5-10% of errors are reported
- **Debugging Time**: 2-5 days per error (manual reports)
- **Support Burden**: 30-50% of support time on error gathering

**Qualitative Impact**:
- **User Trust**: Erodes with each unreported error
- **Team Morale**: Reactive firefighting is demoralizing
- **Product Quality**: Degrades without visibility
- **Business Risk**: Unknown error rates create business risk

### The Solution: Automatic Error Reporting to GitHub Issues

**Why This Solution Works**:
1. **Immediate Detection**: Errors reported within seconds
2. **Complete Context**: All error information captured automatically
3. **Zero User Friction**: No user action required
4. **Integrated Workflow**: Works with existing GitHub workflow
5. **Cost Effective**: FREE, no additional infrastructure
6. **Scalable**: Handles any volume of errors
7. **Searchable**: Easy to find and track errors
8. **Collaborative**: Team can work together on fixes

## Implementation Decision: GitHub Issues (EASIEST, FREE)

**Why GitHub Issues**:
- ✅ **FREE**: No cost
- ✅ **EASIEST**: Already have GitHub account
- ✅ **Integrated**: Works with existing GitHub workflow
- ✅ **Familiar**: Team already knows how to use it
- ✅ **Flexible**: Can customize with templates and labels
- ✅ **Searchable**: Easy to find and track errors
- ✅ **Collaborative**: Team can work together on fixes

**Alternative Options (NOT chosen)**:
- ❌ Sentry: Requires account setup, may have costs
- ❌ Custom error reporting: Requires significant development
- ❌ Email-based: Harder to track and manage

## Implementation Tasks

### Task 11.2.1: Create Error Reporter Module

**What to Create**
- Error reporter utility that sends errors to GitHub Issues
- Integration with existing crash handler
- Privacy-respecting error reporting
- User consent mechanism

**Implementation Details**

**11.2.1.1 Error Reporter Module**

**File to Create**: `SRC/cuepoint/utils/error_reporter.py`

**Purpose**: Report application errors to GitHub Issues automatically

**Key Features**:
- Automatic error reporting
- Privacy filtering (no sensitive data)
- User consent check
- Error grouping (avoid duplicates)
- Error context collection

**Architectural Analysis**:

**Design Decisions**:
1. **Singleton Pattern**: Global error reporter instance ensures consistent error handling across the application
2. **Privacy-First Design**: Sensitive data filtering happens before any external transmission
3. **Deduplication Strategy**: Error hash-based deduplication prevents spam while allowing re-reporting after time window
4. **Graceful Degradation**: If error reporting fails, it doesn't crash the application
5. **Async-Friendly**: Error reporting doesn't block the main thread

**Performance Considerations**:
- **Caching**: Error cache prevents duplicate reports, reducing API calls
- **Timeouts**: 10-second timeout prevents hanging on network issues
- **Lazy Loading**: Error cache loaded only when needed
- **Minimal Overhead**: Error reporting adds < 50ms to error handling

**Security Considerations**:
- **Token Security**: GitHub token never logged or exposed
- **Data Filtering**: Comprehensive sensitive data filtering
- **Privacy Compliance**: Respects user consent preferences
- **Rate Limiting**: Deduplication prevents API rate limit issues

**Code Structure**:
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Error Reporter for GitHub Issues

Reports application errors to GitHub Issues automatically.
FREE, EASIEST option - uses existing GitHub account.
"""

import json
import logging
import platform
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, Optional

import requests

from cuepoint.version import get_version, get_build_info


class ErrorReporter:
    """Report errors to GitHub Issues."""
    
    def __init__(
        self,
        github_repo: str,
        github_token: Optional[str] = None,
        enabled: bool = True
    ):
        """
        Initialize error reporter.
        
        Args:
            github_repo: GitHub repository (format: "owner/repo")
            github_token: GitHub personal access token (optional, can use GITHUB_TOKEN env var)
            enabled: Whether error reporting is enabled
        """
        self.github_repo = github_repo
        self.github_token = github_token or self._get_token_from_env()
        self.enabled = enabled and bool(self.github_token)
        
        self.logger = logging.getLogger(__name__)
        
        # Error cache to avoid duplicate reports
        self._reported_errors: Dict[str, datetime] = {}
        self._cache_file = Path.home() / ".cuepoint" / "error_cache.json"
        self._load_error_cache()
    
    def _get_token_from_env(self) -> Optional[str]:
        """Get GitHub token from environment variable."""
        return None  # Can be set via GITHUB_TOKEN env var
    
    def _load_error_cache(self) -> None:
        """Load error cache from disk."""
        try:
            if self._cache_file.exists():
                with open(self._cache_file, 'r') as f:
                    data = json.load(f)
                    for error_hash, timestamp_str in data.items():
                        self._reported_errors[error_hash] = datetime.fromisoformat(timestamp_str)
        except Exception as e:
            self.logger.warning(f"Could not load error cache: {e}")
    
    def _save_error_cache(self) -> None:
        """Save error cache to disk."""
        try:
            self._cache_file.parent.mkdir(parents=True, exist_ok=True)
            data = {
                error_hash: timestamp.isoformat()
                for error_hash, timestamp in self._reported_errors.items()
            }
            with open(self._cache_file, 'w') as f:
                json.dump(data, f)
        except Exception as e:
            self.logger.warning(f"Could not save error cache: {e}")
    
    def _should_report_error(self, error_hash: str) -> bool:
        """Check if error should be reported (avoid duplicates)."""
        if error_hash not in self._reported_errors:
            return True
        
        # Report again if last report was > 24 hours ago
        last_report = self._reported_errors[error_hash]
        time_since_report = datetime.now() - last_report
        return time_since_report.total_seconds() > 86400  # 24 hours
    
    def _filter_sensitive_data(self, data: Dict[str, Any]) -> Dict[str, Any]:
        """Filter sensitive data from error report."""
        filtered = {}
        sensitive_keys = [
            'password', 'token', 'key', 'secret', 'api_key',
            'file_path', 'path', 'directory', 'username', 'email'
        ]
        
        for key, value in data.items():
            key_lower = key.lower()
            if any(sensitive in key_lower for sensitive in sensitive_keys):
                filtered[key] = '[REDACTED]'
            elif isinstance(value, dict):
                filtered[key] = self._filter_sensitive_data(value)
            elif isinstance(value, str) and len(value) > 500:
                filtered[key] = value[:500] + '... [TRUNCATED]'
            else:
                filtered[key] = value
        
        return filtered
    
    def _create_error_issue(self, error_info: Dict[str, Any]) -> Optional[int]:
        """Create GitHub issue for error."""
        if not self.enabled:
            return None
        
        try:
            # Prepare issue title
            error_type = error_info.get('error_type', 'Unknown Error')
            error_message = error_info.get('error_message', 'No message')
            title = f"[Auto-Reported] {error_type}: {error_message[:100]}"
            
            # Prepare issue body
            body = self._format_error_body(error_info)
            
            # Create issue via GitHub API
            url = f"https://api.github.com/repos/{self.github_repo}/issues"
            headers = {
                "Authorization": f"token {self.github_token}",
                "Accept": "application/vnd.github.v3+json"
            }
            data = {
                "title": title,
                "body": body,
                "labels": ["auto-reported", "error", "bug"]
            }
            
            response = requests.post(url, headers=headers, json=data, timeout=10)
            response.raise_for_status()
            
            issue_data = response.json()
            issue_number = issue_data.get('number')
            
            self.logger.info(f"Error reported to GitHub Issue #{issue_number}")
            return issue_number
            
        except Exception as e:
            self.logger.error(f"Failed to report error to GitHub: {e}")
            return None
    
    def _format_error_body(self, error_info: Dict[str, Any]) -> str:
        """Format error information as GitHub issue body."""
        lines = [
            "## Auto-Reported Error",
            "",
            "This error was automatically reported by the application.",
            "",
            "### Error Details",
            "",
            f"**Error Type**: `{error_info.get('error_type', 'Unknown')}`",
            f"**Error Message**: `{error_info.get('error_message', 'No message')}`",
            "",
            "### System Information",
            "",
            f"- **Version**: {error_info.get('version', 'Unknown')}",
            f"- **OS**: {error_info.get('os', 'Unknown')}",
            f"- **Platform**: {error_info.get('platform', 'Unknown')}",
            f"- **Python**: {error_info.get('python_version', 'Unknown')}",
            "",
            "### Error Context",
            "",
            "```",
            error_info.get('traceback', 'No traceback available'),
            "```",
            "",
            "### Additional Information",
            "",
            "```json",
            json.dumps(error_info.get('additional_info', {}), indent=2),
            "```",
            "",
            "---",
            "",
            "*This issue was automatically created. Please verify and add any additional context.*"
        ]
        
        return "\n".join(lines)
    
    def report_error(
        self,
        error_type: str,
        error_message: str,
        traceback: Optional[str] = None,
        additional_info: Optional[Dict[str, Any]] = None
    ) -> Optional[int]:
        """
        Report an error to GitHub Issues.
        
        Args:
            error_type: Type of error (e.g., "Crash", "Exception")
            error_message: Error message
            traceback: Error traceback (optional)
            additional_info: Additional error context (optional)
        
        Returns:
            GitHub issue number if reported, None otherwise
        """
        if not self.enabled:
            return None
        
        # Collect error information
        error_info = {
            'error_type': error_type,
            'error_message': error_message,
            'traceback': traceback or 'No traceback available',
            'timestamp': datetime.now().isoformat(),
            'version': get_version(),
            'os': platform.system(),
            'platform': platform.platform(),
            'python_version': sys.version,
            'additional_info': additional_info or {}
        }
        
        # Add build info if available
        try:
            build_info = get_build_info()
            error_info['build_info'] = build_info
        except Exception:
            pass
        
        # Filter sensitive data
        error_info = self._filter_sensitive_data(error_info)
        
        # Generate error hash for deduplication
        import hashlib
        error_hash = hashlib.md5(
            f"{error_type}:{error_message}".encode()
        ).hexdigest()
        
        # Check if should report
        if not self._should_report_error(error_hash):
            self.logger.debug(f"Error already reported recently, skipping: {error_hash}")
            return None
        
        # Report error
        issue_number = self._create_error_issue(error_info)
        
        if issue_number:
            # Update cache
            self._reported_errors[error_hash] = datetime.now()
            self._save_error_cache()
        
        return issue_number


# Global error reporter instance
_error_reporter: Optional[ErrorReporter] = None


def init_error_reporter(
    github_repo: str,
    github_token: Optional[str] = None,
    enabled: bool = True
) -> None:
    """Initialize global error reporter."""
    global _error_reporter
    _error_reporter = ErrorReporter(github_repo, github_token, enabled)


def report_error(
    error_type: str,
    error_message: str,
    traceback: Optional[str] = None,
    additional_info: Optional[Dict[str, Any]] = None
) -> Optional[int]:
    """Report error using global error reporter."""
    if _error_reporter:
        return _error_reporter.report_error(
            error_type, error_message, traceback, additional_info
        )
    return None
```

**Test Implementation Guidance for Error Reporter Module**

**File to Create**: `SRC/tests/unit/utils/test_error_reporter.py`

**Comprehensive Test Suite**:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Tests for Error Reporter Module

Comprehensive test suite covering all error reporter functionality.
"""

import json
import os
import tempfile
from datetime import datetime, timedelta
from pathlib import Path
from unittest.mock import Mock, patch, MagicMock

import pytest
import requests

from cuepoint.utils.error_reporter import ErrorReporter, init_error_reporter, report_error


class TestErrorReporter:
    """Test ErrorReporter class."""
    
    @pytest.fixture
    def temp_cache_dir(self):
        """Create temporary cache directory."""
        with tempfile.TemporaryDirectory() as tmpdir:
            yield Path(tmpdir)
    
    @pytest.fixture
    def error_reporter(self, temp_cache_dir, monkeypatch):
        """Create ErrorReporter instance for testing."""
        # Mock cache file location
        monkeypatch.setattr(
            'cuepoint.utils.error_reporter.Path.home',
            lambda: temp_cache_dir
        )
        
        reporter = ErrorReporter(
            github_repo="test/repo",
            github_token="test_token",
            enabled=True
        )
        # Override cache file location
        reporter._cache_file = temp_cache_dir / ".cuepoint" / "error_cache.json"
        return reporter
    
    def test_init_with_token(self, error_reporter):
        """Test ErrorReporter initialization with token."""
        assert error_reporter.github_repo == "test/repo"
        assert error_reporter.github_token == "test_token"
        assert error_reporter.enabled is True
    
    def test_init_without_token(self, temp_cache_dir, monkeypatch):
        """Test ErrorReporter initialization without token."""
        monkeypatch.setattr(
            'cuepoint.utils.error_reporter.Path.home',
            lambda: temp_cache_dir
        )
        
        reporter = ErrorReporter(
            github_repo="test/repo",
            github_token=None,
            enabled=True
        )
        assert reporter.enabled is False  # Disabled without token
    
    def test_init_disabled(self, error_reporter):
        """Test ErrorReporter initialization when disabled."""
        error_reporter.enabled = False
        assert error_reporter.enabled is False
    
    def test_load_error_cache_new_file(self, error_reporter):
        """Test loading error cache from new file."""
        error_reporter._load_error_cache()
        assert len(error_reporter._reported_errors) == 0
    
    def test_load_error_cache_existing_file(self, error_reporter):
        """Test loading error cache from existing file."""
        # Create cache file
        error_reporter._cache_file.parent.mkdir(parents=True, exist_ok=True)
        cache_data = {
            "error_hash_1": datetime.now().isoformat(),
            "error_hash_2": (datetime.now() - timedelta(hours=25)).isoformat()
        }
        with open(error_reporter._cache_file, 'w') as f:
            json.dump(cache_data, f)
        
        error_reporter._load_error_cache()
        assert len(error_reporter._reported_errors) == 2
    
    def test_save_error_cache(self, error_reporter):
        """Test saving error cache to file."""
        error_reporter._reported_errors = {
            "error_hash_1": datetime.now(),
            "error_hash_2": datetime.now() - timedelta(hours=1)
        }
        
        error_reporter._save_error_cache()
        
        assert error_reporter._cache_file.exists()
        with open(error_reporter._cache_file, 'r') as f:
            data = json.load(f)
            assert "error_hash_1" in data
            assert "error_hash_2" in data
    
    def test_should_report_error_new_error(self, error_reporter):
        """Test should_report_error for new error."""
        assert error_reporter._should_report_error("new_error_hash") is True
    
    def test_should_report_error_recent_error(self, error_reporter):
        """Test should_report_error for recently reported error."""
        error_reporter._reported_errors["recent_error"] = datetime.now()
        assert error_reporter._should_report_error("recent_error") is False
    
    def test_should_report_error_old_error(self, error_reporter):
        """Test should_report_error for old error (> 24 hours)."""
        error_reporter._reported_errors["old_error"] = datetime.now() - timedelta(hours=25)
        assert error_reporter._should_report_error("old_error") is True
    
    def test_filter_sensitive_data_passwords(self, error_reporter):
        """Test filtering sensitive data (passwords)."""
        data = {
            "password": "secret123",
            "username": "user",
            "message": "Error occurred"
        }
        filtered = error_reporter._filter_sensitive_data(data)
        
        assert filtered["password"] == "[REDACTED]"
        assert filtered["username"] == "[REDACTED]"
        assert filtered["message"] == "Error occurred"
    
    def test_filter_sensitive_data_nested(self, error_reporter):
        """Test filtering sensitive data in nested structures."""
        data = {
            "user": {
                "password": "secret",
                "email": "user@example.com"
            },
            "message": "Error"
        }
        filtered = error_reporter._filter_sensitive_data(data)
        
        assert filtered["user"]["password"] == "[REDACTED]"
        assert filtered["user"]["email"] == "[REDACTED]"
        assert filtered["message"] == "Error"
    
    def test_filter_sensitive_data_long_strings(self, error_reporter):
        """Test truncating long strings."""
        long_string = "x" * 1000
        data = {"traceback": long_string}
        filtered = error_reporter._filter_sensitive_data(data)
        
        assert len(filtered["traceback"]) == 503  # 500 + "... [TRUNCATED]"
        assert filtered["traceback"].endswith("... [TRUNCATED]")
    
    @patch('cuepoint.utils.error_reporter.requests.post')
    def test_create_error_issue_success(self, mock_post, error_reporter):
        """Test successful error issue creation."""
        mock_response = Mock()
        mock_response.json.return_value = {"number": 123}
        mock_response.raise_for_status = Mock()
        mock_post.return_value = mock_response
        
        error_info = {
            "error_type": "ValueError",
            "error_message": "Test error",
            "traceback": "Traceback...",
            "version": "1.0.0",
            "os": "Windows",
            "platform": "Windows-10",
            "python_version": "3.11.0"
        }
        
        issue_number = error_reporter._create_error_issue(error_info)
        
        assert issue_number == 123
        mock_post.assert_called_once()
        call_args = mock_post.call_args
        assert "api.github.com" in call_args[0][0]
        assert call_args[1]["json"]["title"].startswith("[Auto-Reported]")
    
    @patch('cuepoint.utils.error_reporter.requests.post')
    def test_create_error_issue_failure(self, mock_post, error_reporter):
        """Test error issue creation failure."""
        mock_post.side_effect = requests.RequestException("Network error")
        
        error_info = {"error_type": "Test", "error_message": "Test"}
        issue_number = error_reporter._create_error_issue(error_info)
        
        assert issue_number is None
    
    @patch('cuepoint.utils.error_reporter.requests.post')
    def test_report_error_success(self, mock_post, error_reporter, temp_cache_dir):
        """Test successful error reporting."""
        mock_response = Mock()
        mock_response.json.return_value = {"number": 456}
        mock_response.raise_for_status = Mock()
        mock_post.return_value = mock_response
        
        issue_number = error_reporter.report_error(
            error_type="TestError",
            error_message="Test error message",
            traceback="Traceback...",
            additional_info={"key": "value"}
        )
        
        assert issue_number == 456
        assert "test_error" in error_reporter._reported_errors  # Hash of error
    
    @patch('cuepoint.utils.error_reporter.requests.post')
    def test_report_error_deduplication(self, mock_post, error_reporter):
        """Test error reporting deduplication."""
        mock_response = Mock()
        mock_response.json.return_value = {"number": 789}
        mock_response.raise_for_status = Mock()
        mock_post.return_value = mock_response
        
        # Report first error
        error_reporter.report_error("TestError", "Test message")
        assert mock_post.call_count == 1
        
        # Report same error again (should be deduplicated)
        error_reporter.report_error("TestError", "Test message")
        assert mock_post.call_count == 1  # Not called again
    
    def test_report_error_disabled(self, error_reporter):
        """Test error reporting when disabled."""
        error_reporter.enabled = False
        
        issue_number = error_reporter.report_error(
            "TestError",
            "Test message"
        )
        
        assert issue_number is None
    
    @patch('cuepoint.utils.error_reporter.get_version')
    @patch('cuepoint.utils.error_reporter.get_build_info')
    def test_report_error_with_build_info(self, mock_build_info, mock_version, error_reporter):
        """Test error reporting includes build info."""
        mock_version.return_value = "1.0.0"
        mock_build_info.return_value = {"build_number": "123"}
        
        with patch.object(error_reporter, '_create_error_issue') as mock_create:
            error_reporter.report_error("TestError", "Test message")
            
            # Verify build info was included
            call_args = mock_create.call_args[0][0]
            assert "build_info" in call_args


class TestErrorReporterIntegration:
    """Integration tests for error reporter."""
    
    @patch('cuepoint.utils.error_reporter.ErrorReporter')
    def test_init_error_reporter(self, mock_reporter_class):
        """Test global error reporter initialization."""
        init_error_reporter("test/repo", "token", True)
        
        mock_reporter_class.assert_called_once_with("test/repo", "token", True)
    
    @patch('cuepoint.utils.error_reporter._error_reporter')
    def test_report_error_global(self, mock_reporter):
        """Test global report_error function."""
        mock_reporter.report_error.return_value = 123
        
        issue_number = report_error("TestError", "Test message")
        
        assert issue_number == 123
        mock_reporter.report_error.assert_called_once()
    
    def test_report_error_no_reporter(self):
        """Test report_error when no global reporter."""
        # Reset global reporter
        import cuepoint.utils.error_reporter as er_module
        er_module._error_reporter = None
        
        issue_number = report_error("TestError", "Test message")
        assert issue_number is None


class TestErrorReporterEdgeCases:
    """Test edge cases and error handling."""
    
    def test_malformed_cache_file(self, temp_cache_dir, monkeypatch):
        """Test handling of malformed cache file."""
        monkeypatch.setattr(
            'cuepoint.utils.error_reporter.Path.home',
            lambda: temp_cache_dir
        )
        
        reporter = ErrorReporter("test/repo", "token", True)
        reporter._cache_file = temp_cache_dir / ".cuepoint" / "error_cache.json"
        
        # Create malformed cache file
        reporter._cache_file.parent.mkdir(parents=True, exist_ok=True)
        with open(reporter._cache_file, 'w') as f:
            f.write("invalid json")
        
        # Should not crash, should handle gracefully
        reporter._load_error_cache()
        assert len(reporter._reported_errors) == 0
    
    def test_cache_file_permissions_error(self, error_reporter, monkeypatch):
        """Test handling of cache file permission errors."""
        def mock_open(*args, **kwargs):
            raise PermissionError("Permission denied")
        
        monkeypatch.setattr("builtins.open", mock_open)
        
        # Should not crash
        error_reporter._save_error_cache()
        error_reporter._load_error_cache()
    
    @patch('cuepoint.utils.error_reporter.requests.post')
    def test_github_api_rate_limit(self, mock_post, error_reporter):
        """Test handling of GitHub API rate limits."""
        mock_response = Mock()
        mock_response.status_code = 403
        mock_response.raise_for_status.side_effect = requests.HTTPError("Rate limit exceeded")
        mock_post.return_value = mock_response
        
        issue_number = error_reporter.report_error("TestError", "Test message")
        
        assert issue_number is None  # Should fail gracefully
```

**Test Execution Strategy**:

1. **Unit Tests**: Run isolated tests for each method
   ```bash
   pytest SRC/tests/unit/utils/test_error_reporter.py -v
   ```

2. **Integration Tests**: Test with mock GitHub API
   ```bash
   pytest SRC/tests/unit/utils/test_error_reporter.py::TestErrorReporterIntegration -v
   ```

3. **Edge Case Tests**: Test error handling
   ```bash
   pytest SRC/tests/unit/utils/test_error_reporter.py::TestErrorReporterEdgeCases -v
   ```

4. **Coverage**: Ensure > 90% code coverage
   ```bash
   pytest SRC/tests/unit/utils/test_error_reporter.py --cov=cuepoint.utils.error_reporter --cov-report=html
   ```

**11.2.1.2 Integration with Crash Handler**

**File to Modify**: `SRC/cuepoint/utils/crash_handler.py`

**Integration Point**: Add error reporting to existing crash handler

**Code Addition**:
```python
# Add to crash_handler.py

from cuepoint.utils.error_reporter import report_error

# In CrashHandler.handle_exception method:
def handle_exception(self, exc_type, exc_value, exc_traceback):
    """Handle uncaught exception."""
    # ... existing code ...
    
    # Report to GitHub Issues
    try:
        traceback_str = ''.join(traceback.format_exception(exc_type, exc_value, exc_traceback))
        report_error(
            error_type=exc_type.__name__,
            error_message=str(exc_value),
            traceback=traceback_str,
            additional_info={
                'crash_report': True,
                'user_action': self._get_user_action_context()
            }
        )
    except Exception as e:
        logger.warning(f"Failed to report error to GitHub: {e}")
```

**Test Implementation Guidance for Crash Handler Integration**

**File to Create**: `SRC/tests/unit/utils/test_crash_handler_integration.py`

**Integration Test Suite**:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Integration Tests for Crash Handler with Error Reporter

Tests the integration between crash handler and error reporter.
"""

import sys
from unittest.mock import Mock, patch, MagicMock

import pytest

from cuepoint.utils.crash_handler import CrashHandler
from cuepoint.utils.error_reporter import report_error


class TestCrashHandlerErrorReporting:
    """Test crash handler error reporting integration."""
    
    @pytest.fixture
    def crash_handler(self):
        """Create CrashHandler instance."""
        handler = CrashHandler()
        return handler
    
    @patch('cuepoint.utils.crash_handler.report_error')
    def test_handle_exception_reports_error(self, mock_report_error, crash_handler):
        """Test that handle_exception reports errors."""
        # Create test exception
        test_exception = ValueError("Test error message")
        
        # Call handle_exception
        crash_handler.handle_exception(
            ValueError,
            test_exception,
            sys.exc_info()[2]
        )
        
        # Verify report_error was called
        mock_report_error.assert_called_once()
        call_args = mock_report_error.call_args
        
        assert call_args[0][0] == "ValueError"
        assert "Test error message" in call_args[0][1]
        assert call_args[1]["additional_info"]["crash_report"] is True
    
    @patch('cuepoint.utils.crash_handler.report_error')
    def test_handle_exception_includes_context(self, mock_report_error, crash_handler):
        """Test that handle_exception includes user action context."""
        # Mock user action context
        with patch.object(crash_handler, '_get_user_action_context', return_value="Processing tracks"):
            crash_handler.handle_exception(
                ValueError,
                ValueError("Error"),
                sys.exc_info()[2]
            )
            
            call_args = mock_report_error.call_args
            assert call_args[1]["additional_info"]["user_action"] == "Processing tracks"
    
    @patch('cuepoint.utils.crash_handler.report_error')
    def test_handle_exception_handles_report_failure(self, mock_report_error, crash_handler):
        """Test that handle_exception handles report_error failures gracefully."""
        # Make report_error raise exception
        mock_report_error.side_effect = Exception("Report failed")
        
        # Should not crash
        crash_handler.handle_exception(
            ValueError,
            ValueError("Error"),
            sys.exc_info()[2]
        )
        
        # Exception should be caught and logged, not propagated
        assert True  # If we get here, exception was handled
```

**Test Execution**:
```bash
pytest SRC/tests/unit/utils/test_crash_handler_integration.py -v
```

**11.2.1.3 User Consent Mechanism**

**File to Create**: `SRC/cuepoint/utils/error_reporting_prefs.py`

**Purpose**: Manage user preferences for error reporting

**Code**:
```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Error Reporting Preferences

Manages user preferences for error reporting.
"""

from PySide6.QtCore import QSettings


class ErrorReportingPrefs:
    """Manage error reporting preferences."""
    
    def __init__(self):
        self.settings = QSettings()
    
    def is_enabled(self) -> bool:
        """Check if error reporting is enabled."""
        return self.settings.value("error_reporting/enabled", True, type=bool)
    
    def set_enabled(self, enabled: bool) -> None:
        """Set error reporting enabled state."""
        self.settings.setValue("error_reporting/enabled", enabled)
    
    def has_user_consented(self) -> bool:
        """Check if user has consented to error reporting."""
        return self.settings.value("error_reporting/consented", False, type=bool)
    
    def set_consented(self, consented: bool) -> None:
        """Set user consent for error reporting."""
        self.settings.setValue("error_reporting/consented", consented)
```

**Test Implementation Guidance for Error Reporting Preferences**

**File to Create**: `SRC/tests/unit/utils/test_error_reporting_prefs.py`

**Test Suite**:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Tests for Error Reporting Preferences

Tests user preference management for error reporting.
"""

from unittest.mock import Mock, MagicMock

import pytest

from cuepoint.utils.error_reporting_prefs import ErrorReportingPrefs


class TestErrorReportingPrefs:
    """Test ErrorReportingPrefs class."""
    
    @pytest.fixture
    def mock_settings(self):
        """Create mock QSettings."""
        settings = MagicMock()
        settings.value = Mock(return_value=False)
        return settings
    
    @pytest.fixture
    def prefs(self, mock_settings, monkeypatch):
        """Create ErrorReportingPrefs instance with mocked settings."""
        with patch('cuepoint.utils.error_reporting_prefs.QSettings', return_value=mock_settings):
            return ErrorReportingPrefs()
    
    def test_is_enabled_default(self, prefs, mock_settings):
        """Test is_enabled returns default value."""
        mock_settings.value.return_value = True
        assert prefs.is_enabled() is True
        
        mock_settings.value.assert_called_with("error_reporting/enabled", True, type=bool)
    
    def test_set_enabled(self, prefs, mock_settings):
        """Test set_enabled saves preference."""
        prefs.set_enabled(False)
        
        mock_settings.setValue.assert_called_with("error_reporting/enabled", False)
    
    def test_has_user_consented_default(self, prefs, mock_settings):
        """Test has_user_consented returns default value."""
        mock_settings.value.return_value = False
        assert prefs.has_user_consented() is False
        
        mock_settings.value.assert_called_with("error_reporting/consented", False, type=bool)
    
    def test_set_consented(self, prefs, mock_settings):
        """Test set_consented saves preference."""
        prefs.set_consented(True)
        
        mock_settings.setValue.assert_called_with("error_reporting/consented", True)
```

**Test Execution**:
```bash
pytest SRC/tests/unit/utils/test_error_reporting_prefs.py -v
```

**11.2.1.4 Configuration**

**File to Create**: `config/error_reporting.yaml`

**Purpose**: Configuration for error reporting

**Content**:
```yaml
error_reporting:
  enabled: true
  github_repo: "stuchain/CuePoint"  # Update with your repo
  github_token_env: "GITHUB_TOKEN"  # Environment variable name
  require_consent: true
  report_crashes: true
  report_exceptions: true
  min_severity: "error"  # error, warning, info
  deduplication_window_hours: 24
```

### Task 11.2.2: Create GitHub Issue Templates

**What to Create**
- GitHub issue templates for error reports
- Auto-labeling configuration
- Issue template configuration

**Implementation Details**

**11.2.2.1 Error Report Issue Template**

**File to Create**: `.github/ISSUE_TEMPLATE/error_report.yml`

**Content**:
```yaml
name: Error Report
description: Report an application error or crash
title: "[Error] "
labels: ["error", "bug"]
body:
  - type: markdown
    attributes:
      value: |
        This issue was automatically created by the error reporting system.
        
        Please review the error details below and add any additional context.
  
  - type: textarea
    id: error_type
    attributes:
      label: Error Type
      description: Type of error (e.g., Crash, Exception, Warning)
      value: Auto-detected
    validations:
      required: true
  
  - type: textarea
    id: error_message
    attributes:
      label: Error Message
      description: The error message
      value: Auto-detected
    validations:
      required: true
  
  - type: textarea
    id: traceback
    attributes:
      label: Traceback
      description: Error traceback (if available)
      value: Auto-detected
  
  - type: textarea
    id: system_info
    attributes:
      label: System Information
      description: System information (OS, version, etc.)
      value: Auto-detected
  
  - type: textarea
    id: steps_to_reproduce
    attributes:
      label: Steps to Reproduce
      description: Steps to reproduce the error (if known)
      placeholder: |
        1. 
        2. 
        3. 
  
  - type: textarea
    id: expected_behavior
    attributes:
      label: Expected Behavior
      description: What should have happened?
  
  - type: textarea
    id: additional_context
    attributes:
      label: Additional Context
      description: Any other context about the error
```

**11.2.2.2 Issue Template Configuration**

**File to Create**: `.github/ISSUE_TEMPLATE/config.yml`

**Content**:
```yaml
blank_issues_enabled: true
contact_links:
  - name: Support Question
    url: https://github.com/stuchain/CuePoint/discussions
    about: Ask a question or get help
  - name: Feature Request
    url: https://github.com/stuchain/CuePoint/issues/new?template=feature_request.yml
    about: Suggest a new feature
```

### Task 11.2.3: Initialize Error Reporter

**File to Modify**: `SRC/gui_app.py`

**Integration Point**: Initialize error reporter at application startup

**Code Addition**:
```python
# Add to gui_app.py startup

from cuepoint.utils.error_reporter import init_error_reporter
from cuepoint.utils.error_reporting_prefs import ErrorReportingPrefs
import os

# Initialize error reporter
prefs = ErrorReportingPrefs()
if prefs.is_enabled() and prefs.has_user_consented():
    github_repo = "stuchain/CuePoint"  # Update with your repo
    github_token = os.getenv("GITHUB_TOKEN")  # Optional, can be None for public repos
    init_error_reporter(github_repo, github_token, enabled=True)
```

**Test Implementation Guidance for Application Integration**

**File to Create**: `SRC/tests/integration/test_error_reporter_integration.py`

**Integration Test Suite**:

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
Integration Tests for Error Reporter in Application

Tests error reporter integration with application startup.
"""

import os
from unittest.mock import Mock, patch, MagicMock

import pytest

from cuepoint.utils.error_reporter import init_error_reporter
from cuepoint.utils.error_reporting_prefs import ErrorReportingPrefs


class TestErrorReporterApplicationIntegration:
    """Test error reporter application integration."""
    
    @patch('cuepoint.utils.error_reporting_prefs.ErrorReportingPrefs')
    @patch('cuepoint.utils.error_reporter.init_error_reporter')
    def test_error_reporter_initialization_enabled(self, mock_init, mock_prefs_class):
        """Test error reporter initialization when enabled and consented."""
        # Mock preferences
        mock_prefs = MagicMock()
        mock_prefs.is_enabled.return_value = True
        mock_prefs.has_user_consented.return_value = True
        mock_prefs_class.return_value = mock_prefs
        
        # Mock environment
        with patch.dict(os.environ, {"GITHUB_TOKEN": "test_token"}):
            # Simulate application startup code
            prefs = ErrorReportingPrefs()
            if prefs.is_enabled() and prefs.has_user_consented():
                github_repo = "test/repo"
                github_token = os.getenv("GITHUB_TOKEN")
                init_error_reporter(github_repo, github_token, enabled=True)
        
        # Verify initialization was called
        mock_init.assert_called_once_with("test/repo", "test_token", True)
    
    @patch('cuepoint.utils.error_reporting_prefs.ErrorReportingPrefs')
    @patch('cuepoint.utils.error_reporter.init_error_reporter')
    def test_error_reporter_initialization_disabled(self, mock_init, mock_prefs_class):
        """Test error reporter not initialized when disabled."""
        # Mock preferences
        mock_prefs = MagicMock()
        mock_prefs.is_enabled.return_value = False
        mock_prefs.has_user_consented.return_value = True
        mock_prefs_class.return_value = mock_prefs
        
        # Simulate application startup code
        prefs = ErrorReportingPrefs()
        if prefs.is_enabled() and prefs.has_user_consented():
            init_error_reporter("test/repo", None, enabled=True)
        
        # Verify initialization was NOT called
        mock_init.assert_not_called()
    
    @patch('cuepoint.utils.error_reporting_prefs.ErrorReportingPrefs')
    @patch('cuepoint.utils.error_reporter.init_error_reporter')
    def test_error_reporter_initialization_no_consent(self, mock_init, mock_prefs_class):
        """Test error reporter not initialized without consent."""
        # Mock preferences
        mock_prefs = MagicMock()
        mock_prefs.is_enabled.return_value = True
        mock_prefs.has_user_consented.return_value = False
        mock_prefs_class.return_value = mock_prefs
        
        # Simulate application startup code
        prefs = ErrorReportingPrefs()
        if prefs.is_enabled() and prefs.has_user_consented():
            init_error_reporter("test/repo", None, enabled=True)
        
        # Verify initialization was NOT called
        mock_init.assert_not_called()
```

**Test Execution**:
```bash
pytest SRC/tests/integration/test_error_reporter_integration.py -v
```

**End-to-End Test Strategy**:

1. **Manual Testing**: Test error reporting in development environment
   - Trigger test error
   - Verify GitHub issue is created
   - Verify error context is correct
   - Verify sensitive data is filtered

2. **Staging Testing**: Test with staging GitHub repository
   - Use test repository for error reporting
   - Verify issues are created correctly
   - Test deduplication
   - Test error cache persistence

3. **Production Testing**: Gradual rollout
   - Enable for beta users first
   - Monitor error report volume
   - Verify no performance impact
   - Verify user consent flow

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/utils/error_reporter.py` - Error reporter module
2. `SRC/cuepoint/utils/error_reporting_prefs.py` - User preferences
3. `config/error_reporting.yaml` - Configuration
4. `.github/ISSUE_TEMPLATE/error_report.yml` - Error report template
5. `.github/ISSUE_TEMPLATE/config.yml` - Template configuration

### Modified Files
1. `SRC/cuepoint/utils/crash_handler.py` - Add error reporting
2. `SRC/gui_app.py` - Initialize error reporter
3. `SRC/cuepoint/ui/dialogs/settings_dialog.py` - Add error reporting preference

## Implementation Checklist

### Error Reporter Module
- [ ] Error reporter module created
- [ ] GitHub Issues integration working
- [ ] Privacy filtering implemented
- [ ] Error deduplication working
- [ ] Error cache implemented

### Integration
- [ ] Crash handler integration complete
- [ ] Error reporter initialized at startup
- [ ] User consent mechanism implemented
- [ ] Settings UI for error reporting added

### GitHub Configuration
- [ ] Issue templates created
- [ ] Issue template configuration added
- [ ] Auto-labeling configured
- [ ] GitHub token configured (if needed)

### Testing
- [ ] Error reporting tested
- [ ] Privacy filtering verified
- [ ] Error deduplication verified
- [ ] User consent flow tested

## Success Criteria

### Error Monitoring Working
- ✅ Errors are automatically reported to GitHub Issues
- ✅ Critical errors are detected and reported
- ✅ Error reports include useful context
- ✅ Privacy is respected (sensitive data filtered)
- ✅ User consent is obtained before reporting

### GitHub Integration Working
- ✅ Issue templates are created
- ✅ Auto-labeling works
- ✅ Error reports are searchable
- ✅ Error tracking is efficient

## Cost Analysis

**Total Cost: $0**
- ✅ GitHub Issues: FREE
- ✅ GitHub API: FREE (within rate limits)
- ✅ No third-party services required

## Next Steps

After completing Step 11.2, proceed to:
- **Step 11.3**: User Analytics & Telemetry (optional)
- **Step 11.4**: Performance Monitoring

## References

- GitHub Issues API: https://docs.github.com/en/rest/issues
- Main Step 11 document: `../11_Post_Launch_Operations_and_Support.md`
- Crash handler: `SRC/cuepoint/utils/crash_handler.py`

