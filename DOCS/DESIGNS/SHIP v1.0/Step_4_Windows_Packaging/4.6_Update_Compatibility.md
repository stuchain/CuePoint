# Implementation Step 4.6: Update Compatibility

## Implementation Overview
**What We're Building**: A comprehensive update compatibility system that ensures CuePoint can be updated seamlessly from any previous version to any newer version, preserving user data, maintaining application identity, and integrating with the auto-update system (WinSparkle). This includes update detection, version comparison, installer-based update flow, data preservation, and all aspects of the update experience.

## Implementation Tasks

### Task 4.6.1: Define Update System Requirements

**What to Build**
- Update system architecture
- Update detection and notification
- Update download and verification
- Update installation flow
- Update rollback capability
- Update system security

**Implementation Details**

**4.6.1.1 Update System Architecture**
- **Update Mechanism**: Installer-based updates (recommended for v1.0)
  - **Rationale**: Simpler than in-place patching, reliable, well-tested
  - **Process**: WinSparkle downloads signed installer, runs it
  - **Advantages**: 
    - Simple implementation
    - Reliable upgrade process
    - Handles all file updates
    - Works with existing installer
  - **Disadvantages**: 
    - Downloads full installer (larger than delta)
    - Requires installer execution
- **Alternative**: Delta updates (future consideration)
  - **Rationale**: Smaller downloads, faster updates
  - **Process**: Download only changed files, apply patches
  - **Advantages**: Smaller downloads, faster updates
  - **Disadvantages**: More complex, requires delta generation
  - **Recommendation**: Defer to v1.1+ if needed
- **Update Feed**: Appcast/update feed hosted on GitHub Pages or CDN
  - **Format**: XML (Sparkle/WinSparkle format)
  - **Location**: GitHub Pages or CDN
  - **Content**: Version info, download URL, release notes, signatures

**4.6.1.2 Update Detection and Notification**
- **Detection Method**: WinSparkle checks update feed periodically
  - **Frequency**: On app launch, then periodic (configurable)
  - **Manual Check**: User can check for updates manually
  - **Background Check**: Automatic background checking
- **Update Notification**:
  - **New Version Available**: Show notification to user
  - **Update Dialog**: Informative update dialog
  - **Release Notes**: Show what's new in update
  - **User Choice**: Download now, remind later, skip version
- **Update Prompt Design**:
  - Clear version information
  - Release notes preview
  - Download size indication
  - Update button
  - Remind later option
  - Skip version option

**4.6.1.3 Update Download and Verification**
- **Download Process**:
  - Download installer from update feed URL
  - Show download progress
  - Verify download integrity (checksum)
  - Verify signature
- **Verification Requirements**:
  - **Checksum Verification**: Verify downloaded file checksum matches feed
  - **Signature Verification**: Verify installer signature is valid
  - **Publisher Verification**: Verify publisher matches expected
  - **Version Verification**: Verify version matches feed
- **Security**:
  - HTTPS download (secure channel)
  - Signature verification (authenticity)
  - Checksum verification (integrity)
  - Publisher verification (trust)

**4.6.1.4 Update Installation Flow**
- **Installation Process**:
  1. **Pre-Installation**:
     - Close running app (or prompt user)
     - Verify installer signature
     - Verify installer version
  2. **Installation**:
     - Run installer (upgrade mode)
     - Installer detects existing installation
     - Installer upgrades files
     - Installer preserves user data
  3. **Post-Installation**:
     - Launch updated app
     - Verify update succeeded
     - Show update success message
- **User Experience**:
  - Seamless upgrade process
  - Minimal user interaction
  - Clear progress indication
  - Success confirmation

**4.6.1.5 Update Rollback Capability**
- **Rollback Strategy**: Manual rollback (not automatic)
  - **Rationale**: Simpler for v1.0, user can reinstall previous version
  - **Process**: User downloads previous version installer
  - **Future**: Automatic rollback if update fails (v1.1+)
- **Update Failure Handling**:
  - Detect update failure
  - Report error to user
  - Provide rollback instructions
  - Support for manual rollback

**4.6.1.6 Update System Security**
- **Security Requirements**:
  - Signed update feed (if possible)
  - Signed installer downloads
  - Signature verification before installation
  - Secure download channel (HTTPS)
  - Publisher verification
- **Security Measures**:
  - Verify installer signature
  - Verify publisher matches
  - Verify version matches feed
  - Secure download (HTTPS)
  - Integrity checks (checksums)

### Task 4.6.2: Define Version Compatibility

**What to Build**
- Version comparison logic
- Version compatibility rules
- Upgrade path validation
- Version format consistency
- Version metadata for updates

**Implementation Details**

**4.6.2.1 Version Comparison Logic**
- **Version Format**: Semantic Versioning (SemVer: X.Y.Z)
- **Comparison Rules**:
  - **Major Version**: Breaking changes (may require migration)
  - **Minor Version**: New features, backward compatible
  - **Patch Version**: Bug fixes, backward compatible
- **Version Comparison**:
  - Compare version strings
  - Determine if update is available
  - Determine update type (major/minor/patch)
  - Handle pre-release versions (if any)
- **Implementation**:
  - Parse version string
  - Compare major, minor, patch components
  - Return comparison result (newer, older, same)

**4.6.2.2 Version Compatibility Rules**
- **Backward Compatibility**:
  - **Minor/Patch Updates**: Fully backward compatible
    - User data format unchanged
    - Configuration format unchanged
    - No migration needed
  - **Major Updates**: May require migration
    - User data format may change
    - Configuration format may change
    - Migration may be needed
- **Upgrade Paths**:
  - **Any → Latest**: Always supported (installer-based)
  - **Old → New**: Supported (installer handles upgrade)
  - **Skip Versions**: Supported (can upgrade from any version to any newer version)
- **Version Skipping**:
  - **Allowed**: Can skip intermediate versions
  - **Rationale**: Installer-based updates support this
  - **Example**: Upgrade from 1.0.0 directly to 1.2.0

**4.6.2.3 Upgrade Path Validation**
- **Validation Requirements**:
  - Verify upgrade path is valid
  - Verify version compatibility
  - Verify data format compatibility
  - Verify migration support (if needed)
- **Validation Script**: `scripts/validate_upgrade_path.py`
- **Validation Checks**:
  - Version format valid
  - Upgrade path supported
  - Data format compatible
  - Migration available (if needed)

**4.6.2.4 Version Format Consistency**
- **Consistency Requirements**:
  - Version format consistent across all components
  - Version in executable matches version in installer
  - Version in update feed matches version in installer
  - Version in release notes matches version
- **Validation**: Automated version consistency validation
- **Failure Handling**: Build fails if version inconsistent

**4.6.2.5 Version Metadata for Updates**
- **Update Feed Metadata**:
  - **Version**: Current version (X.Y.Z)
  - **Minimum Version**: Minimum supported version for upgrade
  - **Critical Update**: Flag for critical security updates
  - **Release Notes**: What's new in this version
  - **Download URL**: URL to installer
  - **File Size**: Installer file size
  - **Checksum**: SHA256 checksum of installer
  - **Signature**: DSA signature (for Sparkle/WinSparkle)
- **Metadata Generation**: `scripts/generate_update_feed.py`
- **Metadata Validation**: Verify all required fields present

### Task 4.6.3: Define Installer-Based Update Flow

**What to Build**
- Update flow integration with installer
- Upgrade detection in installer
- Data preservation during update
- Update installation process
- Update validation

**Implementation Details**

**4.6.3.1 Update Flow Integration**
- **WinSparkle Integration**:
  - WinSparkle checks update feed
  - WinSparkle downloads installer
  - WinSparkle verifies installer signature
  - WinSparkle runs installer
  - Installer handles upgrade
- **Installer Upgrade Mode**:
  - Installer detects existing installation
  - Installer enters upgrade mode
  - Installer upgrades files
  - Installer preserves user data
  - Installer updates shortcuts and registry
- **User Experience**:
  - User clicks "Update" in app
  - App downloads installer (with progress)
  - App closes
  - Installer runs automatically
  - Installer upgrades installation
  - Updated app launches

**4.6.3.2 Upgrade Detection in Installer**
- **Detection Logic**:
  - Check if installation directory exists
  - Check if executable exists
  - Check registry for existing installation
  - Get installed version
  - Compare with installer version
- **Upgrade Mode**:
  - If existing installation found → Upgrade mode
  - If no existing installation → Fresh install mode
- **Upgrade Prompt**:
  - Inform user about upgrade
  - Show current and new version
  - Confirm upgrade
  - Option to cancel

**4.6.3.3 Data Preservation During Update**
- **Preservation Strategy**:
  - **User Data**: Always preserved (separate from installation)
  - **Configuration**: Always preserved (in AppData)
  - **Cache**: Preserved (can be cleared if needed)
  - **Logs**: Preserved (for debugging)
  - **Exports**: Always preserved (user files)
- **Preservation Implementation**:
  - Installer only modifies installation directory
  - User data directories untouched
  - Configuration files untouched
  - Application reads from user data on launch
- **Data Migration** (if needed):
  - Detect old data format
  - Migrate to new format
  - Backup old data
  - Verify migration

**4.6.3.4 Update Installation Process**
- **Process Steps**:
  1. **Pre-Update**:
     - Detect existing installation
     - Check for running app
     - Prompt to close app
     - Verify installer signature
  2. **Update Installation**:
     - Remove old executable
     - Remove old dependencies (if changed)
     - Install new executable
     - Install new dependencies
     - Update shortcuts
     - Update registry entries
  3. **Post-Update**:
     - Verify new version installed
     - Verify data preserved
     - Launch updated app
- **Error Handling**:
  - Handle installation errors
  - Rollback if needed (if backup created)
  - Report errors to user

**4.6.3.5 Update Validation**
- **Validation Checks**:
  - New version installed correctly
  - User data preserved
  - Configuration preserved
  - Shortcuts updated
  - Registry entries updated
  - App can launch
  - Version number correct
- **Validation Script**: Run after update
- **Failure Handling**: Report errors, provide rollback option

### Task 4.6.4: Define Update Feed Generation

**What to Build**
- Update feed format specification
- Update feed generation script
- Update feed validation
- Update feed publishing
- Update feed security

**Implementation Details**

**4.6.4.1 Update Feed Format**
- **Format**: XML (Sparkle/WinSparkle appcast format)
- **Structure**:
  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle">
    <channel>
      <title>CuePoint Updates</title>
      <item>
        <title>Version X.Y.Z</title>
        <pubDate>Date</pubDate>
        <sparkle:version>X.Y.Z</sparkle:version>
        <sparkle:shortVersionString>X.Y.Z</sparkle:shortVersionString>
        <enclosure url="https://..." length="SIZE" type="application/octet-stream" sparkle:dsaSignature="SIGNATURE"/>
        <description><![CDATA[Release notes]]></description>
      </item>
    </channel>
  </rss>
  ```
- **Required Fields**:
  - Version: `sparkle:version`
  - Short Version: `sparkle:shortVersionString`
  - Download URL: `enclosure url`
  - File Size: `enclosure length`
  - Signature: `sparkle:dsaSignature` (DSA signature for Sparkle)
  - Release Notes: `description`
  - Publication Date: `pubDate`

**4.6.4.2 Update Feed Generation Script**
- **Script**: `scripts/generate_update_feed.py`
- **Functionality**:
  - Read version from version.py
  - Read release notes
  - Generate installer checksum
  - Generate DSA signature (for Sparkle)
  - Generate update feed XML
  - Validate feed format
- **Input**:
  - Version information
  - Installer file path
  - Release notes
  - Download URL
- **Output**:
  - Update feed XML file
  - Validation report

**4.6.4.3 Update Feed Validation**
- **Validation Requirements**:
  - Valid XML format
  - All required fields present
  - Version format correct
  - URLs valid and accessible
  - Signatures valid
  - File sizes correct
- **Validation Script**: `scripts/validate_feeds.py`
- **Validation Timing**: After feed generation, before publishing

**4.6.4.4 Update Feed Publishing**
- **Publishing Location**: GitHub Pages or CDN
  - **GitHub Pages**: `https://username.github.io/cuepoint/appcast.xml`
  - **CDN**: Custom CDN URL
- **Publishing Process**:
  1. Generate update feed
  2. Validate feed
  3. Commit to repository (if GitHub Pages)
  4. Push to gh-pages branch
  5. Verify feed accessible
- **Feed URL**: Configured in application (WinSparkle)

**4.6.4.5 Update Feed Security**
- **Security Requirements**:
  - HTTPS feed URL (secure channel)
  - Signed feed (if possible)
  - Signed installers (required)
  - Signature verification (required)
- **Security Measures**:
  - Use HTTPS for feed
  - Verify installer signatures
  - Verify publisher matches
  - Secure feed generation

### Task 4.6.5: Define Update System Integration

**What to Build**
- WinSparkle integration
- Update check configuration
- Update notification UI
- Update download UI
- Update installation integration

**Implementation Details**

**4.6.5.1 WinSparkle Integration**
- **WinSparkle Library**: Embedded in application
  - **Purpose**: Update checking and installation
  - **Location**: Bundled with application
  - **Version**: Latest stable version
- **WinSparkle Configuration**:
  - **Update Feed URL**: Configured in application
  - **Check Interval**: Configurable (default: on launch, then periodic)
  - **Update Prompt**: Customizable UI
  - **Signature Verification**: Enabled
- **WinSparkle Initialization**:
  - Initialize on app startup
  - Configure feed URL
  - Configure update check behavior
  - Set up update handlers

**4.6.5.2 Update Check Configuration**
- **Check Frequency**:
  - **On Launch**: Check for updates on app launch
  - **Periodic**: Check periodically (e.g., daily, weekly)
  - **Manual**: User can check manually
- **Check Behavior**:
  - **Automatic**: Check in background
  - **Silent**: Don't prompt if no updates
  - **Prompt**: Show dialog if update available
- **Configuration Options**:
  - Enable/disable automatic checks
  - Set check interval
  - Set update prompt behavior

**4.6.5.3 Update Notification UI**
- **Update Available Dialog**:
  - **Content**:
    - New version available message
    - Current version and new version
    - Release notes preview
    - Download size
    - Update button
    - Remind later button
    - Skip version button
  - **Design**: Clear, informative, non-intrusive
  - **User Choice**: Download now, remind later, skip version
- **Update Download Dialog**:
  - **Content**:
    - Download progress bar
    - Download speed
    - Time remaining
    - Cancel button
  - **Design**: Clear progress indication
- **Update Installation Dialog**:
  - **Content**:
    - Installation in progress message
    - App will close and restart message
    - Cancel button (if possible)
  - **Design**: Clear status indication

**4.6.5.4 Update Download UI**
- **Download Progress**:
  - Progress bar
  - Download speed
  - Time remaining
  - File size downloaded/total
- **Download Status**:
  - Downloading
  - Verifying
  - Ready to install
  - Error (if any)
- **User Control**:
  - Cancel download
  - Pause download (if supported)
  - Retry on error

**4.6.5.5 Update Installation Integration**
- **Installation Trigger**:
  - User clicks "Install Update"
  - App closes gracefully
  - Installer launches automatically
  - Installer upgrades installation
  - Updated app launches
- **Installation Flow**:
  - Save application state (if needed)
  - Close application
  - Launch installer
  - Installer upgrades
  - Launch updated application
  - Restore application state (if saved)

### Task 4.6.6: Define Update Testing and Validation

**What to Build**
- Update testing procedures
- Update validation scripts
- Update compatibility testing
- Update failure testing
- Update rollback testing

**Implementation Details**

**4.6.6.1 Update Testing Procedures**
- **Test Scenarios**:
  - Fresh installation → Update to new version
  - Old version → Update to new version
  - Skip versions (e.g., 1.0.0 → 1.2.0)
  - Multiple updates in sequence
  - Update with running app
  - Update with user data
- **Test Environment**:
  - Clean Windows VMs
  - Different Windows versions
  - Different installation states
- **Test Validation**:
  - Update succeeds
  - Data preserved
  - App launches
  - Functionality works
  - Version correct

**4.6.6.2 Update Validation Scripts**
- **Script**: `scripts/validate_update_compatibility.py`
- **Functionality**:
  - Validate version format
  - Validate upgrade path
  - Validate data compatibility
  - Validate update feed
  - Generate validation report
- **Integration**: Called in CI before release

**4.6.6.3 Update Compatibility Testing**
- **Compatibility Matrix**:
  - Test upgrades from all previous versions
  - Test upgrades to current version
  - Test version skipping
  - Test data format changes
- **Compatibility Validation**:
  - Verify all upgrade paths work
  - Verify data preserved
  - Verify app functions after upgrade

**4.6.6.4 Update Failure Testing**
- **Failure Scenarios**:
  - Update download fails
  - Update signature invalid
  - Update installation fails
  - App won't launch after update
- **Failure Handling**:
  - Detect failures
  - Report errors
  - Provide recovery options
  - Support rollback

**4.6.6.5 Update Rollback Testing**
- **Rollback Scenarios**:
  - User wants to rollback
  - Update fails and rollback needed
  - Manual rollback process
- **Rollback Validation**:
  - Verify rollback works
  - Verify data preserved
  - Verify app functions after rollback

## Implementation Checklist

### Update System Requirements
- [ ] Define update system architecture
- [ ] Define update detection
- [ ] Define update download
- [ ] Define update installation
- [ ] Define update security

### Version Compatibility
- [ ] Define version comparison
- [ ] Define compatibility rules
- [ ] Define upgrade paths
- [ ] Create validation

### Installer-Based Update
- [ ] Integrate update flow
- [ ] Implement upgrade detection
- [ ] Implement data preservation
- [ ] Test update flow

### Update Feed
- [ ] Define feed format
- [ ] Create feed generation script
- [ ] Create feed validation
- [ ] Implement feed publishing

### WinSparkle Integration
- [ ] Integrate WinSparkle
- [ ] Configure update checks
- [ ] Implement update UI
- [ ] Test integration

### Testing
- [ ] Create update testing procedures
- [ ] Create validation scripts
- [ ] Test update scenarios
- [ ] Test failure scenarios

## Files to Create/Modify

### New Files
1. `DOCS/DESIGNS/SHIP v1.0/Step_4_Windows_Packaging/4.6_Update_Compatibility.md` - This document
2. `scripts/validate_update_compatibility.py` - Update compatibility validation
3. `scripts/generate_update_feed.py` - Update feed generation (Windows)

### Files to Modify
1. `scripts/generate_update_feed.py` - Enhance for Windows (if exists)
2. `DOCS/DESIGNS/SHIP v1.0/Step_4_Windows_Packaging/README.md` - Add reference

## Implementation Dependencies

### Prerequisites
- Step 4.2: Build Output (executable structure)
- Step 4.3: App Identity (version metadata)
- Step 4.5: Installer Behavior (installer upgrade support)
- WinSparkle library

### Enables
- Step 5: Auto-Update System (uses update compatibility)

## Success Criteria

### Update System
- ✅ Update detection works
- ✅ Update download works
- ✅ Update installation works
- ✅ Data preserved during updates
- ✅ Update feed generated correctly

### Version Compatibility
- ✅ Version comparison works
- ✅ Upgrade paths supported
- ✅ Version skipping supported
- ✅ Data compatibility maintained

### Integration
- ✅ WinSparkle integrated
- ✅ Update UI works
- ✅ Update flow works
- ✅ Update validation works

## Next Implementation Steps

After completing Step 4.6:
1. **Step 4.7**: Common Pitfalls (prevents common issues)
2. **Step 5**: Auto-Update System (implements full update system)

## Detailed Implementation Guidance

### Update Feed Generation Example

**Complete Update Feed Generation Script**:
```python
#!/usr/bin/env python3
"""Generate Windows update feed (appcast) for WinSparkle"""

import hashlib
import sys
from pathlib import Path
from datetime import datetime
import xml.etree.ElementTree as ET

# Add SRC to path
sys.path.insert(0, str(Path('SRC').resolve()))

from cuepoint.version import __version__

def generate_dsa_signature(installer_path, private_key_path):
    """Generate DSA signature for Sparkle/WinSparkle"""
    # Note: DSA signature generation requires OpenSSL or similar
    # This is a placeholder - actual implementation uses OpenSSL
    import subprocess
    
    result = subprocess.run(
        ['openssl', 'dgst', '-sha1', '-sign', private_key_path, installer_path],
        capture_output=True,
        check=True
    )
    
    # Base64 encode signature
    import base64
    return base64.b64encode(result.stdout).decode('utf-8')

def generate_update_feed(installer_path, release_notes, feed_url, download_url):
    """Generate update feed XML"""
    installer = Path(installer_path)
    
    # Get file size
    file_size = installer.stat().st_size
    
    # Generate checksum
    sha256 = hashlib.sha256()
    with open(installer, 'rb') as f:
        sha256.update(f.read())
    checksum = sha256.hexdigest()
    
    # Generate DSA signature (if private key available)
    dsa_signature = None
    private_key = Path('build/dsa_private_key.pem')
    if private_key.exists():
        dsa_signature = generate_dsa_signature(installer_path, str(private_key))
    
    # Create XML structure
    rss = ET.Element('rss', version='2.0')
    rss.set('xmlns:sparkle', 'http://www.andymatuschak.org/xml-namespaces/sparkle')
    
    channel = ET.SubElement(rss, 'channel')
    ET.SubElement(channel, 'title').text = 'CuePoint Updates'
    ET.SubElement(channel, 'link').text = feed_url
    ET.SubElement(channel, 'description').text = 'CuePoint Update Feed'
    ET.SubElement(channel, 'language').text = 'en'
    
    item = ET.SubElement(channel, 'item')
    ET.SubElement(item, 'title').text = f'Version {__version__}'
    ET.SubElement(item, 'pubDate').text = datetime.now().strftime('%a, %d %b %Y %H:%M:%S %z')
    
    # Version information
    version_elem = ET.SubElement(item, 'sparkle:version', xmlns='http://www.andymatuschak.org/xml-namespaces/sparkle')
    version_elem.text = __version__
    
    short_version = ET.SubElement(item, 'sparkle:shortVersionString', xmlns='http://www.andymatuschak.org/xml-namespaces/sparkle')
    short_version.text = __version__
    
    # Enclosure (installer)
    enclosure = ET.SubElement(item, 'enclosure')
    enclosure.set('url', download_url)
    enclosure.set('length', str(file_size))
    enclosure.set('type', 'application/octet-stream')
    enclosure.set('sparkle:dsaSignature', dsa_signature or '')
    
    # Release notes
    description = ET.SubElement(item, 'description')
    description.text = ET.CDATA(release_notes)
    
    # Convert to string
    ET.indent(rss, space='  ')
    return ET.tostring(rss, encoding='utf-8', xml_declaration=True).decode('utf-8')

if __name__ == '__main__':
    installer_path = sys.argv[1] if len(sys.argv) > 1 else 'dist/CuePoint-Setup-v1.0.0.exe'
    release_notes = sys.argv[2] if len(sys.argv) > 2 else 'Release notes'
    feed_url = sys.argv[3] if len(sys.argv) > 3 else 'https://username.github.io/cuepoint/appcast.xml'
    download_url = sys.argv[4] if len(sys.argv) > 4 else f'https://github.com/user/repo/releases/download/v{__version__}/CuePoint-Setup-v{__version__}.exe'
    
    feed_xml = generate_update_feed(installer_path, release_notes, feed_url, download_url)
    
    # Write to file
    output_path = Path('dist/appcast.xml')
    output_path.write_text(feed_xml, encoding='utf-8')
    
    print(f"Update feed generated: {output_path}")
```

### WinSparkle Integration Example

**WinSparkle Configuration in Application**:
```python
# WinSparkle integration example (conceptual)
import winsparkle

def initialize_updates():
    """Initialize WinSparkle update system"""
    # Set update feed URL
    feed_url = "https://username.github.io/cuepoint/appcast.xml"
    winsparkle.SetAppcastUrl(feed_url)
    
    # Configure update check behavior
    winsparkle.SetUpdateCheckInterval(86400)  # Check daily
    winsparkle.SetAutomaticCheckForUpdates(True)
    
    # Initialize WinSparkle
    winsparkle.Initialize()
    
    # Check for updates on startup (optional)
    winsparkle.CheckUpdateWithUI()

def check_for_updates_manual():
    """Manual update check"""
    winsparkle.CheckUpdateWithUI()

def shutdown_updates():
    """Shutdown WinSparkle"""
    winsparkle.Cleanup()
```

### Update Compatibility Testing Example

**Comprehensive Update Testing Script**:
```python
#!/usr/bin/env python3
"""Test update compatibility across versions"""

import subprocess
import sys
from pathlib import Path

def test_upgrade_from_version(old_version, new_version):
    """Test upgrade from old version to new version"""
    print(f"Testing upgrade from {old_version} to {new_version}...")
    
    # Install old version
    old_installer = f"dist/CuePoint-Setup-v{old_version}.exe"
    if not Path(old_installer).exists():
        print(f"  ERROR: Old installer not found: {old_installer}")
        return False
    
    # Install old version (in test VM)
    # subprocess.run([old_installer, '/S'])  # Silent install
    
    # Create test data
    # Create config, cache, logs, exports
    
    # Install new version
    new_installer = f"dist/CuePoint-Setup-v{new_version}.exe"
    if not Path(new_installer).exists():
        print(f"  ERROR: New installer not found: {new_installer}")
        return False
    
    # Install new version (in test VM)
    # subprocess.run([new_installer, '/S'])  # Silent install
    
    # Verify upgrade
    # - Check new version installed
    # - Check data preserved
    # - Check app launches
    # - Check functionality works
    
    print(f"  ✓ Upgrade test passed")
    return True

def test_all_upgrade_paths():
    """Test all upgrade paths"""
    versions = ['1.0.0', '1.0.1', '1.1.0', '1.2.0']
    current_version = '1.2.0'
    
    all_passed = True
    for old_version in versions:
        if old_version != current_version:
            if not test_upgrade_from_version(old_version, current_version):
                all_passed = False
    
    return all_passed

if __name__ == '__main__':
    if test_all_upgrade_paths():
        print("All upgrade tests passed")
        sys.exit(0)
    else:
        print("Some upgrade tests failed")
        sys.exit(1)
```

### Advanced Update System Considerations

**Delta Updates (Future)**:
- **Delta Update Strategy**: Download only changed files
- **Delta Generation**: Generate delta patches between versions
- **Delta Application**: Apply delta patches to existing installation
- **Advantages**: Smaller downloads, faster updates
- **Disadvantages**: More complex, requires delta generation
- **Implementation**: Consider for v1.1+ if needed

**Rollback Mechanism (Future)**:
- **Automatic Rollback**: Rollback if update fails
- **Manual Rollback**: User-initiated rollback
- **Rollback Storage**: Store previous version for rollback
- **Rollback Process**: Restore previous version files
- **Implementation**: Consider for v1.1+ if needed

**Update Channels**:
- **Stable Channel**: Production releases
- **Beta Channel**: Pre-release versions (optional)
- **Development Channel**: Development builds (optional)
- **Channel Selection**: User or configuration-based
- **Implementation**: Consider for future if needed

## Advanced Implementation Details

### Update Feed Security Deep Dive

**DSA Signature Generation**:
- **Purpose**: Cryptographic signature for update feed items
- **Algorithm**: DSA (Digital Signature Algorithm)
- **Key Pair**: Private key for signing, public key embedded in app
- **Generation**: Use OpenSSL or similar tool
- **Verification**: WinSparkle verifies signature before installing

**Feed Signing Process**:
1. Generate DSA key pair (one-time)
2. Embed public key in application
3. Sign each update feed item with private key
4. Include signature in feed XML
5. WinSparkle verifies signature before download

**Feed HTTPS Security**:
- **Requirement**: Update feed must be served over HTTPS
- **Rationale**: Prevents man-in-the-middle attacks
- **Implementation**: Use GitHub Pages with HTTPS or CDN with HTTPS
- **Validation**: Verify HTTPS certificate is valid

### Update Installation Deep Dive

**Silent Update Installation**:
- **Option**: Install updates silently (no user interaction)
- **Advantages**: Seamless updates, no user interruption
- **Disadvantages**: Less user control, potential for issues
- **Recommendation**: For v1.0, show update dialog (user control)
- **Future**: Consider silent updates for minor/patch versions

**Update Installation Timing**:
- **On Launch**: Check and install on app launch
- **In Background**: Check and install in background
- **Scheduled**: Check at scheduled times
- **Manual**: User-initiated update check
- **Recommendation**: Combination of automatic and manual

**Update Installation Verification**:
- **Post-Installation Checks**:
  - Verify new version installed
  - Verify executable launches
  - Verify functionality works
  - Verify data preserved
- **Failure Detection**: Detect if update failed
- **Recovery**: Provide recovery options if update fails

### Version Compatibility Deep Dive

**Semantic Versioning for Updates**:
- **Major Version (X)**: Breaking changes, may require migration
- **Minor Version (Y)**: New features, backward compatible
- **Patch Version (Z)**: Bug fixes, backward compatible
- **Update Behavior**:
  - **Patch Updates**: Automatic, seamless
  - **Minor Updates**: Automatic, seamless
  - **Major Updates**: May require user confirmation, migration

**Data Format Compatibility**:
- **Configuration Format**: Ensure backward compatibility
- **Data Format**: Ensure backward compatibility
- **Migration**: Handle format changes gracefully
- **Validation**: Validate data format on load

**API Compatibility**:
- **Internal APIs**: Ensure backward compatibility
- **External APIs**: Handle API changes gracefully
- **Deprecation**: Deprecate APIs gradually
- **Breaking Changes**: Document and handle breaking changes

## References

- Main document: `../04_Windows_Packaging_Signing.md`
- Related: Step 4.5 (Installer Behavior), Step 5 (Auto-Update)
- WinSparkle Documentation: https://github.com/vslavik/winsparkle
- Sparkle Appcast Format: https://sparkle-project.org/documentation/appcast/
- Semantic Versioning: https://semver.org/



