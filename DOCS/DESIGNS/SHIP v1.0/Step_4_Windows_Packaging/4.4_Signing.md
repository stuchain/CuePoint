# Implementation Step 4.4: Code Signing Implementation

## Implementation Overview
**What We're Building**: A comprehensive code signing system for Windows that ensures all executables and installers are properly signed with a valid code signing certificate, minimizing SmartScreen warnings, enabling Windows trust, and providing cryptographic verification of the application's authenticity and integrity. This includes signing automation, verification procedures, timestamping, error handling, and integration with the CI/CD pipeline.

## Implementation Tasks

### Task 4.4.1: Define Signing Architecture

**What to Build**
- Signing process architecture
- Signing order and dependencies
- Signing identity management
- Certificate handling
- Timestamp server configuration
- Signing automation framework

**Implementation Details**

**4.4.1.1 Signing Process Architecture**
- **Process Flow**:
  1. **Certificate Import**: Import code signing certificate to certificate store
  2. **Executable Signing**: Sign the main executable (CuePoint.exe)
  3. **Installer Signing**: Sign the installer executable (CuePoint-Setup.exe)
  4. **Verification**: Verify all signatures
  5. **SmartScreen Testing**: Test SmartScreen behavior (optional)
- **Signing Order**: 
  - **Rationale**: Sign executable first, then installer (installer contains executable)
  - **Order**: Executable → Installer
  - **Failure Impact**: Wrong order may cause verification issues
- **Parallel Signing**: Executable and installer can be signed independently
  - **Executable**: Sign after build
  - **Installer**: Sign after installer creation
  - **No Dependencies**: Can sign in parallel if desired
- **Atomic Operations**: Signing should be atomic where possible
  - **Rationale**: Prevents partial signing states
  - **Implementation**: Sign to temporary location, then move (if needed)
  - **Rollback**: Ability to rollback if signing fails

**4.4.1.2 Signing Identity Management**
- **Identity Format**: Certificate subject name or thumbprint
- **Identity Source**: Extracted from certificate
- **Identity Validation**: Verify identity matches expected
- **Identity Storage**: Environment variable or script parameter
- **Identity Usage**: Passed to signtool with `/f` (certificate file) or `/sha1` (thumbprint)
- **Identity Consistency**: Must be consistent across all signing operations
- **Identity Documentation**: Document expected identity in scripts
- **Common Formats**:
  - **Certificate File**: `certificate.pfx` or `certificate.p12`
  - **Certificate Store**: Certificate in Windows certificate store
  - **Thumbprint**: SHA1 thumbprint of certificate

**4.4.1.3 Certificate Management Architecture**
- **Certificate Storage**: GitHub Secrets (base64 encoded or binary)
- **Certificate Format**: .pfx or .p12 (PKCS#12)
- **Certificate Import**: Certificate store or file-based
- **Certificate Lifecycle**:
  - **Acquisition**: From certificate authority (CA)
  - **Export**: From certificate store (with password)
  - **Encoding**: Base64 encode for GitHub Secrets (if text storage)
  - **Storage**: GitHub Secrets (encrypted)
  - **Import**: To certificate store or use file during build
  - **Usage**: For code signing
  - **Cleanup**: Remove from certificate store after build (if temporary)
- **Certificate Security**:
  - Never commit to repository
  - Store only in GitHub Secrets
  - Use secure certificate storage
  - Clean up after use
  - Rotate regularly
  - Protect certificate password

**4.4.1.4 Timestamp Server Configuration**
- **Purpose**: Timestamp signatures so they remain valid after certificate expiry
- **Timestamp Servers**:
  - **Microsoft**: `http://timestamp.digicert.com` (recommended)
  - **Alternative**: `http://timestamp.verisign.com/scripts/timstamp.dll`
  - **RFC 3161**: `http://timestamp.globalsign.com/tsa/r6advanced1`
- **Timestamp Format**: SHA256 (recommended) or SHA1 (legacy)
- **Timestamp Usage**: Required for long-term signature validity
- **Timestamp Validation**: Verify timestamp is present in signature
- **Configuration**: Pass to signtool with `/tr` (RFC 3161) or `/t` (legacy)

**4.4.1.5 Signing Automation Framework**
- **Automation Level**: Fully automated
- **Trigger**: Automatic on tag push (release builds)
- **Manual Override**: Workflow dispatch for testing
- **Error Handling**: Fail-fast with clear errors
- **Logging**: Comprehensive signing logs
- **Verification**: Automatic verification after signing
- **Integration**: Seamless CI/CD integration

### Task 4.4.2: Implement Executable Signing

**What to Build**
- Executable signing procedure
- Signing script for executable
- Signing verification
- Error handling
- Signing automation

**Implementation Details**

**4.4.2.1 Executable Signing Procedure**
- **Signing Command**:
  ```powershell
  signtool sign /f certificate.pfx /p password /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 /v CuePoint.exe
  ```
- **Signing Options Explained**:
  - `/f certificate.pfx`: Certificate file path
  - `/p password`: Certificate password
  - `/tr http://timestamp.digicert.com`: RFC 3161 timestamp server
  - `/td SHA256`: Timestamp digest algorithm (SHA256)
  - `/fd SHA256`: File digest algorithm (SHA256)
  - `/v`: Verbose output
  - `CuePoint.exe`: File to sign
- **Alternative Options**:
  - `/sha1 thumbprint`: Use certificate from store by thumbprint
  - `/t http://timestamp.verisign.com/scripts/timstamp.dll`: Legacy timestamp server
  - `/d "Description"`: Description of signed content
  - `/du "URL"`: URL with more information
- **Signing Location**: After PyInstaller build, before installer creation
- **Signing Result**: Digital signature embedded in executable

**4.4.2.2 Executable Signing Script**
- **Script**: `scripts/sign_windows.ps1` (PowerShell) or `scripts/sign_windows.bat` (batch)
- **Functionality**:
  - Import certificate (if needed)
  - Sign executable with signtool
  - Verify signature
  - Report signing status
- **Script Structure**:
  1. Validate inputs
  2. Import certificate (if not already imported)
  3. Sign executable
  4. Verify signature
  5. Report results
- **Error Handling**:
  - Fail on signing error
  - Report which file failed
  - Provide troubleshooting guidance
  - Clear error messages

**4.4.2.3 Executable Signing Verification**
- **Verification Command**:
  ```powershell
  signtool verify /pa /v CuePoint.exe
  ```
- **Verification Options**:
  - `/pa`: Verify all signatures (including nested)
  - `/v`: Verbose output
  - `/tw`: Warn if timestamp is missing
- **Verification Checks**:
  - Signature valid
  - Certificate chain valid
  - Timestamp present and valid
  - Publisher name matches expected
  - No errors or warnings
- **Verification Script**: `scripts/validate_signing.py` (enhanced for Windows)
- **Verification Timing**: After signing, before installer creation

**4.4.2.4 Certificate Store vs File-Based Signing**
- **Certificate Store Method**:
  - **Advantage**: Certificate stored securely in Windows certificate store
  - **Usage**: Import certificate to store, use thumbprint
  - **Command**: `signtool sign /sha1 thumbprint /tr ... /td SHA256 /fd SHA256 file.exe`
  - **Security**: Certificate protected by Windows certificate store
- **File-Based Method**:
  - **Advantage**: Simpler for CI/CD, no certificate store management
  - **Usage**: Use certificate file directly
  - **Command**: `signtool sign /f certificate.pfx /p password /tr ... /td SHA256 /fd SHA256 file.exe`
  - **Security**: Certificate file must be protected
- **Recommendation**: File-based for CI/CD (simpler), certificate store for local development

### Task 4.4.3: Implement Installer Signing

**What to Build**
- Installer signing procedure
- Installer signing script
- Installer signing verification
- Error handling
- Signing automation

**Implementation Details**

**4.4.3.1 Installer Signing Procedure**
- **Signing Command**:
  ```powershell
  signtool sign /f certificate.pfx /p password /tr http://timestamp.digicert.com /td SHA256 /fd SHA256 /v CuePoint-Setup-v1.0.0.exe
  ```
- **Signing Options**: Same as executable signing
- **Signing Location**: After installer creation, before distribution
- **Signing Result**: Digital signature embedded in installer
- **Important**: Installer must be signed separately from executable
  - **Rationale**: Installer is a separate executable
  - **Requirement**: Both executable and installer must be signed
  - **Impact**: SmartScreen checks both signatures

**4.4.3.2 Installer Signing Script**
- **Script**: `scripts/sign_windows.ps1` (enhanced to handle both)
- **Functionality**:
  - Sign installer with signtool
  - Verify installer signature
  - Report signing status
- **Script Enhancement**: Support both executable and installer signing
- **Error Handling**: Same as executable signing

**4.4.3.3 Installer Signing Verification**
- **Verification Command**:
  ```powershell
  signtool verify /pa /v CuePoint-Setup-v1.0.0.exe
  ```
- **Verification Checks**: Same as executable verification
- **Verification Timing**: After installer signing, before distribution

### Task 4.4.4: Implement Signing Verification

**What to Build**
- Comprehensive verification procedures
- Verification scripts
- Verification automation
- Verification reporting
- Failure diagnostics

**Implementation Details**

**4.4.4.1 Signature Verification Procedures**
- **Individual File Verification**:
  - Verify executable signature
  - Verify installer signature
  - Check signing identity
  - Check timestamp
  - Check certificate validity
- **Comprehensive Verification**:
  - Verify all signed files
  - Check signature consistency
  - Verify no unsigned files that should be signed
  - Check certificate chain
- **SmartScreen Readiness**:
  - Verify signatures are valid
  - Verify timestamps present
  - Verify publisher name correct
  - Check for common SmartScreen blockers

**4.4.4.2 Verification Scripts**
- **Script**: `scripts/validate_signing.py` (enhanced for Windows)
- **Functionality**:
  - Verify executable signature
  - Verify installer signature
  - Check signing identity
  - Verify timestamp
  - Generate verification report
- **Verification Commands**:
  - `signtool verify /pa /v` (signature verification)
  - `signtool verify /pa /v /tw` (with timestamp warning)
  - Certificate store inspection
- **Output**: Detailed verification report

**4.4.4.3 Verification Automation**
- **Automation Points**:
  - After executable signing
  - After installer signing
  - Before distribution
  - In CI/CD pipeline
- **CI Integration**: Automatic verification in build workflow
- **Failure Handling**: Build fails if verification fails
- **Reporting**: Verification results in build logs

**4.4.4.4 Verification Reporting**
- **Report Format**: Human-readable and machine-parseable
- **Report Content**:
  - Signing status (success/failure)
  - Signing identity
  - Timestamp status
  - Certificate validity
  - Publisher name
  - Any warnings or errors
- **Report Location**: Build logs, artifact metadata
- **Report Usage**: Debugging, compliance, documentation

**4.4.4.5 Failure Diagnostics**
- **Diagnostic Information**:
  - Which file failed to sign
  - Signing error message
  - Certificate status
  - Certificate store status
  - Identity availability
  - File permissions
- **Diagnostic Commands**:
  - `signtool verify /pa /v` (signature details)
  - Certificate store inspection
  - File properties inspection
- **Troubleshooting Guide**: Document common issues and solutions

### Task 4.4.5: Implement Certificate Import and Management

**What to Build**
- Certificate import automation
- Certificate store management
- Certificate validation
- Certificate cleanup
- Certificate security

**Implementation Details**

**4.4.5.1 Certificate Import Process**
- **Import Script**: `scripts/import_windows_cert.ps1`
- **Import Steps**:
  1. Decode base64 certificate (if encoded)
  2. Import certificate to certificate store (if using store method)
  3. Verify certificate import
  4. Clean up certificate file
- **Import Command (Store Method)**:
  ```powershell
  Import-PfxCertificate -FilePath certificate.pfx -CertStoreLocation Cert:\CurrentUser\My -Password (ConvertTo-SecureString -String $password -AsPlainText -Force)
  ```
- **Import Command (File Method)**:
  - No import needed, use certificate file directly
  - Ensure certificate file is accessible
  - Protect certificate file permissions
- **Certificate Store Location**:
  - **Current User**: `Cert:\CurrentUser\My` (per-user)
  - **Local Machine**: `Cert:\LocalMachine\My` (system-wide, requires admin)
  - **Recommendation**: Current User for CI/CD (no admin required)

**4.4.5.2 Certificate Store Management**
- **Certificate Store**: Windows certificate store
- **Store Location**: Current User Personal store (recommended)
- **Certificate Access**: Accessible to signtool
- **Certificate Cleanup**: Remove after build (if temporary)
- **Certificate Security**: Protected by Windows certificate store

**4.4.5.3 Certificate Validation**
- **Validation Checks**:
  - Certificate exists in store or file accessible
  - Certificate type correct (Code Signing)
  - Certificate not expired
  - Certificate identity matches expected
  - Certificate accessible to signtool
- **Validation Commands**:
  ```powershell
  Get-ChildItem Cert:\CurrentUser\My | Where-Object {$_.Subject -like "*Code Signing*"}
  ```
- **Validation Script**: `scripts/validate_certificate.py` (Windows version)
- **Validation Timing**: Before signing, after import

**4.4.5.4 Certificate Cleanup**
- **Cleanup Steps**:
  1. Remove certificate from store (if temporary)
  2. Remove certificate file (if temporary)
  3. Clear environment variables (if set)
  4. Log cleanup actions
- **Cleanup Timing**: After signing, after verification
- **Cleanup Security**: Ensure no certificate data remains
- **Cleanup Verification**: Verify cleanup completed

**4.4.5.5 Certificate Security**
- **Security Principles**:
  - Never commit certificates to repository
  - Store only in GitHub Secrets
  - Use secure certificate storage
  - Clean up after use
  - Rotate regularly
  - Monitor for compromise
- **Security Measures**:
  - Base64 encoding for storage (if text)
  - Encrypted storage (GitHub Secrets)
  - Secure certificate file handling
  - Automatic cleanup
  - Access logging
  - Regular rotation

### Task 4.4.6: Implement Signing Error Handling

**What to Build**
- Error detection and classification
- Error recovery procedures
- Error reporting and logging
- Error prevention measures
- Troubleshooting documentation

**Implementation Details**

**4.4.6.1 Error Detection and Classification**
- **Error Types**:
  - **Certificate Errors**: Missing, expired, wrong type
  - **Signing Errors**: Failed to sign, invalid identity
  - **Verification Errors**: Signature invalid, identity mismatch
  - **Permission Errors**: File permissions, certificate store access
  - **System Errors**: Certificate store issues, system problems
- **Error Detection**:
  - Check command exit codes
  - Parse error messages
  - Verify expected outputs
  - Validate intermediate states
- **Error Classification**:
  - **Critical**: Blocks signing, must fix
  - **Warning**: May cause issues, should fix
  - **Info**: Informational, no action needed

**4.4.6.2 Error Recovery Procedures**
- **Certificate Errors**:
  - Check certificate availability
  - Verify certificate validity
  - Re-import certificate if needed
  - Update certificate if expired
- **Signing Errors**:
  - Retry signing (transient errors)
  - Check file permissions
  - Verify identity availability
  - Review signing command
- **Verification Errors**:
  - Re-sign if needed
  - Check signing command
  - Verify certificate
  - Review error messages
- **Recovery Automation**: Automatic retry for transient errors
- **Manual Intervention**: Clear error messages for manual fixes

**4.4.6.3 Error Reporting and Logging**
- **Logging Requirements**:
  - All signing commands logged
  - All errors logged with context
  - All warnings logged
  - Signing summary logged
- **Error Messages**:
  - Clear and actionable
  - Include error context
  - Suggest solutions
  - Reference documentation
- **Error Reporting**:
  - Console output
  - Build logs
  - Error artifacts (if applicable)
  - Notification (on failure)

**4.4.6.4 Error Prevention Measures**
- **Pre-Signing Validation**:
  - Validate certificate before signing
  - Check file permissions
  - Verify identity availability
  - Validate file structure
- **Signing Best Practices**:
  - Use timestamp servers
  - Use SHA256 digest
  - Verify after signing
  - Use proper certificate
- **Post-Signing Validation**:
  - Verify all signatures
  - Check SmartScreen readiness
  - Validate for distribution
  - Comprehensive testing

**4.4.6.5 Troubleshooting Documentation**
- **Troubleshooting Guide**: `DOCS/TROUBLESHOOTING/Windows_Signing_Issues.md`
- **Common Issues**:
  - Certificate not found
  - Signing identity invalid
  - Timestamp server unavailable
  - SmartScreen warnings
  - Signature verification failures
- **Solutions**: Step-by-step solutions for each issue
- **Diagnostic Commands**: Commands to diagnose issues
- **Support**: Contact information for help

### Task 4.4.7: Implement CI/CD Integration

**What to Build**
- GitHub Actions workflow integration
- Signing automation in CI
- Certificate import in CI
- Verification in CI
- Error handling in CI

**Implementation Details**

**4.4.7.1 Workflow Integration**
- **Workflow File**: `.github/workflows/build-windows.yml`
- **Signing Steps**:
  1. Import certificate (if using store method)
  2. Sign executable
  3. Verify executable signing
  4. Build installer
  5. Sign installer
  6. Verify installer signing
- **Conditional Execution**: Only on version tags
- **Error Handling**: Fail workflow on signing failure
- **Artifact Upload**: Upload signed executable and installer

**4.4.7.2 Certificate Import in CI**
- **Import Step**: Before signing
- **Certificate Source**: GitHub Secrets
- **Import Script**: `scripts/import_windows_cert.ps1`
- **Environment Variables**:
  - `WINDOWS_SIGNING_CERT_PFX`: Base64 certificate (if encoded)
  - `WINDOWS_SIGNING_CERT_PASSWORD`: Certificate password
- **Certificate Store Management**: Current User store (no admin required)
- **Cleanup**: Automatic cleanup after build

**4.4.7.3 Signing Automation in CI**
- **Signing Step**: After executable build, after installer creation
- **Signing Script**: `scripts/sign_windows.ps1`
- **Identity Source**: Environment variable or script parameter
- **Signing Options**: Timestamp, SHA256, verbose
- **Verification**: Automatic after signing
- **Failure Handling**: Workflow fails on signing failure

**4.4.7.4 Verification in CI**
- **Verification Steps**:
  - After executable signing
  - After installer signing
  - Before distribution
- **Verification Scripts**:
  - `scripts/validate_signing.py`
  - `signtool verify` commands
- **Failure Handling**: Workflow fails on verification failure

**4.4.7.5 Error Handling in CI**
- **Error Detection**: Check command exit codes
- **Error Reporting**: Clear error messages in logs
- **Error Notification**: Notify on signing failure
- **Error Artifacts**: Save diagnostic information
- **Retry Logic**: Retry transient errors
- **Failure Recovery**: Manual intervention procedures

### Task 4.4.8: Implement Signing Best Practices

**What to Build**
- Signing best practices documentation
- Signing checklist
- Signing validation procedures
- Signing performance optimization
- Signing security hardening

**Implementation Details**

**4.4.8.1 Signing Best Practices**
- **Always Timestamp**: Use timestamp servers for long-term validity
- **Use SHA256**: Use SHA256 digest algorithm (modern, secure)
- **Sign Both**: Sign both executable and installer
- **Verify After Signing**: Always verify signatures after signing
- **Documentation**: Document all signing steps
- **Automation**: Automate all signing steps
- **Certificate Security**: Secure certificate storage and handling
- **Regular Rotation**: Rotate certificates regularly

**4.4.8.2 Signing Checklist**
- **Pre-Signing**:
  - [ ] Certificate valid and not expired
  - [ ] Certificate imported or accessible
  - [ ] Signing identity verified
  - [ ] Executable/installer structure correct
  - [ ] All files present
- **Signing**:
  - [ ] Executable signed
  - [ ] Installer signed
  - [ ] Timestamps added
  - [ ] SHA256 digest used
- **Post-Signing**:
  - [ ] All signatures verified
  - [ ] Signing identity correct
  - [ ] Timestamps present
  - [ ] Ready for distribution

**4.4.8.3 Signing Validation Procedures**
- **Validation Levels**:
  - **Basic**: Signature exists and is valid
  - **Standard**: Basic + identity verification
  - **Strict**: Standard + timestamp verification
  - **Comprehensive**: Strict + SmartScreen readiness
- **Validation Frequency**:
  - After each signing step
  - Before distribution
  - Before release
  - After release
- **Validation Automation**: Automated in CI/CD

**4.4.8.4 Signing Performance Optimization**
- **Parallel Signing**: Sign executable and installer in parallel (if possible)
- **Caching**: Cache signing results where possible
- **Optimization Trade-offs**: Balance speed vs. reliability
- **Performance Monitoring**: Track signing times

**4.4.8.5 Signing Security Hardening**
- **Certificate Security**: Secure storage and handling
- **Identity Verification**: Verify identity before signing
- **Signature Verification**: Verify after signing
- **Audit Logging**: Log all signing operations
- **Access Control**: Limit who can trigger signing
- **Rotation**: Regular certificate rotation

## Implementation Checklist

### Signing Architecture
- [ ] Define signing process architecture
- [ ] Define signing order
- [ ] Define certificate management
- [ ] Define timestamp server configuration
- [ ] Create signing automation framework

### Executable Signing
- [ ] Implement executable signing procedure
- [ ] Create executable signing script
- [ ] Implement executable verification
- [ ] Create error handling

### Installer Signing
- [ ] Implement installer signing procedure
- [ ] Create installer signing script
- [ ] Implement installer verification
- [ ] Create error handling

### Signing Verification
- [ ] Create verification procedures
- [ ] Create verification scripts
- [ ] Automate verification
- [ ] Create verification reporting
- [ ] Create failure diagnostics

### Certificate Management
- [ ] Implement certificate import
- [ ] Implement certificate store management
- [ ] Create certificate validation
- [ ] Implement certificate cleanup
- [ ] Implement certificate security

### Error Handling
- [ ] Implement error detection
- [ ] Create error recovery procedures
- [ ] Implement error reporting
- [ ] Create error prevention measures
- [ ] Create troubleshooting documentation

### CI/CD Integration
- [ ] Integrate with GitHub Actions
- [ ] Automate certificate import
- [ ] Automate signing
- [ ] Automate verification
- [ ] Implement error handling

### Best Practices
- [ ] Document best practices
- [ ] Create signing checklist
- [ ] Create validation procedures
- [ ] Optimize performance
- [ ] Harden security

## Files to Create/Modify

### New Files
1. `DOCS/DESIGNS/SHIP v1.0/Step_4_Windows_Packaging/4.4_Signing.md` - This document
2. `scripts/import_windows_cert.ps1` - Certificate import script
3. `DOCS/TROUBLESHOOTING/Windows_Signing_Issues.md` - Troubleshooting guide

### Files to Modify
1. `scripts/sign_windows.ps1` - Enhanced signing script
2. `scripts/validate_signing.py` - Enhanced verification (Windows)
3. `.github/workflows/build-windows.yml` - Signing integration
4. `DOCS/DESIGNS/SHIP v1.0/Step_4_Windows_Packaging/README.md` - Add reference

## Implementation Dependencies

### Prerequisites
- Step 2: Build System (provides infrastructure)
- Step 4.2: Build Output (executable structure)
- Step 4.3: App Identity (publisher identity)
- Code signing certificate

### Enables
- Step 4.5: Installer Behavior (requires signed installer)
- Step 5: Auto-Update (requires signed executable)

## Success Criteria

### Signing
- ✅ All executables properly signed
- ✅ Signing identity correct
- ✅ Timestamps present
- ✅ All signatures verified

### Verification
- ✅ All verification passes
- ✅ Ready for distribution
- ✅ No signing errors

### Automation
- ✅ Fully automated signing
- ✅ CI/CD integration complete
- ✅ Error handling robust
- ✅ Documentation complete

## Next Implementation Steps

After completing Step 4.4:
1. **Step 4.5**: Installer Behavior (implements installer functionality)
2. **Step 4.6**: Update Compatibility (ensures update system works)

## Detailed Implementation Guidance

### Signing Script Example

**Enhanced Signing Script** (`scripts/sign_windows.ps1`):
```powershell
# Enhanced Windows signing script

param(
    [Parameter(Mandatory=$true)]
    [string]$FilePath,
    
    [Parameter(Mandatory=$false)]
    [string]$CertificatePath = $env:WINDOWS_SIGNING_CERT_PFX,
    
    [Parameter(Mandatory=$false)]
    [string]$CertificatePassword = $env:WINDOWS_SIGNING_CERT_PASSWORD,
    
    [Parameter(Mandatory=$false)]
    [string]$TimestampServer = "http://timestamp.digicert.com"
)

if (-not (Test-Path $FilePath)) {
    Write-Error "File not found: $FilePath"
    exit 1
}

if (-not $CertificatePath -or -not (Test-Path $CertificatePath)) {
    Write-Error "Certificate not found: $CertificatePath"
    exit 1
}

Write-Host "=========================================="
Write-Host "Signing Windows Executable"
Write-Host "=========================================="
Write-Host "File: $FilePath"
Write-Host "Certificate: $CertificatePath"
Write-Host ""

# Sign the file
Write-Host "Signing file..."
$signArgs = @(
    "sign",
    "/f", $CertificatePath,
    "/p", $CertificatePassword,
    "/tr", $TimestampServer,
    "/td", "SHA256",
    "/fd", "SHA256",
    "/v",
    $FilePath
)

& signtool $signArgs
if ($LASTEXITCODE -ne 0) {
    Write-Error "Signing failed"
    exit 1
}

Write-Host "✓ File signed successfully"
Write-Host ""

# Verify signature
Write-Host "Verifying signature..."
$verifyArgs = @(
    "verify",
    "/pa",
    "/v",
    $FilePath
)

& signtool $verifyArgs
if ($LASTEXITCODE -ne 0) {
    Write-Error "Signature verification failed"
    exit 1
}

Write-Host "✓ Signature verified"
Write-Host ""
Write-Host "=========================================="
Write-Host "Signing complete"
Write-Host "=========================================="
```

### Verification Script Example

**Comprehensive Verification**:
```powershell
# Comprehensive signing verification

param(
    [Parameter(Mandatory=$true)]
    [string]$FilePath
)

Write-Host "Verifying signature for: $FilePath"
Write-Host ""

# Verify signature
Write-Host "1. Verifying signature..."
& signtool verify /pa /v $FilePath
if ($LASTEXITCODE -ne 0) {
    Write-Error "Signature verification failed"
    exit 1
}

# Check timestamp
Write-Host "2. Checking timestamp..."
& signtool verify /pa /v /tw $FilePath
if ($LASTEXITCODE -ne 0) {
    Write-Warning "Timestamp check failed or missing"
}

# Get signature details
Write-Host "3. Getting signature details..."
$details = & signtool verify /pa /v $FilePath 2>&1
Write-Host $details

Write-Host ""
Write-Host "✓ Verification complete"
```

## References

- Main document: `../04_Windows_Packaging_Signing.md`
- Related: Step 4.3 (App Identity), Step 4.5 (Installer Behavior)
- Windows Code Signing: https://docs.microsoft.com/en-us/windows/win32/seccrypto/cryptography-tools
- signtool Documentation: https://docs.microsoft.com/en-us/windows/win32/seccrypto/signtool
- SmartScreen Documentation: https://docs.microsoft.com/en-us/windows/security/threat-protection/microsoft-defender-smartscreen/microsoft-defender-smartscreen-overview



