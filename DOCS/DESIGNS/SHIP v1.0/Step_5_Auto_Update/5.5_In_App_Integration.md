# Implementation Step 5.5: In-App Update Integration

## Implementation Overview
**What We're Building**: A comprehensive in-app update integration system that implements update checking logic, version comparison, update notification UI, user preference management, state persistence, and all aspects of integrating the auto-update system into the CuePoint application. This document defines the complete implementation of update checking, user interface, state management, and user experience for the auto-update feature within the application.

## Implementation Tasks

### Task 5.5.1: Define Update Check Process

**What to Build**
- Update check logic implementation
- Version comparison algorithm
- Feed fetching and parsing
- Update detection logic
- Check scheduling and timing
- Error handling and retry logic

**Implementation Details**

**5.5.1.1 Update Check Flow**
- **Check Trigger Points**:
  1. **App Startup**: Check for updates on app launch (if enabled and not too recent)
  2. **Scheduled Check**: Periodic background checks (daily, weekly, etc.)
  3. **Manual Check**: User-initiated check via menu or settings
  4. **Post-Update Check**: Check after successful update installation
- **Check Process Flow**:
  1. **Pre-Check Validation**:
     - Verify network connectivity
     - Check if check is needed (not too recent, not disabled)
     - Check if update check is allowed (user preferences)
  2. **Feed Fetching**:
     - Construct feed URL based on platform and channel
     - Fetch appcast XML from feed URL
     - Handle network errors, timeouts, SSL errors
     - Validate feed accessibility
  3. **Feed Parsing**:
     - Parse XML feed
     - Extract update items
     - Validate feed structure
     - Handle parsing errors
  4. **Version Comparison**:
     - Get current app version
     - Get latest version from feed
     - Compare versions using semantic versioning
     - Filter pre-release versions (if not on beta channel)
     - Check if version is ignored
  5. **Update Detection**:
     - If newer version found and not ignored:
       - Store update information
       - Trigger update notification
       - Update last check timestamp
     - If no update or version ignored:
       - Update last check timestamp
       - Log check result
  6. **Post-Check Actions**:
     - Save last check timestamp
     - Save check result
     - Schedule next check (if periodic)
     - Handle errors appropriately
- **Check Frequency Management**:
  - **On Startup**: Check once per app launch (if enabled)
  - **Periodic**: Check at configured interval (daily, weekly, etc.)
  - **Minimum Interval**: Don't check more than once per hour (even if multiple triggers)
  - **User Preference**: Respect user's check frequency setting
- **Background Execution**:
  - **Threading**: Update checks run in background thread
  - **Non-Blocking**: Checks don't block main UI thread
  - **Cancellation**: Checks can be cancelled if app closes
  - **Resource Management**: Minimal resource usage during checks

**5.5.1.2 Version Comparison Logic**
- **Semantic Versioning**: Use semantic versioning (SemVer) for version comparison
- **Version Format**: `X.Y.Z` where X=major, Y=minor, Z=patch
- **Comparison Algorithm**:
  ```python
  def compare_versions(version1, version2):
      """Compare two semantic versions.
      Returns: -1 if version1 < version2, 0 if equal, 1 if version1 > version2
      """
      v1_parts = [int(x) for x in version1.split('.')]
      v2_parts = [int(x) for x in version2.split('.')]
      
      # Compare major, minor, patch
      for i in range(3):
          if v1_parts[i] < v2_parts[i]:
              return -1
          elif v1_parts[i] > v2_parts[i]:
              return 1
      return 0
  ```
- **Pre-Release Version Handling**:
  - **Stable Channel**: Skip pre-release versions (e.g., "1.0.1-beta.1")
  - **Beta Channel**: Include pre-release versions
  - **Detection**: Check for pre-release identifiers in version string
  - **Filtering**: Filter items based on channel and version type
- **Version Ignoring**:
  - **User Action**: User can click "Skip this version"
  - **Storage**: Store ignored versions in preferences
  - **Checking**: Skip ignored versions during comparison
  - **Persistence**: Ignored versions persist across app restarts
  - **Expiration**: Optional expiration for ignored versions (e.g., after 30 days)
- **Version Gap Handling**:
  - **Large Gaps**: Handle updates from very old versions (e.g., v1.0.0 → v2.0.0)
  - **Migration**: May require data migration for major version updates
  - **Compatibility**: Ensure update system works across all version gaps
  - **Testing**: Test updates from various old versions

**5.5.1.3 Feed Fetching and Parsing**
- **Feed URL Construction**:
  - **Base URL**: `https://stuchain.github.io/CuePoint/updates/`
  - **Platform**: `macos` or `windows` (detected at runtime)
  - **Channel**: `stable` or `beta` (from user preferences)
  - **Full URL**: `{base}/{platform}/{channel}/appcast.xml`
- **Network Request**:
  - **HTTP Client**: Use platform-appropriate HTTP client
  - **HTTPS**: Enforce HTTPS (no HTTP fallback)
  - **Timeout**: Set reasonable timeout (e.g., 10 seconds)
  - **Headers**: Set appropriate User-Agent, Accept headers
  - **Caching**: Respect HTTP cache headers (but verify freshness)
  - **Redirects**: Handle HTTP redirects properly
- **Error Handling**:
  - **Network Errors**: No internet, connection timeout, DNS failure
  - **HTTP Errors**: 404 (feed not found), 500 (server error), etc.
  - **SSL Errors**: Certificate validation failures, expired certificates
  - **Parsing Errors**: Malformed XML, invalid structure
  - **Error Recovery**: Retry logic, exponential backoff, user notification
- **Feed Parsing**:
  - **XML Parsing**: Parse RSS 2.0 + Sparkle namespace XML
  - **Item Extraction**: Extract all `<item>` elements
  - **Field Extraction**: Extract version, URL, size, signature, notes
  - **Validation**: Validate extracted fields
  - **Sorting**: Sort items by version (latest first)
- **Caching Strategy**:
  - **Feed Cache**: Cache parsed feed for short period (e.g., 5 minutes)
  - **Cache Invalidation**: Invalidate on manual check or after timeout
  - **Offline Support**: Use cached feed if network unavailable (with warning)

### Task 5.5.2: Define Update UI and User Experience

**What to Build**
- Update dialog design and implementation
- Update notification UI
- Download progress UI
- Installation progress UI
- Error message UI
- User interaction patterns

**Implementation Details**

**5.5.2.1 Update Available Dialog**
- **Dialog Purpose**: Notify user of available update and provide update options
- **Dialog Design**:
  - **Platform-Native**: Use platform-native dialog style (Cocoa on macOS, Win32/WPF on Windows)
  - **Non-Blocking**: Dialog is modal but doesn't block app (user can dismiss)
  - **Professional Appearance**: Clean, branded, matches app design
  - **Clear Information**: Version numbers, release notes, update size clearly displayed
- **Dialog Content**:
  - **Header**: "Update Available" or "CuePoint Update Available"
  - **Version Information**:
     - Current version: "You have version 1.0.0"
     - New version: "Version 1.0.1 is available"
     - Visual indicator: Arrow or "→" between versions
  - **Release Notes Summary**:
     - Brief summary (2-3 sentences)
     - HTML formatted (if supported)
     - Scrollable if long
     - "More details" link to full release notes
  - **Update Size**: Download size (e.g., "50 MB")
  - **Update Type**: Optional indicator (Bug Fix, Feature, Security, etc.)
- **Dialog Actions**:
  - **Primary Action**: "Download & Install" button (prominent)
  - **Secondary Actions**:
     - "Remind me later" button
     - "Skip this version" button
     - "More details" link (opens release notes in browser)
  - **Dismissal**: Dialog can be closed/dismissed (X button or Escape key)
- **Dialog Behavior**:
  - **Appearance**: Show dialog when update detected
  - **Timing**: Show immediately or after short delay (user preference)
  - **Persistence**: Dialog state saved if app closes during update
  - **Accessibility**: Full keyboard navigation, screen reader support
- **Platform-Specific Considerations**:
  - **macOS**: Use NSAlert or custom Cocoa dialog
  - **Windows**: Use MessageBox or custom Win32/WPF dialog
  - **Qt Integration**: Use QMessageBox or custom QDialog (if using Qt)

**5.5.2.2 Download Progress UI**
- **Progress Display**: Show download progress during update download
- **Progress Information**:
  - **Progress Bar**: Visual progress indicator (0-100%)
  - **Download Speed**: Current download speed (e.g., "2.5 MB/s")
  - **Downloaded/Total**: "25 MB / 50 MB downloaded"
  - **Time Remaining**: Estimated time remaining (e.g., "10 seconds remaining")
  - **Status Text**: Current status (e.g., "Downloading update...")
- **Progress Dialog**:
  - **Non-Blocking**: User can minimize or continue using app
  - **Cancellable**: User can cancel download
  - **Minimizable**: Can be minimized to system tray/status bar
  - **Persistent**: Progress persists if app closes (resume on restart)
- **Progress Updates**:
  - **Frequency**: Update progress every 100ms or on significant progress
  - **Smooth Animation**: Smooth progress bar animation
  - **Accurate**: Progress reflects actual download progress
- **Error Handling**:
  - **Network Errors**: Show error, allow retry
  - **Download Failures**: Show error, allow retry or cancel
  - **Cancellation**: Handle user cancellation gracefully

**5.5.2.3 Installation Progress UI**
- **Installation Display**: Show installation progress (platform-specific)
- **macOS Installation**:
  - **Sparkle Handles**: Sparkle shows native installation progress
  - **App Quit**: App quits during installation
  - **Relaunch**: App relaunches automatically after installation
- **Windows Installation**:
  - **Installer UI**: Installer shows its own progress UI
  - **App Quit**: App quits before installer runs
  - **Installer Handles**: Installer handles upgrade process
  - **Relaunch**: Optional auto-relaunch after installation
- **Progress Information** (if custom UI):
  - **Status**: "Installing update..."
  - **Progress**: Installation progress (if available)
  - **Cannot Cancel**: Installation typically cannot be cancelled

**5.5.2.4 Error Message UI**
- **Error Dialog**: Show errors clearly and helpfully
- **Error Types**:
  - **Network Errors**: "Unable to check for updates. Please check your internet connection."
  - **Feed Errors**: "Unable to fetch update information. Please try again later."
  - **Download Errors**: "Download failed. Please try again."
  - **Verification Errors**: "Update verification failed. The update may be corrupted."
  - **Installation Errors**: "Installation failed. Please try downloading the update manually."
- **Error Dialog Content**:
  - **Error Title**: Clear error title
  - **Error Message**: Specific, non-technical error description
  - **Suggested Actions**: What user can do to resolve
  - **Error Code**: Optional error code for support (technical)
  - **Retry Button**: Allow user to retry
  - **Cancel Button**: Allow user to dismiss
- **Error Recovery**:
  - **Automatic Retry**: Retry transient errors automatically
  - **Manual Retry**: User can retry manually
  - **Support Link**: Link to support or documentation
  - **Manual Download**: Option to download manually if automatic fails

### Task 5.5.3: Define Update State Management

**What to Build**
- Update state tracking
- Preference storage
- State persistence
- State recovery
- State synchronization

**Implementation Details**

**5.5.3.1 Update State Tracking**
- **State Variables**:
  - **Last Check Timestamp**: When update was last checked
  - **Check Result**: Result of last check (update available, no update, error)
  - **Available Update**: Information about available update (version, URL, notes)
  - **Ignored Versions**: List of versions user has chosen to skip
  - **Download State**: Current download state (idle, downloading, paused, completed)
  - **Installation State**: Current installation state (idle, installing, completed, failed)
- **State Machine**:
  - **States**: Idle, Checking, Update Available, Downloading, Installing, Error
  - **Transitions**: Well-defined state transitions
  - **State Persistence**: Save state to disk for recovery
  - **State Recovery**: Restore state on app restart
- **State Storage**:
  - **macOS**: Store in `~/Library/Preferences/com.stuchain.cuepoint.plist` or `~/Library/Application Support/CuePoint/update_state.json`
  - **Windows**: Store in `%APPDATA%\CuePoint\update_state.json` or registry
  - **Format**: JSON (preferred) or platform-native format (plist, registry)
  - **Encryption**: Optional encryption for sensitive state (not required for v1.0)

**5.5.3.2 User Preference Management**
- **Preference Storage**:
  - **Location**: Same as state storage
  - **Format**: JSON or platform-native format
  - **Synchronization**: Preferences synced across app instances (if applicable)
- **Update Preferences**:
  - **Check Frequency**: On startup, daily, weekly, monthly, never
  - **Auto-Download**: Download updates automatically (not install) - future feature
  - **Channel**: Stable or beta
  - **Notification Style**: Immediate, delayed, silent
  - **Last Check Override**: Manual override of last check timestamp (for testing)
- **Preference Defaults**:
  - **Check Frequency**: On startup (default)
  - **Channel**: Stable (default)
  - **Auto-Download**: Disabled (default)
  - **Notification Style**: Immediate (default)
- **Preference UI**:
  - **Settings Window**: Update preferences in Settings/Preferences window
  - **UI Components**: Dropdowns, checkboxes, radio buttons
  - **Validation**: Validate preference values
  - **Persistence**: Save preferences immediately on change

**5.5.3.3 State Persistence and Recovery**
- **Persistence Strategy**:
  - **Save Frequency**: Save state after significant changes
  - **Save Triggers**: After check, after download start, after download complete, after error
  - **Atomic Writes**: Write to temporary file, then rename (atomic operation)
  - **Backup**: Keep backup of previous state (for recovery)
- **Recovery Scenarios**:
  - **App Restart During Check**: Resume check or start fresh
  - **App Restart During Download**: Resume download if possible, or restart
  - **App Restart During Installation**: Installation should complete (handled by installer/framework)
  - **State Corruption**: Detect corrupted state, reset to defaults
- **State Validation**:
  - **Format Validation**: Validate state file format
  - **Value Validation**: Validate state values are reasonable
  - **Consistency Check**: Check state consistency
  - **Recovery**: Recover from invalid state

### Task 5.5.4: Define Update Check Scheduling

**What to Build**
- Check scheduling logic
- Timing management
- Frequency configuration
- Background scheduling
- Manual check support

**Implementation Details**

**5.5.4.1 Check Scheduling Logic**
- **Scheduling Triggers**:
  - **On Startup**: Check immediately on app launch (if enabled and not too recent)
  - **Periodic**: Schedule periodic checks based on user preference
  - **Manual**: User-initiated check (always allowed)
  - **Post-Update**: Check after successful update (optional)
- **Timing Rules**:
  - **Minimum Interval**: Don't check more than once per hour (even with multiple triggers)
  - **Recent Check Skip**: Skip check if checked within last hour (configurable)
  - **User Preference**: Respect user's check frequency setting
  - **Network Awareness**: Skip check if network unavailable (with cached result)
- **Scheduling Implementation**:
  - **Timer-Based**: Use platform timer APIs for periodic checks
  - **Event-Based**: Trigger on app events (startup, focus, etc.)
  - **Background Tasks**: Use platform background task APIs (if available)
  - **Threading**: Schedule checks in background thread

**5.5.4.2 Check Frequency Configuration**
- **Frequency Options**:
  - **On Startup Only**: Check only when app launches
  - **Daily**: Check once per day (at app launch or scheduled time)
  - **Weekly**: Check once per week
  - **Monthly**: Check once per month
  - **Never**: Disable automatic checks (manual only)
- **Frequency Implementation**:
  - **Startup Check**: Check on app launch (if enabled)
  - **Scheduled Check**: Schedule next check based on frequency
  - **Time-Based**: Use system time for scheduling
  - **Persistence**: Save next check time, restore on app restart
- **User Configuration**:
  - **Settings UI**: Allow user to change frequency
  - **Immediate Effect**: Changes take effect immediately
  - **Validation**: Validate frequency values

**5.5.4.3 Background Check Management**
- **Background Execution**:
  - **Threading**: Run checks in background thread
  - **Non-Blocking**: Don't block main UI thread
  - **Resource Usage**: Minimize resource usage during checks
  - **Battery Impact**: Minimize battery impact (especially on laptops)
- **Check Cancellation**:
  - **App Close**: Cancel check if app closes
  - **User Cancel**: Allow user to cancel manual check
  - **Timeout**: Cancel check if timeout exceeded
  - **Cleanup**: Clean up resources on cancellation
- **Check Prioritization**:
  - **Manual Check**: Highest priority (user-initiated)
  - **Startup Check**: Medium priority
  - **Periodic Check**: Lower priority (can be delayed)

### Task 5.5.5: Define Menu and Settings Integration

**What to Build**
- Menu integration for update checking
- Settings UI for update preferences
- Update status display
- Manual check trigger
- Update information display

**Implementation Details**

**5.5.5.1 Menu Integration**
- **Menu Location**:
  - **macOS**: Application menu → "Check for Updates..."
  - **Windows**: Help menu → "Check for Updates..."
  - **Keyboard Shortcut**: Standard shortcut (Cmd+U on macOS, Ctrl+U on Windows)
- **Menu Items**:
  - **"Check for Updates..."**: Manual update check
  - **"Update Preferences..."**: Open update preferences (optional)
  - **Update Status**: Show update status in menu (optional, e.g., "Up to date" or "Update available")
- **Menu Behavior**:
  - **Manual Check**: Trigger immediate update check when clicked
  - **Status Update**: Update menu item text based on update status
  - **Disabled State**: Disable menu item during check or download
  - **Platform Guidelines**: Follow platform menu guidelines

**5.5.5.2 Settings UI Integration**
- **Settings Location**: Update preferences in main Settings/Preferences window
- **Settings Section**: "Updates" or "Auto-Update" section
- **Settings Options**:
  - **Check Frequency**: Dropdown with frequency options
  - **Update Channel**: Radio buttons for Stable/Beta
  - **Auto-Download**: Checkbox (future feature)
  - **Last Check Info**: Display last check time and result
  - **Manual Check Button**: "Check Now" button
  - **Update Status**: Display current update status
- **Settings UI Design**:
  - **Clear Labels**: Clear, descriptive labels
  - **Help Text**: Brief help text for each option
  - **Validation**: Validate settings before saving
  - **Immediate Effect**: Settings take effect immediately
  - **Platform Guidelines**: Follow platform settings UI guidelines

**5.5.5.3 Update Status Display**
- **Status Information**:
  - **Current Version**: Display current app version
  - **Update Status**: "Up to date", "Update available", "Checking...", "Error"
  - **Available Version**: Display available version (if update available)
  - **Last Check**: Display last check time
- **Status Location**:
  - **About Dialog**: Show in About dialog
  - **Settings**: Show in Settings window
  - **Status Bar**: Optional status bar indicator (future)
- **Status Updates**:
  - **Real-Time**: Update status in real-time during checks
  - **Persistence**: Persist status across app restarts
  - **Refresh**: Refresh status on manual check

### Task 5.5.6: Define Update Notification Strategy

**What to Build**
- Notification timing and triggers
- Notification content and formatting
- Notification persistence
- Notification dismissal handling
- Notification priority management

**Implementation Details**

**5.5.6.1 Notification Timing**
- **Immediate Notification**: Show immediately when update detected
  - **Use Case**: Manual check, critical updates
  - **User Experience**: Immediate feedback
- **Delayed Notification**: Show after delay (e.g., 5 minutes after app start)
  - **Use Case**: Automatic checks on startup
  - **User Experience**: Less intrusive, allows app to settle
- **Scheduled Notification**: Show at specific time
  - **Use Case**: Periodic checks
  - **User Experience**: Predictable timing
- **User Preference**: Respect user's notification preference

**5.5.6.2 Notification Content**
- **Essential Information**:
  - Current version → New version
  - Release notes summary
  - Download size
  - Update type (if applicable)
- **Optional Information**:
  - Security update indicator
  - Breaking changes warning
  - Estimated update time
  - Update importance level
- **Formatting**:
  - Clear, readable text
  - Proper formatting (HTML if supported)
  - Visual hierarchy
  - Platform-native appearance

**5.5.6.3 Notification Persistence**
- **State Persistence**: Save notification state
- **Dismissal Handling**: Track dismissed notifications
- **Re-notification**: Re-show if user dismissed (after delay)
- **Skip Version**: Track skipped versions
- **Expiration**: Optional expiration for dismissed notifications

### Task 5.5.7: Define Update Installation Coordination

**What to Build**
- Installation coordination logic
- App shutdown handling
- State preservation during installation
- Installation progress coordination
- Post-installation handling

**Implementation Details**

**5.5.7.1 Installation Coordination**
- **Pre-Installation**:
  - Save application state
  - Close open files
  - Prepare for app shutdown
  - Notify user of shutdown
- **App Shutdown**:
  - Graceful shutdown
  - Save unsaved work (if applicable)
  - Close connections
  - Clean up resources
- **Installation**:
  - Framework handles installation
  - Monitor installation progress (if possible)
  - Handle installation errors
- **Post-Installation**:
  - App relaunch
  - State restoration
  - Update verification
  - Success notification

**5.5.7.2 State Preservation**
- **Application State**:
  - Window positions and sizes
  - Open files (if applicable)
  - Current work (if applicable)
  - User preferences
- **Preservation Method**:
  - Save to persistent storage
  - Restore on app relaunch
  - Verify state restoration
- **State Recovery**:
  - Detect state file on launch
  - Restore state
  - Handle state corruption

### Task 5.5.8: Define Update System Monitoring

**What to Build**
- Monitoring architecture
- Metrics collection
- Error tracking
- Performance monitoring
- User analytics

**Implementation Details**

**5.5.8.1 Monitoring Architecture**
- **Metrics Collection**:
  - Update check success/failure
  - Update adoption rates
  - Error rates by type
  - Performance metrics
- **Error Tracking**:
  - Log all errors
  - Categorize errors
  - Track error frequency
  - Alert on critical errors
- **Performance Monitoring**:
  - Track update check time
  - Track download speed
  - Track installation time
  - Monitor resource usage

**5.5.8.2 Analytics Collection** (Optional, with user consent)
- **Update Metrics**:
  - Update check frequency
  - Update adoption rate
  - Update completion rate
  - Error rates
- **User Behavior**:
  - Notification interaction
  - Update deferral patterns
  - Channel preferences
- **Privacy**:
  - User consent required
  - Anonymize data
  - No personal information
  - Opt-out option

### Task 5.5.9: Define Update System Implementation Examples

**What to Build**
- Complete implementation code examples
- Update manager implementation
- Update checker implementation
- Update UI implementation
- Integration examples

**Implementation Details**

**5.5.9.1 Update Manager Implementation Example**
```python
#!/usr/bin/env python3
"""Update manager for CuePoint"""

from pathlib import Path
from typing import Optional, Dict, Any
import json
import threading
from datetime import datetime, timedelta

class UpdateManager:
    """Manages update checking and installation"""
    
    def __init__(self, feed_url: str, current_version: str):
        self.feed_url = feed_url
        self.current_version = current_version
        self.update_available = False
        self.latest_version: Optional[str] = None
        self.update_info: Optional[Dict[str, Any]] = None
        self.last_check: Optional[datetime] = None
        self.checking = False
        self.lock = threading.Lock()
        
    def check_for_updates(self, force: bool = False) -> bool:
        """Check for updates"""
        with self.lock:
            if self.checking:
                return False
            self.checking = True
        
        try:
            # Check if check is needed
            if not force and self._recently_checked():
                return False
            
            # Fetch and parse feed
            feed_data = self._fetch_feed()
            if not feed_data:
                return False
            
            # Compare versions
            latest = self._get_latest_version(feed_data)
            if latest and self._is_newer(latest['version'], self.current_version):
                self.update_available = True
                self.latest_version = latest['version']
                self.update_info = latest
                self.last_check = datetime.now()
                return True
            else:
                self.update_available = False
                self.last_check = datetime.now()
                return False
        finally:
            with self.lock:
                self.checking = False
    
    def _recently_checked(self) -> bool:
        """Check if recently checked"""
        if not self.last_check:
            return False
        return (datetime.now() - self.last_check) < timedelta(hours=1)
    
    def _fetch_feed(self) -> Optional[Dict]:
        """Fetch update feed"""
        # Implementation: HTTP request to feed URL
        # Parse XML feed
        # Return parsed data
        pass
    
    def _get_latest_version(self, feed_data: Dict) -> Optional[Dict]:
        """Get latest version from feed"""
        # Implementation: Extract latest item from feed
        pass
    
    def _is_newer(self, version1: str, version2: str) -> bool:
        """Compare versions"""
        # Implementation: Semantic version comparison
        pass
```

**5.5.9.2 Update UI Implementation Example**
```python
#!/usr/bin/env python3
"""Update UI for CuePoint"""

from PySide6.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton, QTextBrowser
from PySide6.QtCore import Qt

class UpdateDialog(QDialog):
    """Update available dialog"""
    
    def __init__(self, current_version: str, new_version: str, release_notes: str, parent=None):
        super().__init__(parent)
        self.current_version = current_version
        self.new_version = new_version
        self.release_notes = release_notes
        self.init_ui()
    
    def init_ui(self):
        """Initialize UI"""
        self.setWindowTitle("Update Available")
        self.setModal(True)
        
        layout = QVBoxLayout()
        
        # Title
        title = QLabel(f"Update Available: {self.current_version} → {self.new_version}")
        title.setStyleSheet("font-size: 16px; font-weight: bold;")
        layout.addWidget(title)
        
        # Release notes
        notes_label = QLabel("What's New:")
        layout.addWidget(notes_label)
        
        notes_browser = QTextBrowser()
        notes_browser.setHtml(self.release_notes)
        notes_browser.setMaximumHeight(200)
        layout.addWidget(notes_browser)
        
        # Buttons
        button_layout = QVBoxLayout()
        
        install_btn = QPushButton("Download & Install")
        install_btn.setDefault(True)
        install_btn.clicked.connect(self.accept)
        button_layout.addWidget(install_btn)
        
        later_btn = QPushButton("Remind me later")
        later_btn.clicked.connect(self.reject)
        button_layout.addWidget(later_btn)
        
        skip_btn = QPushButton("Skip this version")
        skip_btn.clicked.connect(self.skip_version)
        button_layout.addWidget(skip_btn)
        
        layout.addLayout(button_layout)
        self.setLayout(layout)
    
    def skip_version(self):
        """Skip this version"""
        # Implementation: Mark version as skipped
        self.reject()
```

## Implementation Summary

### Update Check Process
- ✅ Comprehensive check flow defined
- ✅ Version comparison logic specified
- ✅ Feed fetching and parsing defined
- ✅ Error handling implemented
- ✅ Check scheduling and timing

### Update UI
- ✅ Update dialog design specified
- ✅ Progress UI defined
- ✅ Error UI defined
- ✅ Platform-native UI guidelines
- ✅ Notification strategy

### State Management
- ✅ State tracking defined
- ✅ Preference management specified
- ✅ State persistence implemented
- ✅ Recovery procedures defined
- ✅ State synchronization

### Scheduling
- ✅ Check scheduling logic defined
- ✅ Frequency configuration specified
- ✅ Background management implemented
- ✅ Timing optimization

### Integration
- ✅ Menu integration specified
- ✅ Settings UI defined
- ✅ Status display implemented
- ✅ Installation coordination
- ✅ Monitoring architecture

## Files to Create/Modify

### New Files
1. `SRC/cuepoint/update/update_manager.py` - Main update manager
2. `SRC/cuepoint/update/update_checker.py` - Update checking logic
3. `SRC/cuepoint/update/update_ui.py` - Update UI components
4. `SRC/cuepoint/update/version_comparator.py` - Version comparison logic
5. `SRC/cuepoint/update/preferences.py` - Update preferences management
6. `SRC/cuepoint/update/notification_manager.py` - Notification management

### Files to Modify
1. `SRC/cuepoint/ui/main_window.py` - Add update menu items
2. `SRC/cuepoint/ui/settings_window.py` - Add update preferences UI
3. Application initialization code - Initialize update system
4. Application shutdown code - Handle update installation

## Implementation Dependencies

### Prerequisites
- Step 2: Build System (provides versioning)
- Step 3: macOS Packaging (for Sparkle integration)
- Step 4: Windows Packaging (for WinSparkle integration)
- Step 5.4: Update Metadata (provides feed structure)

### Framework Dependencies
- Sparkle framework (macOS)
- WinSparkle library (Windows)
- Network libraries
- UI framework (Qt/PySide6)

## Next Implementation Steps

After completing Step 5.5:
1. **Step 5.6**: macOS Flow (implements Sparkle integration)
2. **Step 5.7**: Windows Flow (implements WinSparkle integration)
3. **Step 5.8**: Security Model (implements security requirements)

## References

- Main document: `../05_Auto_Update_System.md`
- Sparkle Documentation: https://sparkle-project.org/documentation/
- WinSparkle Documentation: https://github.com/vslavik/winsparkle
- Semantic Versioning: https://semver.org/
- Qt Documentation: https://www.qt.io/docs/
