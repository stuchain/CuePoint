# Implementation Step 9.5: Support UX

## Implementation Overview
**What We're Building**: A comprehensive support user experience system that empowers users to get help, report issues, access diagnostics, and find solutions independently. This includes support bundle generation and export, issue reporting workflows with GitHub integration, diagnostic information collection and display, help system integration, log viewing capabilities, and "Open Folder" actions for common locations. The support UX system reduces support burden, enables efficient issue resolution, provides transparency about application state, and creates a professional support experience that builds user trust and confidence.

## Implementation Tasks

### Task 9.5.1: Implement Support Bundle Generation and Export

**What to Build**
- Enhanced support bundle generation system
- Support bundle export dialog
- Support bundle content organization
- Support bundle sanitization and privacy
- Support bundle sharing mechanisms
- Support bundle documentation

**Implementation Details**

**9.5.1.1 Support Bundle Generation Enhancement**
- **Purpose**: Enhance the existing support bundle generator to include comprehensive diagnostics, logs, configuration, and system information in a user-friendly format that can be easily shared with support.
- **Rationale**:
  - Support bundles enable efficient issue diagnosis
  - Comprehensive information reduces back-and-forth
  - Easy export and sharing improves user experience
  - Sanitized bundles protect user privacy
  - Well-organized bundles speed up support resolution
- **Implementation Location**: `SRC/cuepoint/utils/support_bundle.py` (enhance existing), `SRC/cuepoint/ui/dialogs/support_dialog.py` (new)
- **Support Bundle Contents**:
  ```
  Support Bundle Structure:
  cuepoint-support-YYYYMMDD-HHMMSS.zip
  ├── README.txt                    # Instructions and overview
  ├── diagnostics.json              # System and app diagnostics
  ├── logs/
  │   ├── application.log          # Application logs
  │   ├── error.log                 # Error logs
  │   └── crash.log                 # Crash logs (if any)
  ├── config/
  │   └── config.json               # Configuration (sanitized)
  ├── system/
  │   ├── system_info.json          # System information
  │   └── environment.txt           # Environment variables (sanitized)
  └── metadata.json                 # Bundle metadata
  ```
- **Enhanced Support Bundle Generator**:
  ```python
  from pathlib import Path
  from datetime import datetime
  import json
  import zipfile
  import logging
  from typing import Dict, List, Optional
  
  from cuepoint.utils.diagnostics import DiagnosticCollector
  from cuepoint.utils.paths import AppPaths
  from cuepoint.utils.version import get_version
  
  class SupportBundleGenerator:
      """Enhanced support bundle generator."""
      
      def __init__(self):
          self.diagnostic_collector = DiagnosticCollector()
          self.app_paths = AppPaths()
      
      def generate_bundle(
          self,
          output_path: Optional[Path] = None,
          include_logs: bool = True,
          include_config: bool = True,
          sanitize: bool = True
      ) -> Path:
          """
          Generate comprehensive support bundle.
          
          Args:
              output_path: Directory to save bundle (default: Downloads)
              include_logs: Include log files
              include_config: Include configuration
              sanitize: Sanitize sensitive information
          
          Returns:
              Path to generated bundle file
          """
          if output_path is None:
              output_path = Path.home() / "Downloads"
          
          timestamp = datetime.now().strftime("%Y%m%d-%H%M%S")
          bundle_name = f"cuepoint-support-{timestamp}.zip"
          bundle_path = output_path / bundle_name
          
          with zipfile.ZipFile(bundle_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
              # Add README
              self._add_readme(zipf)
              
              # Add diagnostics
              self._add_diagnostics(zipf, sanitize)
              
              # Add logs
              if include_logs:
                  self._add_logs(zipf, sanitize)
              
              # Add configuration
              if include_config:
                  self._add_config(zipf, sanitize)
              
              # Add system information
              self._add_system_info(zipf, sanitize)
              
              # Add metadata
              self._add_metadata(zipf)
          
          logging.info(f"Support bundle generated: {bundle_path}")
          return bundle_path
      
      def _add_readme(self, zipf: zipfile.ZipFile):
          """Add README file with instructions."""
          readme_content = f"""
  CuePoint Support Bundle
  Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
  
  This bundle contains diagnostic information to help resolve issues with CuePoint.
  
  Contents:
  - diagnostics.json: System and application diagnostics
  - logs/: Application logs
  - config/: Configuration files (sanitized)
  - system/: System information
  
  Privacy:
  - Sensitive information has been sanitized
  - File paths may be partially redacted
  - No personal data is included
  
  How to Use:
  1. Attach this bundle when reporting an issue
  2. Include a description of the problem
  3. Include steps to reproduce (if applicable)
  
  For support, visit: https://github.com/your-repo/cuepoint/issues
  """
          zipf.writestr("README.txt", readme_content)
      
      def _add_diagnostics(self, zipf: zipfile.ZipFile, sanitize: bool):
          """Add diagnostics information."""
          diagnostics = self.diagnostic_collector.collect_all()
          
          if sanitize:
              diagnostics = self._sanitize_diagnostics(diagnostics)
          
          zipf.writestr(
              "diagnostics.json",
              json.dumps(diagnostics, indent=2, default=str)
          )
      
      def _add_logs(self, zipf: zipfile.ZipFile, sanitize: bool):
          """Add log files."""
          logs_dir = self.app_paths.logs_dir()
          
          if not logs_dir.exists():
              return
          
          # Add recent log files
          log_files = sorted(logs_dir.glob("*.log"), key=lambda p: p.stat().st_mtime, reverse=True)
          
          for log_file in log_files[:10]:  # Limit to 10 most recent
              log_content = log_file.read_text(encoding='utf-8', errors='ignore')
              
              if sanitize:
                  log_content = self._sanitize_log_content(log_content)
              
              zipf.writestr(
                  f"logs/{log_file.name}",
                  log_content
              )
      
      def _add_config(self, zipf: zipfile.ZipFile, sanitize: bool):
          """Add configuration files."""
          config_dir = self.app_paths.config_dir()
          
          if not config_dir.exists():
              return
          
          # Add config files (sanitize sensitive data)
          for config_file in config_dir.glob("*.json"):
              config_content = config_file.read_text(encoding='utf-8')
              config_data = json.loads(config_content)
              
              if sanitize:
                  config_data = self._sanitize_config(config_data)
              
              zipf.writestr(
                  f"config/{config_file.name}",
                  json.dumps(config_data, indent=2)
              )
      
      def _add_system_info(self, zipf: zipfile.ZipFile, sanitize: bool):
          """Add system information."""
          import platform
          import sys
          
          system_info = {
              "platform": platform.platform(),
              "system": platform.system(),
              "release": platform.release(),
              "version": platform.version(),
              "machine": platform.machine(),
              "processor": platform.processor(),
              "python_version": sys.version,
              "python_executable": str(sys.executable) if not sanitize else "[REDACTED]",
          }
          
          zipf.writestr(
              "system/system_info.json",
              json.dumps(system_info, indent=2)
          )
      
      def _add_metadata(self, zipf: zipfile.ZipFile):
          """Add bundle metadata."""
          from cuepoint.utils.version import get_version
          
          metadata = {
              "version": get_version(),
              "generated_at": datetime.now().isoformat(),
              "bundle_format_version": "1.0",
          }
          
          zipf.writestr(
              "metadata.json",
              json.dumps(metadata, indent=2)
          )
      
      def _sanitize_diagnostics(self, diagnostics: Dict) -> Dict:
          """Sanitize sensitive information from diagnostics."""
          sanitized = diagnostics.copy()
          
          # Redact file paths (keep structure, redact user names)
          if "paths" in sanitized:
              for key, path in sanitized["paths"].items():
                  if isinstance(path, str):
                      # Replace user home directory with ~
                      home = str(Path.home())
                      if path.startswith(home):
                          sanitized["paths"][key] = path.replace(home, "~")
          
          return sanitized
      
      def _sanitize_log_content(self, content: str) -> str:
          """Sanitize sensitive information from log content."""
          lines = content.split('\n')
          sanitized_lines = []
          
          for line in lines:
              # Redact file paths
              home = str(Path.home())
              if home in line:
                  line = line.replace(home, "~")
              
              sanitized_lines.append(line)
          
          return '\n'.join(sanitized_lines)
      
      def _sanitize_config(self, config: Dict) -> Dict:
          """Sanitize sensitive configuration data."""
          sanitized = config.copy()
          
          # Remove or redact sensitive keys
          sensitive_keys = ["api_key", "token", "password", "secret"]
          for key in sensitive_keys:
              if key in sanitized:
                  sanitized[key] = "[REDACTED]"
          
          return sanitized
  ```
- **Benefits**:
  - Comprehensive diagnostics
  - Easy to share
  - Privacy protection
  - Efficient support resolution
  - Professional support experience

**9.5.1.2 Support Bundle Export Dialog**
- **Purpose**: Create a user-friendly dialog for generating and exporting support bundles with options and clear instructions.
- **Implementation**:
  ```python
  from PySide6.QtWidgets import (
      QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
      QCheckBox, QProgressBar, QTextEdit, QFileDialog
  )
  from PySide6.QtCore import Qt, QThread, Signal
  from pathlib import Path
  
  class SupportBundleDialog(QDialog):
      """Dialog for generating and exporting support bundles."""
      
      def __init__(self, parent=None):
          super().__init__(parent)
          self.bundle_path: Optional[Path] = None
          self._setup_ui()
      
      def _setup_ui(self):
          layout = QVBoxLayout()
          layout.setSpacing(16)
          
          # Title
          title = QLabel("Export Support Bundle")
          title_font = title.font()
          title_font.setPointSize(18)
          title_font.setBold(True)
          title.setFont(title_font)
          layout.addWidget(title)
          
          # Description
          description = QLabel(
              "Generate a support bundle containing diagnostic information, "
              "logs, and configuration to help resolve issues. The bundle can "
              "be attached when reporting issues."
          )
          description.setWordWrap(True)
          layout.addWidget(description)
          
          # Options
          options_label = QLabel("Include in bundle:")
          layout.addWidget(options_label)
          
          self.include_logs_checkbox = QCheckBox("Application logs")
          self.include_logs_checkbox.setChecked(True)
          layout.addWidget(self.include_logs_checkbox)
          
          self.include_config_checkbox = QCheckBox("Configuration files")
          self.include_config_checkbox.setChecked(True)
          layout.addWidget(self.include_config_checkbox)
          
          self.sanitize_checkbox = QCheckBox("Sanitize sensitive information")
          self.sanitize_checkbox.setChecked(True)
          layout.addWidget(self.sanitize_checkbox)
          
          # Progress bar (hidden initially)
          self.progress_bar = QProgressBar()
          self.progress_bar.setVisible(False)
          layout.addWidget(self.progress_bar)
          
          # Status message
          self.status_label = QLabel()
          self.status_label.setVisible(False)
          layout.addWidget(self.status_label)
          
          # Buttons
          button_layout = QHBoxLayout()
          
          cancel_button = QPushButton("Cancel")
          cancel_button.clicked.connect(self.reject)
          button_layout.addWidget(cancel_button)
          
          button_layout.addStretch()
          
          self.generate_button = QPushButton("Generate Bundle")
          self.generate_button.setDefault(True)
          self.generate_button.clicked.connect(self.generate_bundle)
          button_layout.addWidget(self.generate_button)
          
          layout.addLayout(button_layout)
          
          self.setLayout(layout)
          self.setWindowTitle("Export Support Bundle")
          self.resize(500, 400)
      
      def generate_bundle(self):
          """Generate support bundle."""
          self.generate_button.setEnabled(False)
          self.progress_bar.setVisible(True)
          self.progress_bar.setRange(0, 0)  # Indeterminate
          self.status_label.setVisible(True)
          self.status_label.setText("Generating support bundle...")
          
          # Generate bundle in background thread
          generator = SupportBundleGenerator()
          
          try:
              bundle_path = generator.generate_bundle(
                  include_logs=self.include_logs_checkbox.isChecked(),
                  include_config=self.include_config_checkbox.isChecked(),
                  sanitize=self.sanitize_checkbox.isChecked()
              )
              
              self.bundle_path = bundle_path
              self.progress_bar.setVisible(False)
              self.status_label.setText(
                  f"Bundle generated: {bundle_path.name}\n"
                f"Location: {bundle_path.parent}"
              )
              
              # Show success and offer to open location
              from PySide6.QtWidgets import QMessageBox
              msg = QMessageBox(self)
              msg.setIcon(QMessageBox.Information)
              msg.setWindowTitle("Support Bundle Generated")
              msg.setText(f"Support bundle generated successfully:\n{bundle_path.name}")
              msg.setInformativeText(f"Location: {bundle_path.parent}")
              
              open_button = msg.addButton("Open Location", QMessageBox.ActionRole)
              msg.addButton("OK", QMessageBox.AcceptRole)
              
              result = msg.exec()
              
              if msg.clickedButton() == open_button:
                  # Open file location
                  import subprocess
                  import platform
                  
                  if platform.system() == "Windows":
                      subprocess.Popen(f'explorer /select,"{bundle_path}"')
                  elif platform.system() == "Darwin":
                      subprocess.Popen(["open", "-R", str(bundle_path)])
                  else:
                      subprocess.Popen(["xdg-open", str(bundle_path.parent)])
              
              self.accept()
          
          except Exception as e:
              self.progress_bar.setVisible(False)
              self.status_label.setText(f"Error generating bundle: {e}")
              
              from PySide6.QtWidgets import QMessageBox
              QMessageBox.critical(self, "Error", f"Failed to generate support bundle:\n{e}")
          
          finally:
              self.generate_button.setEnabled(True)
      
      def get_bundle_path(self) -> Optional[Path]:
          """Get path to generated bundle."""
          return self.bundle_path
  ```
- **Benefits**:
  - User-friendly interface
  - Clear options
  - Progress feedback
  - Easy access to bundle
  - Professional experience

### Task 9.5.2: Implement Issue Reporting Workflow

**What to Build**
- Issue reporting dialog
- GitHub issue template integration
- Pre-filled issue information
- Issue reporting workflow
- Issue tracking and follow-up

**Implementation Details**

**9.5.2.1 Issue Reporting Dialog**
- **Purpose**: Create a dialog that helps users report issues with pre-filled information and GitHub integration.
- **Implementation**:
  ```python
  from PySide6.QtWidgets import (
      QDialog, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
      QTextEdit, QLineEdit, QComboBox, QCheckBox
  )
  from PySide6.QtCore import Qt, QUrl
  from PySide6.QtGui import QDesktopServices
  from pathlib import Path
  
  class ReportIssueDialog(QDialog):
      """Dialog for reporting issues to GitHub."""
      
      def __init__(self, parent=None):
          super().__init__(parent)
          self._setup_ui()
          self._prefill_info()
      
      def _setup_ui(self):
          layout = QVBoxLayout()
          layout.setSpacing(16)
          
          # Title
          title = QLabel("Report Issue")
          title_font = title.font()
          title_font.setPointSize(18)
          title_font.setBold(True)
          title.setFont(title_font)
          layout.addWidget(title)
          
          # Description
          description = QLabel(
              "Report an issue or bug. This will open GitHub with pre-filled "
              "information to help us resolve the issue quickly."
          )
          description.setWordWrap(True)
          layout.addWidget(description)
          
          # Issue type
          type_label = QLabel("Issue Type:")
          layout.addWidget(type_label)
          
          self.issue_type = QComboBox()
          self.issue_type.addItems([
              "Bug",
              "Feature Request",
              "Question",
              "Other"
          ])
          layout.addWidget(self.issue_type)
          
          # Title
          title_label = QLabel("Title:")
          layout.addWidget(title_label)
          
          self.title_input = QLineEdit()
          self.title_input.setPlaceholderText("Brief description of the issue")
          layout.addWidget(self.title_input)
          
          # Description
          desc_label = QLabel("Description:")
          layout.addWidget(desc_label)
          
          self.description_input = QTextEdit()
          self.description_input.setPlaceholderText(
              "Describe the issue, steps to reproduce, and expected behavior..."
          )
          self.description_input.setMinimumHeight(150)
          layout.addWidget(self.description_input)
          
          # Include support bundle
          self.include_bundle_checkbox = QCheckBox(
              "Generate and attach support bundle"
          )
          self.include_bundle_checkbox.setChecked(True)
          layout.addWidget(self.include_bundle_checkbox)
          
          # Buttons
          button_layout = QHBoxLayout()
          
          cancel_button = QPushButton("Cancel")
          cancel_button.clicked.connect(self.reject)
          button_layout.addWidget(cancel_button)
          
          button_layout.addStretch()
          
          self.report_button = QPushButton("Open GitHub Issue")
          self.report_button.setDefault(True)
          self.report_button.clicked.connect(self.open_github_issue)
          button_layout.addWidget(self.report_button)
          
          layout.addLayout(button_layout)
          
          self.setLayout(layout)
          self.setWindowTitle("Report Issue")
          self.resize(600, 500)
      
      def _prefill_info(self):
          """Pre-fill issue information."""
          from cuepoint.utils.version import get_version
          import platform
          
          version = get_version()
          system = platform.system()
          release = platform.release()
          
          # Pre-fill description with system info
          prefill = f"""**CuePoint Version:** {version}
  **Operating System:** {system} {release}

  **Issue Description:**
  [Describe the issue here]

  **Steps to Reproduce:**
  1. [Step 1]
  2. [Step 2]
  3. [Step 3]

  **Expected Behavior:**
  [What should happen]

  **Actual Behavior:**
  [What actually happens]

  **Additional Information:**
  [Any other relevant information]
  """
          self.description_input.setPlainText(prefill)
      
      def open_github_issue(self):
          """Open GitHub issue page with pre-filled information."""
          from cuepoint.utils.version import get_version
          import platform
          import urllib.parse
          
          # Build issue URL
          repo_url = "https://github.com/your-repo/cuepoint"
          issue_url = f"{repo_url}/issues/new"
          
          # Get form data
          issue_type = self.issue_type.currentText()
          title = self.title_input.text() or "Issue Report"
          description = self.description_input.toPlainText()
          
          # Add system info if not already included
          if "CuePoint Version:" not in description:
              version = get_version()
              system = platform.system()
              release = platform.release()
              description = f"""**CuePoint Version:** {version}
  **Operating System:** {system} {release}

  {description}
  """
          
          # Generate support bundle if requested
          bundle_path = None
          if self.include_bundle_checkbox.isChecked():
              try:
                  generator = SupportBundleGenerator()
                  bundle_path = generator.generate_bundle(sanitize=True)
                  
                  description += f"\n\n**Support Bundle:** {bundle_path.name} (see attached)"
              except Exception as e:
                  description += f"\n\n**Note:** Failed to generate support bundle: {e}"
          
          # URL encode parameters
          params = {
              "title": f"[{issue_type}] {title}",
              "body": description,
              "labels": issue_type.lower().replace(" ", "-")
          }
          
          query_string = urllib.parse.urlencode(params)
          full_url = f"{issue_url}?{query_string}"
          
          # Open in browser
          QDesktopServices.openUrl(QUrl(full_url))
          
          # Show message about support bundle
          if bundle_path:
              from PySide6.QtWidgets import QMessageBox
              msg = QMessageBox(self)
              msg.setIcon(QMessageBox.Information)
              msg.setWindowTitle("Support Bundle Generated")
              msg.setText(
                  "GitHub issue page opened.\n\n"
                  f"Support bundle generated: {bundle_path.name}\n"
                  "Please attach it to the issue."
              )
              msg.exec()
          
          self.accept()
  ```
- **Benefits**:
  - Easy issue reporting
  - Pre-filled information
  - GitHub integration
  - Support bundle attachment
  - Efficient workflow

### Task 9.5.3: Implement Help System Integration

**What to Build**
- Help menu integration
- Help dialog system
- Contextual help access
- User guide integration
- Help content organization

**Implementation Details**

**9.5.3.1 Help Menu Integration**
- **Purpose**: Integrate help features into the application menu bar for easy access.
- **Implementation**:
  ```python
  # In main_window.py
  def _create_help_menu(self):
      """Create Help menu."""
      help_menu = self.menuBar().addMenu("Help")
      
      # User Guide
      user_guide_action = QAction("User Guide", self)
      user_guide_action.setShortcut("F1")
      user_guide_action.triggered.connect(self.show_user_guide)
      help_menu.addAction(user_guide_action)
      
      # Keyboard Shortcuts
      shortcuts_action = QAction("Keyboard Shortcuts", self)
      shortcuts_action.setShortcut("Ctrl+?")
      shortcuts_action.triggered.connect(self.show_shortcuts)
      help_menu.addAction(shortcuts_action)
      
      help_menu.addSeparator()
      
      # Report Issue
      report_issue_action = QAction("Report Issue", self)
      report_issue_action.triggered.connect(self.report_issue)
      help_menu.addAction(report_issue_action)
      
      # Export Support Bundle
      support_bundle_action = QAction("Export Support Bundle...", self)
      support_bundle_action.triggered.connect(self.export_support_bundle)
      help_menu.addAction(support_bundle_action)
      
      help_menu.addSeparator()
      
      # Open Logs Folder
      open_logs_action = QAction("Open Logs Folder", self)
      open_logs_action.triggered.connect(self.open_logs_folder)
      help_menu.addAction(open_logs_action)
      
      # Open Output Folder
      open_output_action = QAction("Open Output Folder", self)
      open_output_action.triggered.connect(self.open_output_folder)
      help_menu.addAction(open_output_action)
      
      help_menu.addSeparator()
      
      # About
      about_action = QAction("About CuePoint", self)
      about_action.triggered.connect(self.show_about)
      help_menu.addAction(about_action)
  
  def open_logs_folder(self):
      """Open logs folder in file manager."""
      from cuepoint.utils.paths import AppPaths
      import subprocess
      import platform
      
      logs_dir = AppPaths.logs_dir()
      logs_dir.mkdir(parents=True, exist_ok=True)
      
      if platform.system() == "Windows":
          subprocess.Popen(f'explorer "{logs_dir}"')
      elif platform.system() == "Darwin":
          subprocess.Popen(["open", str(logs_dir)])
      else:
          subprocess.Popen(["xdg-open", str(logs_dir)])
  
  def open_output_folder(self):
      """Open output folder in file manager."""
      from cuepoint.utils.paths import AppPaths
      import subprocess
      import platform
      
      output_dir = AppPaths.exports_dir()
      output_dir.mkdir(parents=True, exist_ok=True)
      
      if platform.system() == "Windows":
          subprocess.Popen(f'explorer "{output_dir}"')
      elif platform.system() == "Darwin":
          subprocess.Popen(["open", str(output_dir)])
      else:
          subprocess.Popen(["xdg-open", str(output_dir)])
  ```
- **Benefits**:
  - Easy help access
  - Consistent menu structure
  - Quick folder access
  - Professional help system

## Success Criteria

### Support UX Goals
- ✅ Support bundle generation implemented
- ✅ Issue reporting workflow complete
- ✅ Help system integrated
- ✅ Log viewing available
- ✅ Folder access implemented
- ✅ Support UX tested and validated

### Validation Methods
- Support bundle generation testing
- Issue reporting workflow testing
- Help system testing
- User testing
- Support workflow validation

## Implementation Files

### Support Infrastructure
1. `SRC/cuepoint/utils/support_bundle.py` - Support bundle generator (enhance existing)
2. `SRC/cuepoint/ui/dialogs/support_dialog.py` - Support dialog (new)
3. `SRC/cuepoint/ui/dialogs/report_issue_dialog.py` - Issue reporting dialog (new)
4. `SRC/cuepoint/ui/widgets/log_viewer.py` - Log viewer widget (may exist, enhance)

## Dependencies

### Prerequisites
- Step 6: Runtime Operational (provides logging and diagnostics)
- Step 8: Security Privacy Compliance (for sanitization)
- Basic UI components implemented

### Enables
- Efficient support resolution
- Reduced support burden
- Better user experience
- Professional support system
- Issue tracking and resolution

## References

- Support Bundle Best Practices: Industry standard diagnostic collection
- GitHub Issue Templates: https://docs.github.com/en/communities/using-templates-to-encourage-useful-issues-and-pull-requests
