# Implementation Step 9.2: Accessibility

## Implementation Overview
**What We're Building**: A comprehensive accessibility implementation that ensures CuePoint is usable by all users regardless of their abilities, disabilities, or assistive technologies. This includes full keyboard navigation, screen reader support, proper focus management, WCAG contrast compliance, accessible naming and descriptions, and comprehensive accessibility testing. The accessibility implementation transforms CuePoint from a mouse-centric application into a truly accessible application that can be used efficiently with keyboards, screen readers, and other assistive technologies, ensuring compliance with accessibility standards (WCAG 2.1 AA, Section 508) and providing an inclusive user experience.

## Implementation Tasks

### Task 9.2.1: Implement Comprehensive Keyboard Navigation

**What to Build**
- Complete keyboard navigation system
- Logical tab order definition and enforcement
- Keyboard shortcut system and discoverability
- Focus management and visible focus indicators
- Keyboard-only workflow validation
- Accessibility keyboard testing procedures

**Implementation Details**

**9.2.1.1 Tab Order Specification and Implementation**
- **Purpose**: Define and implement a logical, predictable tab order that allows users to navigate all interactive elements using only the keyboard, following a natural reading flow and maintaining context.
- **Rationale**:
  - Keyboard navigation is essential for users who cannot use a mouse
  - Logical tab order improves efficiency and reduces confusion
  - Predictable navigation builds user confidence
  - Tab order must follow visual layout and reading flow
  - Proper tab order is required for accessibility compliance
- **Implementation Location**: `SRC/cuepoint/ui/main_window.py` (enhance existing), `SRC/cuepoint/ui/widgets/focus_manager.py` (new)
- **Tab Order Principles**:
  - **Top-to-Bottom, Left-to-Right**: Follow natural reading flow
  - **Grouping**: Related controls should be grouped together
  - **Context Preservation**: Tab order should maintain context (e.g., form fields in order)
  - **Skip Logic**: Non-interactive elements should be skipped
  - **Modal Dialogs**: Tab order should be constrained within modal dialogs
  - **Dynamic Content**: Tab order should adapt to dynamic content changes
- **Main Window Tab Order Specification**:
  ```
  Tab Order Flow (Main Tab):
  1. Collection XML File Selector (FileSelector widget)
     - File path input field
     - Browse button
     - Info/help button (if present)
  2. Mode Selection (Radio button group)
     - Single mode radio button
     - Batch mode radio button
  3. Playlist Selector (PlaylistSelector widget)
     - Playlist dropdown/combo box
     - Refresh button (if present)
  4. Start Processing Button
  5. Filters Section (Results View)
     - Search input field
     - Status filter dropdown
     - Confidence filter dropdown
     - Year filter (if present)
     - BPM filter (if present)
     - Key filter (if present)
     - Clear filters button
  6. Results Table (ResultsView widget)
     - Table widget (keyboard navigation within table)
     - Column headers (if sortable)
  7. Export Buttons
     - Export CSV button
     - Export JSON button
     - Export All button (if present)
  8. Menu Bar (if keyboard accessible)
     - File menu
     - Edit menu
     - View menu
     - Help menu
  ```
- **Tab Order Implementation**:
  ```python
  from PySide6.QtWidgets import QWidget
  from PySide6.QtCore import Qt
  
  class FocusManager:
      """Manages focus order and keyboard navigation."""
      
      def __init__(self, parent: QWidget):
          self.parent = parent
          self.tab_order: List[QWidget] = []
      
      def set_tab_order(self, widgets: List[QWidget]):
          """Set explicit tab order for widgets."""
          self.tab_order = widgets
          for i in range(len(widgets) - 1):
              self.parent.setTabOrder(widgets[i], widgets[i + 1])
      
      def get_next_focusable(self, current: QWidget) -> Optional[QWidget]:
          """Get next focusable widget in tab order."""
          try:
              index = self.tab_order.index(current)
              if index < len(self.tab_order) - 1:
                  return self.tab_order[index + 1]
          except ValueError:
              pass
          return None
      
      def get_previous_focusable(self, current: QWidget) -> Optional[QWidget]:
          """Get previous focusable widget in tab order."""
          try:
              index = self.tab_order.index(current)
              if index > 0:
                  return self.tab_order[index - 1]
          except ValueError:
              pass
          return None
  
  # In MainWindow.__init__
  def _setup_tab_order(self):
      """Set up logical tab order for main window."""
      focus_manager = FocusManager(self)
      
      # Define tab order widgets
      tab_order = [
          self.file_selector.path_input,      # File path input
          self.file_selector.browse_button,    # Browse button
          self.single_mode_radio,             # Single mode
          self.batch_mode_radio,              # Batch mode
          self.playlist_selector.combo,       # Playlist dropdown
          self.start_button,                  # Start button
          self.results_view.search_input,     # Search input
          self.results_view.status_filter,    # Status filter
          self.results_view.confidence_filter, # Confidence filter
          self.results_view.clear_filters_button, # Clear filters
          self.results_view.table,            # Results table
          self.export_csv_button,              # Export CSV
          self.export_json_button,             # Export JSON
      ]
      
      focus_manager.set_tab_order(tab_order)
  ```
- **Tab Order Validation**:
  - **Manual Testing**: Navigate entire application using only Tab key
  - **Automated Testing**: Verify all interactive elements are reachable
  - **Visual Testing**: Verify tab order matches visual layout
  - **Screen Reader Testing**: Verify screen reader announces elements in correct order
- **Tab Order Best Practices**:
  - Use `setTabOrder()` to explicitly define order
  - Test tab order after layout changes
  - Ensure no focus traps (all elements reachable)
  - Handle dynamic content (add new elements to tab order)
  - Skip non-interactive decorative elements
- **Benefits**:
  - Full keyboard navigation
  - Predictable navigation flow
  - Accessibility compliance
  - Improved efficiency for keyboard users
  - Better screen reader experience

**9.2.1.2 Keyboard Shortcut System Enhancement**
- **Purpose**: Enhance the existing keyboard shortcut system to ensure all shortcuts are discoverable, well-documented, and accessible, with proper conflict detection and user customization support.
- **Rationale**:
  - Keyboard shortcuts improve efficiency for power users
  - Discoverable shortcuts improve learnability
  - Shortcut documentation is essential for accessibility
  - Customizable shortcuts accommodate different user needs
  - Shortcut conflicts must be detected and resolved
- **Implementation Location**: `SRC/cuepoint/ui/widgets/shortcut_manager.py` (enhance existing)
- **Shortcut Specification** (Complete List):
  ```python
  # Global shortcuts (available everywhere)
  GLOBAL_SHORTCUTS = {
      "open_file": ("Ctrl+O", "Cmd+O", "Open XML file"),
      "export_results": ("Ctrl+E", "Cmd+E", "Export results"),
      "quit": ("Ctrl+Q", "Cmd+Q", "Quit application"),
      "help": ("F1", "F1", "Show help"),
      "shortcuts": ("Ctrl+?", "Cmd+?", "Show keyboard shortcuts"),
      "settings": ("Ctrl+,", "Cmd+,", "Open settings"),
      "cancel": ("Esc", "Esc", "Cancel current operation"),
  }
  
  # Main window shortcuts
  MAIN_WINDOW_SHORTCUTS = {
      "start_processing": ("Enter", "Enter", "Start processing (when enabled)"),
      "focus_file_selector": ("Ctrl+Shift+O", "Cmd+Shift+O", "Focus file selector"),
      "focus_playlist": ("Ctrl+Shift+P", "Cmd+Shift+P", "Focus playlist selector"),
  }
  
  # Results view shortcuts
  RESULTS_VIEW_SHORTCUTS = {
      "focus_search": ("Ctrl+F", "Cmd+F", "Focus search box"),
      "clear_filters": ("Ctrl+Shift+F", "Cmd+Shift+F", "Clear all filters"),
      "select_all": ("Ctrl+A", "Cmd+A", "Select all results"),
      "copy_selected": ("Ctrl+C", "Cmd+C", "Copy selected results"),
      "view_candidates": ("Enter", "Enter", "View candidates for selected track"),
      "next_result": ("Down", "Down", "Move to next result"),
      "previous_result": ("Up", "Up", "Move to previous result"),
      "first_result": ("Home", "Home", "Move to first result"),
      "last_result": ("End", "End", "Move to last result"),
  }
  
  # Dialog shortcuts
  DIALOG_SHORTCUTS = {
      "confirm": ("Enter", "Enter", "Confirm dialog"),
      "cancel": ("Esc", "Esc", "Cancel dialog"),
      "close": ("Ctrl+W", "Cmd+W", "Close dialog"),
  }
  ```
- **Shortcut Discoverability**:
  - **Help Menu**: "Keyboard Shortcuts" menu item opens shortcuts dialog
  - **Shortcuts Dialog**: Comprehensive list of all shortcuts with search
  - **Tooltips**: Show keyboard shortcuts in tooltips (e.g., "Open (Ctrl+O)")
  - **Menu Items**: Show keyboard shortcuts next to menu items
  - **Context Help**: Show relevant shortcuts in context
- **Shortcut Implementation Enhancement**:
  ```python
  class ShortcutManager(QObject):
      """Enhanced shortcut manager with accessibility features."""
      
      shortcut_changed = Signal(str, str)  # shortcut_id, new_sequence
      shortcut_conflict = Signal(str, str, str)  # shortcut_id, conflicting_id, sequence
      
      def register_shortcut(
          self,
          shortcut_id: str,
          sequence: str,
          action: Callable,
          context: str = ShortcutContext.GLOBAL,
          description: str = "",
          discoverable: bool = True
      ):
          """Register a keyboard shortcut with full metadata."""
          # Convert platform-specific sequence
          if sys.platform == "darwin":
              sequence = sequence.replace("Ctrl+", "Cmd+")
          
          # Check for conflicts
          conflicting = self._check_conflicts(shortcut_id, sequence, context)
          if conflicting:
              self.shortcut_conflict.emit(shortcut_id, conflicting, sequence)
              # Log warning but allow (user can customize)
          
          # Create shortcut
          key_sequence = QKeySequence(sequence)
          shortcut = QShortcut(key_sequence, self.parent_widget)
          shortcut.activated.connect(action)
          
          # Store metadata
          self.shortcuts[shortcut_id] = {
              "shortcut": shortcut,
              "sequence": sequence,
              "action": action,
              "context": context,
              "description": description,
              "discoverable": discoverable,
          }
      
      def get_shortcut_info(self, shortcut_id: str) -> Dict:
          """Get shortcut information for display."""
          return self.shortcuts.get(shortcut_id, {})
      
      def get_all_shortcuts(self, context: Optional[str] = None) -> Dict[str, Dict]:
          """Get all shortcuts, optionally filtered by context."""
          if context:
              return {
                  sid: info
                  for sid, info in self.shortcuts.items()
                  if info["context"] == context
              }
          return self.shortcuts.copy()
      
      def show_shortcuts_dialog(self):
          """Show keyboard shortcuts dialog."""
          from cuepoint.ui.dialogs.shortcuts_dialog import ShortcutsDialog
          dialog = ShortcutsDialog(self.get_all_shortcuts(), self)
          dialog.exec()
  ```
- **Shortcut Customization**:
  - **Settings Integration**: Allow users to customize shortcuts in settings
  - **Conflict Detection**: Warn users about shortcut conflicts
  - **Reset to Defaults**: Option to reset all shortcuts to defaults
  - **Import/Export**: Allow users to import/export shortcut configurations
  - **Validation**: Ensure custom shortcuts are valid and don't conflict
- **Shortcut Documentation**:
  - **In-App Dialog**: Comprehensive shortcuts dialog with search
  - **User Guide**: Document all shortcuts in user guide
  - **Tooltips**: Show shortcuts in tooltips
  - **Menu Items**: Show shortcuts in menus
- **Benefits**:
  - Improved efficiency for power users
  - Better discoverability
  - Customizable for user needs
  - Accessibility compliance
  - Better user experience

**9.2.1.3 Focus Management System**
- **Purpose**: Implement comprehensive focus management that ensures focus is always visible, predictable, and properly managed across all UI states and transitions.
- **Rationale**:
  - Visible focus is essential for keyboard navigation
  - Focus management prevents focus loss and confusion
  - Proper focus handling improves accessibility
  - Focus indicators must meet contrast requirements
  - Focus management is required for accessibility compliance
- **Implementation Location**: `SRC/cuepoint/ui/widgets/focus_manager.py` (new), enhance existing widgets
- **Focus Indicator Requirements**:
  - **Visibility**: Focus indicators must be clearly visible (3:1 contrast minimum)
  - **Size**: Focus rings must be at least 2px wide
  - **Offset**: Focus rings should have offset (3px) for better visibility
  - **Color**: Focus ring color must contrast with background
  - **Style**: Focus indicators should be consistent across all controls
- **Focus Indicator Implementation**:
  ```python
  # In stylesheet
  QPushButton:focus,
  QLineEdit:focus,
  QComboBox:focus,
  QCheckBox:focus,
  QRadioButton:focus {
      outline: 3px solid {colors.focus_ring}40;  /* 40 = 25% opacity */
      outline-offset: 2px;
  }
  
  QPushButton:focus {
      border: 2px solid {colors.focus_ring};
  }
  
  QLineEdit:focus,
  QComboBox:focus {
      border: 2px solid {colors.focus_ring};
  }
  
  QTableView::item:focus {
      border: 2px solid {colors.focus_ring};
      background-color: {colors.selection};
  }
  ```
- **Focus Management Functions**:
  ```python
  class FocusManager:
      """Manages focus behavior and visibility."""
      
      def ensure_focus_visible(self, widget: QWidget):
          """Ensure focus indicator is visible on widget."""
          widget.setFocusPolicy(Qt.StrongFocus)
          widget.setFocus()
          
          # Scroll to widget if needed
          self._scroll_to_widget(widget)
      
      def trap_focus(self, container: QWidget, widgets: List[QWidget]):
          """Trap focus within a container (e.g., modal dialog)."""
          # Set focus policy
          for widget in widgets:
              widget.setFocusPolicy(Qt.StrongFocus)
          
          # Handle Tab key to cycle within container
          def handle_tab(event):
              if event.key() == Qt.Key_Tab:
                  current = container.focusWidget()
                  if current in widgets:
                      index = widgets.index(current)
                      next_index = (index + 1) % len(widgets)
                      widgets[next_index].setFocus()
                      event.accept()
                      return True
              return False
          
          container.keyPressEvent = handle_tab
      
      def restore_focus(self, widget: QWidget):
          """Restore focus to widget after dialog/modal closes."""
          if widget and widget.isVisible():
              widget.setFocus()
      
      def _scroll_to_widget(self, widget: QWidget):
          """Scroll widget into view if in scrollable container."""
          parent = widget.parent()
          while parent:
              if isinstance(parent, QScrollArea):
                  parent.ensureWidgetVisible(widget)
                  break
              parent = parent.parent()
  ```
- **Focus Best Practices**:
  - Always show focus indicators (never hide with CSS)
  - Maintain focus during state transitions
  - Restore focus after dialogs close
  - Trap focus in modal dialogs
  - Scroll focused elements into view
  - Handle focus for dynamic content
- **Focus Testing**:
  - Test all interactive elements receive focus
  - Test focus indicators are visible
  - Test focus order matches tab order
  - Test focus in modal dialogs
  - Test focus restoration
  - Test focus with screen readers
- **Benefits**:
  - Clear focus visibility
  - Predictable focus behavior
  - Accessibility compliance
  - Better keyboard navigation
  - Improved user experience

### Task 9.2.2: Implement Screen Reader Support

**What to Build**
- Comprehensive accessible names and descriptions
- Proper ARIA roles and properties (Qt equivalents)
- Semantic markup and structure
- Screen reader testing procedures
- Accessible widget implementation

**Implementation Details**

**9.2.2.1 Accessible Name and Description System**
- **Purpose**: Ensure all interactive elements have proper accessible names and descriptions that screen readers can announce, providing context and meaning to users who cannot see the interface.
- **Rationale**:
  - Screen readers rely on accessible names to identify elements
  - Accessible descriptions provide additional context
  - Proper naming is essential for accessibility compliance
  - Names must be concise but descriptive
  - Descriptions should provide context without redundancy
- **Implementation Location**: Enhance all UI widgets, create `SRC/cuepoint/ui/widgets/accessibility.py` (new)
- **Accessible Name Requirements**:
  - **Buttons**: Descriptive action name (e.g., "Start Processing", not "Button")
  - **Input Fields**: Associated label text (use QLabel with buddy)
  - **Checkboxes/Radio Buttons**: Associated label text
  - **Tables**: Descriptive table name, column headers
  - **Links**: Descriptive link text
  - **Icons**: Text alternative or aria-label
- **Accessible Name Implementation**:
  ```python
  from PySide6.QtWidgets import QWidget, QLabel, QPushButton, QLineEdit
  from PySide6.QtCore import Qt
  
  class AccessibilityHelper:
      """Helper for setting accessible names and descriptions."""
      
      @staticmethod
      def set_accessible_name(widget: QWidget, name: str):
          """Set accessible name for widget."""
          widget.setAccessibleName(name)
      
      @staticmethod
      def set_accessible_description(widget: QWidget, description: str):
          """Set accessible description for widget."""
          widget.setAccessibleDescription(description)
      
      @staticmethod
      def set_label_buddy(label: QLabel, widget: QWidget):
          """Associate label with widget for accessibility."""
          label.setBuddy(widget)
          # Qt automatically uses label text as accessible name
  
  # Usage examples
  # Button with accessible name
  start_button = QPushButton("Start Processing")
  AccessibilityHelper.set_accessible_name(
      start_button,
      "Start processing selected playlist"
  )
  AccessibilityHelper.set_accessible_description(
      start_button,
      "Begins processing the selected playlist to find Beatport metadata"
  )
  
  # Input field with label buddy
  file_label = QLabel("Collection XML File:")
  file_input = QLineEdit()
  file_label.setBuddy(file_input)  # Label text becomes accessible name
  AccessibilityHelper.set_accessible_description(
      file_input,
      "Path to Rekordbox collection XML file"
  )
  
  # Table with accessible name
  results_table = QTableWidget()
  AccessibilityHelper.set_accessible_name(
      results_table,
      "Processing Results Table"
  )
  AccessibilityHelper.set_accessible_description(
      results_table,
      "Table showing processing results with columns: Track, Artist, Status, Confidence"
  )
  ```
- **Accessible Name Guidelines**:
  - **Be Descriptive**: Names should clearly describe the element's purpose
  - **Be Concise**: Names should be brief but informative
  - **Avoid Redundancy**: Don't repeat information (e.g., "Button" suffix)
  - **Use Context**: Include context when helpful (e.g., "Start Processing Playlist")
  - **Match Visual Text**: Accessible names should match or complement visible text
  - **Provide Descriptions**: Use descriptions for additional context
- **Table Accessibility**:
  ```python
  # Table with proper headers
  table = QTableWidget()
  table.setColumnCount(4)
  table.setHorizontalHeaderLabels([
      "Track Name",
      "Artist",
      "Status",
      "Confidence"
  ])
  
  # Set accessible name for table
  AccessibilityHelper.set_accessible_name(
      table,
      "Processing Results"
  )
  
  # Set accessible names for headers
  for col in range(table.columnCount()):
      header = table.horizontalHeaderItem(col)
      if header:
          AccessibilityHelper.set_accessible_name(
              header,
              f"Column {col + 1}: {header.text()}"
          )
  
  # Set accessible names for cells (if needed)
  for row in range(table.rowCount()):
      for col in range(table.columnCount()):
          item = table.item(row, col)
          if item:
              # Accessible name is usually the cell text
              # Add description if needed
              if col == 3:  # Confidence column
                  AccessibilityHelper.set_accessible_description(
                      item,
                      f"Confidence score: {item.text()}%"
                  )
  ```
- **Benefits**:
  - Screen reader compatibility
  - Accessibility compliance
  - Better user experience for blind users
  - Clear element identification
  - Contextual information

**9.2.2.2 Semantic Structure and Roles**
- **Purpose**: Ensure UI structure is semantically correct, with proper roles and relationships that screen readers can understand and navigate.
- **Rationale**:
  - Semantic structure helps screen readers understand UI
  - Proper roles identify element types
  - Relationships (labels, groups) provide context
  - Semantic structure improves navigation
  - Required for accessibility compliance
- **Implementation**: Use Qt's built-in semantic roles and proper widget hierarchy
- **Semantic Roles**:
  - **Buttons**: Use QPushButton (automatic role)
  - **Input Fields**: Use QLineEdit, QTextEdit (automatic role)
  - **Checkboxes**: Use QCheckBox (automatic role)
  - **Radio Buttons**: Use QRadioButton with QButtonGroup (automatic role)
  - **Tables**: Use QTableWidget with headers (automatic role)
  - **Lists**: Use QListWidget (automatic role)
  - **Groups**: Use QGroupBox for related controls
  - **Labels**: Use QLabel with buddy for form fields
- **Grouping Controls**:
  ```python
  # Radio button group with proper semantics
  mode_group = QButtonGroup()
  single_radio = QRadioButton("Single Playlist")
  batch_radio = QRadioButton("Batch Processing")
  
  mode_group.addButton(single_radio, 0)
  mode_group.addButton(batch_radio, 1)
  
  # Group box provides semantic grouping
  mode_groupbox = QGroupBox("Processing Mode")
  mode_layout = QVBoxLayout()
  mode_layout.addWidget(single_radio)
  mode_layout.addWidget(batch_radio)
  mode_groupbox.setLayout(mode_layout)
  
  # Set accessible name for group
  AccessibilityHelper.set_accessible_name(
      mode_groupbox,
      "Processing Mode Selection"
  )
  AccessibilityHelper.set_accessible_description(
      mode_groupbox,
      "Choose between single playlist or batch processing mode"
  )
  ```
- **Form Structure**:
  ```python
  # Proper form structure with labels
  form_layout = QFormLayout()
  
  # File selector with label
  file_label = QLabel("Collection XML File:")
  file_input = QLineEdit()
  file_browse = QPushButton("Browse...")
  file_label.setBuddy(file_input)  # Associates label with input
  form_layout.addRow(file_label, file_input)
  
  # Playlist selector with label
  playlist_label = QLabel("Playlist:")
  playlist_combo = QComboBox()
  playlist_label.setBuddy(playlist_combo)
  form_layout.addRow(playlist_label, playlist_combo)
  ```
- **Benefits**:
  - Proper semantic structure
  - Screen reader compatibility
  - Better navigation
  - Accessibility compliance
  - Clear relationships

### Task 9.2.3: Implement Contrast and Sizing Compliance

**What to Build**
- WCAG contrast compliance validation
- Minimum text size enforcement
- Touch target size compliance
- Color contrast testing procedures
- Accessibility validation tools

**Implementation Details**

**9.2.3.1 Contrast Compliance System**
- **Purpose**: Ensure all text and UI elements meet WCAG 2.1 AA contrast requirements (4.5:1 for normal text, 3:1 for large text, 3:1 for UI components).
- **Rationale**:
  - Contrast requirements ensure text is readable
  - Low contrast causes eye strain and accessibility issues
  - WCAG compliance is required for accessibility
  - Automated checking prevents regressions
  - Contrast affects all users, not just those with disabilities
- **Implementation Location**: `SRC/cuepoint/utils/accessibility.py` (new)
- **Contrast Calculation**:
  ```python
  import colorsys
  
  def hex_to_rgb(hex_color: str) -> Tuple[int, int, int]:
      """Convert hex color to RGB tuple."""
      hex_color = hex_color.lstrip('#')
      return tuple(int(hex_color[i:i+2], 16) for i in (0, 2, 4))
  
  def get_luminance(r: int, g: int, b: int) -> float:
      """Calculate relative luminance (WCAG formula)."""
      def to_linear(c):
          c = c / 255.0
          if c <= 0.03928:
              return c / 12.92
          return ((c + 0.055) / 1.055) ** 2.4
      
      r_linear = to_linear(r)
      g_linear = to_linear(g)
      b_linear = to_linear(b)
      
      return 0.2126 * r_linear + 0.7152 * g_linear + 0.0722 * b_linear
  
  def get_contrast_ratio(color1: str, color2: str) -> float:
      """Calculate contrast ratio between two colors."""
      rgb1 = hex_to_rgb(color1)
      rgb2 = hex_to_rgb(color2)
      
      lum1 = get_luminance(*rgb1)
      lum2 = get_luminance(*rgb2)
      
      lighter = max(lum1, lum2)
      darker = min(lum1, lum2)
      
      return (lighter + 0.05) / (darker + 0.05)
  
  def check_contrast(
      foreground: str,
      background: str,
      level: str = "AA",
      text_size: str = "normal"
  ) -> Tuple[bool, float]:
      """
      Check if color combination meets contrast requirements.
      
      Args:
          foreground: Foreground color (hex)
          background: Background color (hex)
          level: WCAG level ("AA" or "AAA")
          text_size: Text size ("normal" or "large")
      
      Returns:
          Tuple of (meets_requirements, contrast_ratio)
      """
      ratio = get_contrast_ratio(foreground, background)
      
      # WCAG requirements
      if level == "AA":
          if text_size == "normal":
              required = 4.5
          else:  # large text
              required = 3.0
      else:  # AAA
          if text_size == "normal":
              required = 7.0
          else:  # large text
              required = 4.5
      
      return ratio >= required, ratio
  ```
- **Contrast Validation**:
  ```python
  class ContrastValidator:
      """Validates contrast for all color combinations."""
      
      def __init__(self, theme_tokens):
          self.theme = theme_tokens
          self.violations = []
      
      def validate_all(self) -> List[Dict]:
          """Validate all color combinations in theme."""
          violations = []
          
          # Text on background
          ratio, meets = check_contrast(
              self.theme.colors.text_primary,
              self.theme.colors.background,
              "AA", "normal"
          )
          if not meets:
              violations.append({
                  "type": "text_primary_on_background",
                  "ratio": ratio,
                  "required": 4.5,
                  "foreground": self.theme.colors.text_primary,
                  "background": self.theme.colors.background,
              })
          
          # Text on surface
          ratio, meets = check_contrast(
              self.theme.colors.text_primary,
              self.theme.colors.surface,
              "AA", "normal"
          )
          if not meets:
              violations.append({
                  "type": "text_primary_on_surface",
                  "ratio": ratio,
                  "required": 4.5,
              })
          
          # Secondary text
          ratio, meets = check_contrast(
              self.theme.colors.text_secondary,
              self.theme.colors.background,
              "AA", "normal"
          )
          if not meets:
              violations.append({
                  "type": "text_secondary_on_background",
                  "ratio": ratio,
                  "required": 4.5,
              })
          
          # Disabled text (must still be readable)
          ratio, meets = check_contrast(
              self.theme.colors.text_disabled,
              self.theme.colors.background,
              "AA", "normal"
          )
          if not meets:
              violations.append({
                  "type": "text_disabled_on_background",
                  "ratio": ratio,
                  "required": 4.5,
                  "note": "Disabled text must still be readable",
              })
          
          # Focus ring
          ratio, meets = check_contrast(
              self.theme.colors.focus_ring,
              self.theme.colors.background,
              "AA", "normal"
          )
          if not meets:
              violations.append({
                  "type": "focus_ring_on_background",
                  "ratio": ratio,
                  "required": 3.0,  # UI components need 3:1
              })
          
          return violations
  ```
- **Contrast Testing**:
  - **Automated Testing**: Run contrast validation in CI/CD
  - **Manual Testing**: Visual inspection with contrast checkers
  - **Screen Reader Testing**: Test with screen readers
  - **User Testing**: Test with users who have low vision
- **Benefits**:
  - WCAG compliance
  - Improved readability
  - Better accessibility
  - Automated validation
  - Prevents regressions

**9.2.3.2 Minimum Size Compliance**
- **Purpose**: Ensure all interactive elements meet minimum size requirements for touch accessibility and usability (28px minimum touch target, 24px minimum click target).
- **Rationale**:
  - Minimum sizes ensure touch accessibility
  - Larger targets are easier to use
  - Size requirements improve usability for all users
  - WCAG 2.5.5 requires minimum touch target sizes
  - Consistent sizing improves visual consistency
- **Implementation**: Use size tokens from theme system (Step 9.1)
- **Size Requirements**:
  - **Touch Targets**: 28px minimum (WCAG 2.5.5)
  - **Click Targets**: 24px minimum (desktop)
  - **Spacing**: 8px minimum between touch targets
  - **Text Size**: 10px minimum for any user-visible text
- **Size Validation**:
  ```python
  class SizeValidator:
      """Validates minimum sizes for accessibility."""
      
      MIN_TOUCH_TARGET = 28  # pixels
      MIN_CLICK_TARGET = 24  # pixels
      MIN_TEXT_SIZE = 10     # pixels
      MIN_SPACING = 8        # pixels between targets
      
      def validate_widget(self, widget: QWidget) -> List[str]:
          """Validate widget meets size requirements."""
          violations = []
          
          size = widget.size()
          min_size = min(size.width(), size.height())
          
          if min_size < self.MIN_TOUCH_TARGET:
              violations.append(
                  f"Widget {widget.objectName()} has size {min_size}px, "
                  f"minimum is {self.MIN_TOUCH_TARGET}px"
              )
          
          # Check font size if text widget
          font = widget.font()
          font_size = font.pixelSize() or font.pointSize() * 1.33  # Approximate
          if font_size < self.MIN_TEXT_SIZE:
              violations.append(
                  f"Widget {widget.objectName()} has font size {font_size}px, "
                  f"minimum is {self.MIN_TEXT_SIZE}px"
              )
          
          return violations
  ```
- **Benefits**:
  - Touch accessibility compliance
  - Improved usability
  - WCAG compliance
  - Better user experience
  - Consistent sizing

### Task 9.2.4: Implement Accessibility Testing Procedures

**What to Build**
- Comprehensive accessibility testing checklist
- Automated accessibility validation
- Screen reader testing procedures
- Keyboard navigation testing
- Accessibility audit procedures

**Implementation Details**

**9.2.4.1 Accessibility Testing Checklist**
- **Purpose**: Comprehensive checklist to ensure all accessibility requirements are met before release.
- **Checklist Items**:
  - ✅ All interactive elements keyboard accessible
  - ✅ Logical tab order implemented
  - ✅ Focus indicators visible on all elements
  - ✅ All elements have accessible names
  - ✅ Form fields have associated labels
  - ✅ Tables have proper headers
  - ✅ All text meets contrast requirements (4.5:1)
  - ✅ All interactive elements meet minimum size (28px)
  - ✅ Keyboard shortcuts documented and discoverable
  - ✅ Screen reader tested (NVDA/JAWS/VoiceOver)
  - ✅ No keyboard traps
  - ✅ Focus management works correctly
  - ✅ Error messages are accessible
  - ✅ Status messages are announced
  - ✅ Dynamic content updates are announced
- **Testing Procedures**:
  - **Keyboard Testing**: Navigate entire application using only keyboard
  - **Screen Reader Testing**: Test with NVDA (Windows), VoiceOver (macOS), JAWS (Windows)
  - **Contrast Testing**: Validate all color combinations
  - **Size Testing**: Verify all interactive elements meet size requirements
  - **Focus Testing**: Verify focus indicators and focus management
- **Benefits**:
  - Comprehensive accessibility validation
  - Release readiness assurance
  - Compliance verification
  - User experience validation

## Success Criteria

### Accessibility Goals
- ✅ Full keyboard navigation implemented
- ✅ All shortcuts discoverable and documented
- ✅ Screen reader support complete
- ✅ WCAG 2.1 AA compliance achieved
- ✅ All contrast requirements met
- ✅ Minimum size requirements met
- ✅ Focus management working correctly
- ✅ Accessibility tested and validated

### Validation Methods
- Automated accessibility testing
- Screen reader testing
- Keyboard navigation testing
- Contrast validation
- Size validation
- User testing with assistive technologies

## Implementation Files

### Accessibility Infrastructure
1. `SRC/cuepoint/ui/widgets/focus_manager.py` - Focus management (new)
2. `SRC/cuepoint/ui/widgets/accessibility.py` - Accessibility helpers (new)
3. `SRC/cuepoint/utils/accessibility.py` - Accessibility utilities (new)
4. `SRC/cuepoint/ui/widgets/shortcut_manager.py` - Shortcut system (enhance existing)
5. `SRC/cuepoint/ui/dialogs/shortcuts_dialog.py` - Shortcuts dialog (new)

### Testing and Validation
1. `scripts/validate_accessibility.py` - Accessibility validation script (new)
2. `tests/ui/test_keyboard_navigation.py` - Keyboard navigation tests (new)
3. `tests/ui/test_screen_reader.py` - Screen reader tests (new)
4. `tests/ui/test_contrast.py` - Contrast validation tests (new)

## Dependencies

### Prerequisites
- Step 9.1: Visual Consistency (provides theme tokens for contrast)
- Basic UI components implemented
- Qt/PySide6 accessibility features

### Enables
- Accessibility compliance
- Inclusive user experience
- WCAG 2.1 AA compliance
- Screen reader compatibility
- Keyboard-only usability

## References

- WCAG 2.1: https://www.w3.org/WAI/WCAG21/quickref/
- Section 508: https://www.section508.gov/
- Qt Accessibility: https://doc.qt.io/qt-6/accessible.html
- ARIA Authoring Practices: https://www.w3.org/WAI/ARIA/apg/
- Keyboard Navigation Guidelines: https://www.w3.org/WAI/WCAG21/Understanding/keyboard.html
