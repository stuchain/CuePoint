# Implementation Step 9.3: Localization Readiness

## Implementation Overview
**What We're Building**: A comprehensive localization readiness infrastructure that prepares CuePoint for future internationalization (i18n) and localization (l10n) without requiring full translation in v1.0. This includes implementing Qt's translation system (QTranslator), centralizing all user-visible strings, creating translation file structure (.ts/.qm), implementing locale-sensitive formatting, and establishing a localization workflow. While v1.0 ships with English only, the infrastructure ensures that adding translations in future versions is straightforward and that the application is architected to support multiple languages from the start, avoiding costly refactoring later.

## Implementation Tasks

### Task 9.3.1: Implement String Centralization System

**What to Build**
- String extraction and centralization infrastructure
- Translation key naming conventions
- String context and disambiguation
- String table organization
- String usage patterns and best practices
- String validation and completeness checking

**Implementation Details**

**9.3.1.1 Translation Key System**
- **Purpose**: Create a centralized system for managing all user-visible strings with translation keys, context, and organization that makes it easy to extract, translate, and maintain strings.
- **Rationale**:
  - Centralized strings prevent hardcoded text throughout codebase
  - Translation keys enable easy translation management
  - String context helps translators understand usage
  - Organized string tables improve maintainability
  - Centralized strings make it easy to update text globally
- **Implementation Location**: `SRC/cuepoint/utils/i18n.py` (new), `SRC/cuepoint/utils/translations.py` (new)
- **Translation Key Structure**:
  ```python
  # Translation keys organized by module/feature
  TRANSLATION_KEYS = {
      # Main window
      "main_window.title": "CuePoint - Beatport Metadata Enricher",
      "main_window.file_selector.label": "Collection XML File:",
      "main_window.file_selector.browse": "Browse...",
      "main_window.file_selector.info": "Select your Rekordbox collection XML file",
      
      # Processing mode
      "mode.single.label": "Single Playlist",
      "mode.single.description": "Process a single playlist",
      "mode.batch.label": "Batch Processing",
      "mode.batch.description": "Process multiple playlists",
      
      # Playlist selector
      "playlist.selector.label": "Playlist:",
      "playlist.selector.none": "No playlist selected",
      "playlist.selector.loading": "Loading playlists...",
      
      # Buttons
      "button.start": "Start Processing",
      "button.cancel": "Cancel",
      "button.export": "Export Results",
      "button.browse": "Browse...",
      "button.close": "Close",
      "button.save": "Save",
      "button.reset": "Reset",
      
      # Status messages
      "status.processing": "Processing...",
      "status.complete": "Processing complete",
      "status.error": "Error occurred",
      "status.no_results": "No results found",
      
      # Results view
      "results.title": "Results",
      "results.search.placeholder": "Search results...",
      "results.column.track": "Track",
      "results.column.artist": "Artist",
      "results.column.status": "Status",
      "results.column.confidence": "Confidence",
      
      # Dialogs
      "dialog.error.title": "Error",
      "dialog.error.message": "An error occurred",
      "dialog.confirm.title": "Confirm",
      "dialog.confirm.message": "Are you sure?",
      
      # Menu items
      "menu.file": "File",
      "menu.file.open": "Open XML File",
      "menu.file.export": "Export Results",
      "menu.file.quit": "Quit",
      "menu.edit": "Edit",
      "menu.view": "View",
      "menu.help": "Help",
      "menu.help.about": "About CuePoint",
      "menu.help.shortcuts": "Keyboard Shortcuts",
      
      # Settings
      "settings.title": "Settings",
      "settings.general": "General",
      "settings.advanced": "Advanced",
      "settings.cache": "Cache",
      
      # Error messages
      "error.file_not_found": "File not found: {path}",
      "error.invalid_xml": "Invalid XML file: {reason}",
      "error.network": "Network error: {message}",
      "error.unknown": "An unknown error occurred",
  }
  ```
- **Translation Function Implementation**:
  ```python
  from PySide6.QtCore import QCoreApplication, QLocale, QTranslator
  from typing import Optional, Dict
  
  class TranslationManager:
      """Manages translations and string localization."""
      
      _instance: Optional['TranslationManager'] = None
      _translator: Optional[QTranslator] = None
      _current_locale: str = "en"
      _translations: Dict[str, str] = {}
      
      def __new__(cls):
          """Singleton pattern."""
          if cls._instance is None:
              cls._instance = super().__new__(cls)
              cls._instance._initialize()
          return cls._instance
      
      def _initialize(self):
          """Initialize translation system."""
          # Load default English strings
          self._translations = TRANSLATION_KEYS.copy()
          
          # Set up Qt translator
          self._translator = QTranslator()
          app = QCoreApplication.instance()
          if app:
              app.installTranslator(self._translator)
      
      def set_locale(self, locale: str):
          """Set application locale and load translations."""
          self._current_locale = locale
          
          if locale == "en":
              # English is default, no translation file needed
              return
          
          # Load translation file (.qm)
          translation_file = f"translations/cuepoint_{locale}.qm"
          if self._translator.load(translation_file):
              # Translation loaded successfully
              pass
          else:
              # Fall back to English if translation not found
              print(f"Warning: Translation file not found: {translation_file}")
      
      def translate(self, key: str, context: Optional[str] = None, **kwargs) -> str:
          """
          Translate a string key to current locale.
          
          Args:
              key: Translation key
              context: Optional context for disambiguation
              **kwargs: Format arguments for string formatting
          
          Returns:
              Translated string
          """
          # Get translation
          if context:
              # Use Qt's translation with context
              translated = QCoreApplication.translate(context, key)
          else:
              # Use our translation dictionary
              translated = self._translations.get(key, key)
          
          # Format with arguments if provided
          if kwargs:
              try:
                  translated = translated.format(**kwargs)
              except KeyError:
                  # Missing format argument, return as-is
                  pass
          
          return translated
      
      def get_current_locale(self) -> str:
          """Get current locale."""
          return self._current_locale
      
      def get_available_locales(self) -> List[str]:
          """Get list of available locales."""
          # For v1.0, only English is available
          return ["en"]
  
  # Convenience function
  def tr(key: str, context: Optional[str] = None, **kwargs) -> str:
      """Translate a string key."""
      manager = TranslationManager()
      return manager.translate(key, context, **kwargs)
  ```
- **String Usage Pattern**:
  ```python
  from cuepoint.utils.i18n import tr
  
  # Simple translation
  button_text = tr("button.start")
  
  # Translation with format arguments
  error_message = tr("error.file_not_found", path="/path/to/file")
  
  # Translation with context (for disambiguation)
  save_button = tr("button.save", context="dialog")
  save_menu = tr("button.save", context="menu")
  
  # In Qt widgets
  button = QPushButton(tr("button.start"))
  label = QLabel(tr("main_window.file_selector.label"))
  ```
- **String Organization Principles**:
  - **Hierarchical Keys**: Use dot notation for organization (e.g., "main_window.file_selector.label")
  - **Context Prefixes**: Prefix keys with module/feature name
  - **Descriptive Names**: Use descriptive key names that indicate purpose
  - **Consistent Naming**: Follow consistent naming conventions
  - **Group Related Strings**: Group related strings together
- **Benefits**:
  - Centralized string management
  - Easy to extract for translation
  - Easy to update text globally
  - Translation-ready infrastructure
  - Maintainable string organization

**9.3.1.2 String Extraction System**
- **Purpose**: Create tools and procedures to extract all user-visible strings from the codebase, identify hardcoded strings, and generate translation files.
- **Rationale**:
  - Automated extraction ensures no strings are missed
  - Extraction tools identify hardcoded strings
  - Translation files can be generated automatically
  - Extraction process can be integrated into CI/CD
  - Regular extraction catches new strings
- **Implementation Location**: `scripts/extract_strings.py` (new)
- **String Extraction Script**:
  ```python
  #!/usr/bin/env python3
  """Extract all user-visible strings from codebase for translation."""
  
  import ast
  import re
  from pathlib import Path
  from typing import List, Dict, Tuple
  from collections import defaultdict
  
  class StringExtractor:
      """Extracts strings from Python source files."""
      
      def __init__(self, source_dir: Path):
          self.source_dir = source_dir
          self.strings: Dict[str, List[Tuple[str, int]]] = defaultdict(list)
      
      def extract_from_file(self, file_path: Path) -> Dict[str, List[Tuple[str, int]]]:
          """Extract strings from a Python file."""
          strings = defaultdict(list)
          
          try:
              with open(file_path, 'r', encoding='utf-8') as f:
                  content = f.read()
                  tree = ast.parse(content, filename=str(file_path))
          
              # Walk AST to find string literals
              for node in ast.walk(tree):
                  if isinstance(node, ast.Str):  # Python < 3.8
                      string_value = node.s
                      if self._is_user_visible(string_value):
                          strings[string_value].append((str(file_path), node.lineno))
                  elif isinstance(node, ast.Constant) and isinstance(node.value, str):  # Python 3.8+
                      string_value = node.value
                      if self._is_user_visible(string_value):
                          strings[string_value].append((str(file_path), node.lineno))
          
          except Exception as e:
              print(f"Error parsing {file_path}: {e}")
          
          return strings
      
      def _is_user_visible(self, string: str) -> bool:
          """Determine if a string is user-visible (needs translation)."""
          # Skip very short strings (likely not user-visible)
          if len(string) < 3:
              return False
          
          # Skip strings that are clearly not user-visible
          skip_patterns = [
              r'^[a-z_]+$',  # Variable names, function names
              r'^#[0-9a-fA-F]{3,6}$',  # Hex colors
              r'^\d+$',  # Numbers
              r'^https?://',  # URLs
              r'^[A-Z_]+$',  # Constants
          ]
          
          for pattern in skip_patterns:
              if re.match(pattern, string):
                  return False
          
          # Check if string contains letters (likely user-visible)
          if re.search(r'[a-zA-Z]', string):
              return True
          
          return False
      
      def extract_all(self) -> Dict[str, List[Tuple[str, int]]]:
          """Extract strings from all Python files in source directory."""
          all_strings = defaultdict(list)
          
          for py_file in self.source_dir.rglob("*.py"):
              # Skip test files and scripts
              if "test" in str(py_file) or "script" in str(py_file):
                  continue
              
              file_strings = self.extract_from_file(py_file)
              for string, locations in file_strings.items():
                  all_strings[string].extend(locations)
          
          return all_strings
      
      def generate_translation_template(self, output_file: Path):
          """Generate .ts (translation source) file template."""
          strings = self.extract_all()
          
          # Generate .ts file content
          ts_content = '<?xml version="1.0" encoding="utf-8"?>\n'
          ts_content += '<!DOCTYPE TS>\n'
          ts_content += '<TS version="2.1" language="en">\n'
          ts_content += '<context>\n'
          ts_content += '    <name>CuePoint</name>\n'
          
          for string, locations in sorted(strings.items()):
              # Escape XML
              escaped_string = string.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
              
              ts_content += f'    <message>\n'
              ts_content += f'        <source>{escaped_string}</source>\n'
              ts_content += f'        <translation type="unfinished"></translation>\n'
              ts_content += f'        <location'
              for file_path, line_no in locations[:3]:  # Limit to first 3 locations
                  ts_content += f' filename="{file_path}" line="{line_no}"'
              ts_content += '/>\n'
              ts_content += f'    </message>\n'
          
          ts_content += '</context>\n'
          ts_content += '</TS>\n'
          
          with open(output_file, 'w', encoding='utf-8') as f:
              f.write(ts_content)
          
          print(f"Generated translation template: {output_file}")
          print(f"Found {len(strings)} unique strings")
  
  if __name__ == "__main__":
      import sys
      
      source_dir = Path("SRC/cuepoint")
      output_file = Path("translations/cuepoint_en.ts")
      
      extractor = StringExtractor(source_dir)
      extractor.generate_translation_template(output_file)
  ```
- **String Extraction Workflow**:
  1. Run extraction script to find all strings
  2. Review extracted strings to identify user-visible strings
  3. Generate translation template (.ts file)
  4. Update code to use translation keys
  5. Re-run extraction to verify all strings are centralized
- **Benefits**:
  - Automated string discovery
  - Translation file generation
  - Hardcoded string detection
  - CI/CD integration
  - Regular validation

### Task 9.3.2: Implement Qt Translation System

**What to Build**
- Qt QTranslator integration
- Translation file loading and management
- Locale detection and selection
- Translation fallback handling
- Translation file structure and organization

**Implementation Details**

**9.3.2.1 QTranslator Integration**
- **Purpose**: Integrate Qt's QTranslator system to enable loading and using translation files (.qm files) for different locales.
- **Rationale**:
  - Qt's translation system is standard and well-supported
  - QTranslator handles locale detection and fallback
  - .ts/.qm file format is standard for Qt applications
  - Integration with Qt's tr() function is seamless
  - Supports pluralization and context
- **Implementation Location**: `SRC/cuepoint/utils/translations.py` (enhance existing)
- **QTranslator Setup**:
  ```python
  from PySide6.QtCore import QCoreApplication, QLocale, QTranslator
  from pathlib import Path
  from typing import Optional, List
  
  class QtTranslationManager:
      """Manages Qt translations using QTranslator."""
      
      def __init__(self, app: QCoreApplication):
          self.app = app
          self.translators: List[QTranslator] = []
          self.current_locale = "en"
      
      def load_translations(self, locale: str = None):
          """Load translations for specified locale or system locale."""
          if locale is None:
              locale = QLocale.system().name()  # e.g., "en_US", "fr_FR"
          
          # Extract language code (e.g., "en" from "en_US")
          language = locale.split('_')[0] if '_' in locale else locale
          self.current_locale = language
          
          # Remove existing translators
          for translator in self.translators:
              self.app.removeTranslator(translator)
          self.translators.clear()
          
          # Load translation file if not English
          if language != "en":
              translator = QTranslator()
              translation_file = f"translations/cuepoint_{language}.qm"
              
              if translator.load(translation_file):
                  self.app.installTranslator(translator)
                  self.translators.append(translator)
                  print(f"Loaded translation: {translation_file}")
              else:
                  print(f"Translation file not found: {translation_file}, using English")
      
      def get_current_locale(self) -> str:
          """Get current locale."""
          return self.current_locale
      
      def get_available_locales(self) -> List[str]:
          """Get list of available locales."""
          translations_dir = Path("translations")
          locales = ["en"]  # English is always available
        
          if translations_dir.exists():
              for qm_file in translations_dir.glob("cuepoint_*.qm"):
                  # Extract locale from filename: cuepoint_fr.qm -> fr
                  locale = qm_file.stem.replace("cuepoint_", "")
                  if locale not in locales:
                      locales.append(locale)
          
          return sorted(locales)
  
  # Global translation manager
  _translation_manager: Optional[QtTranslationManager] = None
  
  def initialize_translations(app: QCoreApplication, locale: str = None):
      """Initialize translation system for application."""
      global _translation_manager
      _translation_manager = QtTranslationManager(app)
      _translation_manager.load_translations(locale)
  
  def get_translation_manager() -> Optional[QtTranslationManager]:
      """Get global translation manager."""
      return _translation_manager
  ```
- **Application Integration**:
  ```python
  # In main.py or application entry point
  from PySide6.QtWidgets import QApplication
  from cuepoint.utils.translations import initialize_translations
  
  app = QApplication(sys.argv)
  
  # Initialize translations (loads system locale or specified locale)
  initialize_translations(app)
  
  # Or specify locale explicitly
  # initialize_translations(app, locale="fr")
  
  # Rest of application setup...
  ```
- **Using Qt's tr() Function**:
  ```python
  from PySide6.QtCore import QObject, tr as qt_tr
  
  class MyWidget(QWidget):
      def __init__(self):
          super().__init__()
          # Use Qt's tr() for automatic translation
          self.setWindowTitle(qt_tr("Main Window", "CuePoint"))
          button = QPushButton(qt_tr("Main Window", "Start Processing"))
  ```
- **Benefits**:
  - Standard Qt translation system
  - Automatic locale detection
  - Fallback handling
  - Pluralization support
  - Context support

**9.3.2.2 Translation File Structure**
- **Purpose**: Define the structure and organization of translation files (.ts source files and .qm compiled files).
- **Translation File Organization**:
  ```
  translations/
  ├── cuepoint_en.ts          # English source (master)
  ├── cuepoint_en.qm          # English compiled (optional, for consistency)
  ├── cuepoint_fr.ts          # French source (future)
  ├── cuepoint_fr.qm          # French compiled (future)
  ├── cuepoint_de.ts          # German source (future)
  ├── cuepoint_de.qm          # German compiled (future)
  └── README.md               # Translation instructions
  ```
- **Translation File Format (.ts)**:
  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <!DOCTYPE TS>
  <TS version="2.1" language="en">
  <context>
      <name>MainWindow</name>
      <message>
          <source>Start Processing</source>
          <translation>Start Processing</translation>
          <location filename="main_window.py" line="123"/>
      </message>
      <message>
          <source>Collection XML File:</source>
          <translation>Collection XML File:</translation>
          <location filename="main_window.py" line="45"/>
      </message>
  </context>
  <context>
      <name>ResultsView</name>
      <message>
          <source>No results found</source>
          <translation>No results found</translation>
      </message>
  </context>
  </TS>
  ```
- **Compiling Translation Files**:
  ```bash
  # Use Qt's lrelease tool to compile .ts to .qm
  lrelease translations/cuepoint_fr.ts -qm translations/cuepoint_fr.qm
  
  # Or use pylupdate6 to update .ts files from source
  pylupdate6 -no-obsolete cuepoint.pro -ts translations/cuepoint_en.ts
  ```
- **Translation Workflow**:
  1. Extract strings from source code
  2. Generate/update .ts file
  3. Send .ts file to translators
  4. Translators fill in translations
  5. Compile .ts to .qm using lrelease
  6. Include .qm files in application distribution
  7. Application loads .qm files based on locale
- **Benefits**:
  - Standard file format
  - Tool support (Qt Linguist)
  - Version control friendly
  - Easy translation workflow

### Task 9.3.3: Implement Locale-Sensitive Formatting

**What to Build**
- Locale-aware date/time formatting
- Locale-aware number formatting
- Locale-aware file path handling
- Locale detection and application
- Formatting utilities and helpers

**Implementation Details**

**9.3.3.1 Date and Time Formatting**
- **Purpose**: Format dates and times according to user's locale preferences, ensuring dates are displayed in familiar formats.
- **Rationale**:
  - Different locales use different date formats
  - Locale-appropriate formatting improves usability
  - Date formats vary (MM/DD/YYYY vs DD/MM/YYYY)
  - Time formats vary (12-hour vs 24-hour)
  - Locale-aware formatting is expected in professional applications
- **Implementation Location**: `SRC/cuepoint/utils/i18n.py` (extend existing)
- **Date/Time Formatting**:
  ```python
  from datetime import datetime
  from PySide6.QtCore import QLocale, QDate, QTime
  
  class LocaleFormatter:
      """Handles locale-sensitive formatting."""
      
      def __init__(self, locale: str = None):
          if locale:
              self.qt_locale = QLocale(locale)
          else:
              self.qt_locale = QLocale.system()
      
      def format_date(self, date: datetime, format_type: str = "short") -> str:
          """
          Format date according to locale.
          
          Args:
              date: datetime object
              format_type: "short", "long", or custom format string
          
          Returns:
              Formatted date string
          """
          qt_date = QDate(date.year, date.month, date.day)
          
          if format_type == "short":
              return self.qt_locale.toString(qt_date, QLocale.ShortFormat)
          elif format_type == "long":
              return self.qt_locale.toString(qt_date, QLocale.LongFormat)
          else:
              # Custom format
              return self.qt_locale.toString(qt_date, format_type)
      
      def format_time(self, time: datetime, format_type: str = "short") -> str:
          """
          Format time according to locale.
          
          Args:
              time: datetime object
              format_type: "short", "long", or custom format string
          
          Returns:
              Formatted time string
          """
          qt_time = QTime(time.hour, time.minute, time.second)
          
          if format_type == "short":
              return self.qt_locale.toString(qt_time, QLocale.ShortFormat)
          elif format_type == "long":
              return self.qt_locale.toString(qt_time, QLocale.LongFormat)
          else:
              # Custom format
              return self.qt_locale.toString(qt_time, format_type)
      
      def format_datetime(self, dt: datetime, format_type: str = "short") -> str:
          """Format datetime according to locale."""
          date_str = self.format_date(dt, format_type)
          time_str = self.format_time(dt, format_type)
          return f"{date_str} {time_str}"
  
  # Global formatter
  _formatter: Optional[LocaleFormatter] = None
  
  def get_formatter() -> LocaleFormatter:
      """Get global locale formatter."""
      global _formatter
      if _formatter is None:
          _formatter = LocaleFormatter()
      return _formatter
  
  # Convenience functions
  def format_date_locale(date: datetime, format_type: str = "short") -> str:
      """Format date according to current locale."""
      return get_formatter().format_date(date, format_type)
  
  def format_time_locale(time: datetime, format_type: str = "short") -> str:
      """Format time according to current locale."""
      return get_formatter().format_time(time, format_type)
  ```
- **Usage Examples**:
  ```python
  from cuepoint.utils.i18n import format_date_locale, format_time_locale
  from datetime import datetime
  
  now = datetime.now()
  
  # Format according to system locale
  date_str = format_date_locale(now)  # "12/14/2024" (US) or "14/12/2024" (UK)
  time_str = format_time_locale(now)  # "3:45 PM" (US) or "15:45" (24-hour)
  ```
- **Benefits**:
  - Locale-appropriate formatting
  - Improved usability
  - Professional appearance
  - User expectations met

**9.3.3.2 Number Formatting**
- **Purpose**: Format numbers (decimals, percentages, currency) according to locale preferences.
- **Implementation**:
  ```python
  class LocaleFormatter:
      def format_number(self, number: float, decimals: int = 2) -> str:
          """Format number according to locale."""
          return self.qt_locale.toString(number, 'f', decimals)
      
      def format_percentage(self, value: float, decimals: int = 1) -> str:
          """Format percentage according to locale."""
          percentage = value * 100
          formatted = self.format_number(percentage, decimals)
          return f"{formatted}%"
      
      def format_currency(self, amount: float, currency_code: str = "USD") -> str:
          """Format currency according to locale."""
          return self.qt_locale.toCurrencyString(amount, currency_code)
  ```
- **Benefits**:
  - Locale-appropriate number formatting
  - Consistent number display
  - Professional appearance

**9.3.3.3 File Path Handling**
- **Purpose**: Handle file paths in a locale-safe manner, ensuring file names remain filesystem-safe regardless of locale.
- **Implementation**:
  ```python
  import os
  from pathlib import Path
  
  def sanitize_filename(filename: str) -> str:
      """
      Sanitize filename to be filesystem-safe across locales.
      
      Removes or replaces characters that are problematic on different
      filesystems (e.g., colon on Windows, slash on Unix).
      """
      # Replace problematic characters
      replacements = {
          ':': '-',  # Colon problematic on Windows
          '/': '-',  # Slash problematic on Unix
          '\\': '-',  # Backslash problematic
          '<': '',
          '>': '',
          '"': '',
          '|': '',
          '?': '',
          '*': '',
      }
      
      sanitized = filename
      for old, new in replacements.items():
          sanitized = sanitized.replace(old, new)
      
      # Remove leading/trailing spaces and dots (problematic on Windows)
      sanitized = sanitized.strip(' .')
      
      return sanitized
  
  def format_export_filename(
      base_name: str,
      extension: str,
      timestamp: Optional[datetime] = None
  ) -> str:
      """Generate locale-safe export filename."""
      if timestamp is None:
          timestamp = datetime.now()
      
      # Format date in filesystem-safe way (YYYY-MM-DD)
      date_str = timestamp.strftime("%Y-%m-%d")
      time_str = timestamp.strftime("%H%M%S")
      
      # Sanitize base name
      safe_base = sanitize_filename(base_name)
      
      return f"{safe_base}_{date_str}_{time_str}.{extension}"
  ```
- **Benefits**:
  - Filesystem-safe file names
  - Cross-platform compatibility
  - Locale-independent file handling

### Task 9.3.4: Create Localization Workflow

**What to Build**
- Translation workflow documentation
- Translation tools and procedures
- Translation validation procedures
- Translation update process
- Localization testing procedures

**Implementation Details**

**9.3.4.1 Translation Workflow Documentation**
- **Purpose**: Document the complete workflow for adding new translations, updating existing translations, and maintaining translation files.
- **Workflow Steps**:
  1. **Extract Strings**: Run `scripts/extract_strings.py` to extract all strings
  2. **Update Translation Files**: Update .ts files with new strings
  3. **Send to Translators**: Provide .ts files to translators
  4. **Receive Translations**: Get back translated .ts files
  5. **Validate Translations**: Check translations for completeness and quality
  6. **Compile Translations**: Use `lrelease` to compile .ts to .qm
  7. **Test Translations**: Test application with translated locale
  8. **Include in Release**: Include .qm files in application distribution
- **Translation Tools**:
  - **Qt Linguist**: GUI tool for editing .ts files
  - **lrelease**: Command-line tool to compile .ts to .qm
  - **pylupdate6**: Tool to update .ts files from source code
  - **Custom Scripts**: String extraction and validation scripts
- **Translation Guidelines**:
  - Maintain context in translations
  - Preserve format placeholders ({}, %s, etc.)
  - Keep translations concise
  - Test translations in UI context
  - Verify all strings are translated
- **Benefits**:
  - Clear translation process
  - Consistent translation quality
  - Efficient workflow
  - Quality assurance

## Success Criteria

### Localization Readiness Goals
- ✅ All user-visible strings centralized
- ✅ Translation system implemented
- ✅ Translation file structure created
- ✅ Locale-sensitive formatting implemented
- ✅ Translation workflow documented
- ✅ String extraction tools created
- ✅ Translation infrastructure ready for future translations

### Validation Methods
- String extraction validation
- Translation file validation
- Locale formatting testing
- Translation workflow testing
- Code review for hardcoded strings

## Implementation Files

### Localization Infrastructure
1. `SRC/cuepoint/utils/i18n.py` - Internationalization utilities (new)
2. `SRC/cuepoint/utils/translations.py` - Translation management (new)
3. `translations/` - Translation files directory (new)
4. `translations/cuepoint_en.ts` - English translation source (new)
5. `translations/README.md` - Translation instructions (new)

### Tools and Scripts
1. `scripts/extract_strings.py` - String extraction script (new)
2. `scripts/update_translations.py` - Translation update script (new)
3. `scripts/validate_translations.py` - Translation validation script (new)

## Dependencies

### Prerequisites
- Step 9.1: Visual Consistency (string centralization affects UI)
- Basic UI components implemented
- Qt/PySide6 translation system

### Enables
- Future translation support
- International market readiness
- Locale-appropriate formatting
- Professional localization infrastructure

## References

- Qt Internationalization: https://doc.qt.io/qt-6/internationalization.html
- Qt Linguist: https://doc.qt.io/qt-6/qtlinguist-index.html
- Gettext: https://www.gnu.org/software/gettext/
- Unicode Locale Data: https://unicode.org/cldr/
